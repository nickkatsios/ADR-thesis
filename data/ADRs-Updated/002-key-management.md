## ADR 2: Key Management and Revealing MAC Keys

### Context

Previous versions of the OTR protocol use a mechanism called the Diffie-Hellman
ratchet (DH Ratchet) to ratchet key material when messages were exchanged. This
ratcheting approach consists of attaching new DH contributions to sent
messages: with each sent message, the sender advertises a new DH value. Message
keys are then computed from the latest acknowledged DH values.

This three step DH Ratchet works as follows:

1. Alice wants to send an encrypted message to Bob:
   * She picks the most recent of her own D-H encryption keys (`pubA`) that Bob
     has acknowledged receiving (by advertising it in a Data Message or in an
     AKE message).
   * If the above key is Alice's most recent key, she generates a new D-H key
     (`next_dh`).
   * She picks the most recent of Bob's D-H encryption keys (`pubB`) that she
     has received from him (either advertised in a Data Message or in an AKE
     message).
   * She uses Diffie-Hellman to compute a shared secret from the two keys
     (`pubA` and `pubB`), and a message key. She encrypts a message with the
     latest.
   * She sends the encrypted message to Bob and "advertises" her next
     Diffie-Hellman key `next_dh`.
2. Bob receives the encrypted message from Alice:
   * He uses Diffie-Hellman to compute a shared secret from the two keys
     (`pubA` and `pubB`), and a message key. He decrypts the message with the
     latest.
   * If he wants to send an encrypted message:
     * He "acknowledges" Alice's next Diffie-Hellman key `next_dh` as `pubA`.
     * He generates a new D-H key (`next_dh`).
     * He picks the most recent of Alice's D-H encryption keys (`pubA`) that
       he has received from her.
     * He uses Diffie-Hellman to compute a shared secret from the two keys
       (`pubA` and `pubB`), and a message key. He encrypts a message with the
       latest.
     * He sends the encrypted message to Alice and "advertises" his next
       Diffie-Hellman key `next_dh`.
 3. Alice receives the encrypted message from Bob and proceeds to decrypt it
    as previously stated.

This design introduces post-compromise secrecy within conversations since a
compromised key will be regularly replaced with new key material. A disadvantage
of this DH Ratchet is that session keys might not be renewed for every message
(forward secrecy is, therefore, only partially provided). It also
lacks out-of-order resilience: if a message arrives after a newly advertised
key is accepted, then the necessary decryption key will be already deleted and
the message will not be able to be decrypted.

In order to improve the forward secrecy of the DH Ratchet, two ratchet
approaches can be combined: session keys produced by DH ratchets are used to
seed per-participant KDF symmetric ratchets. Messages are then encrypted using
keys produced by this KDF symmetric ratchets, and keys are frequently refreshed
by  the DH Ratchet and executed when a participant wants to send a message after
one has been received. This resulting double ratchet (called the "Double Ratchet
Algorithm" [\[1\]](#references)) provides forward secrecy across messages due
to the KDF symmetric ratchets, but also post-compromise secrecy since
compromised KDF keys will eventually be replaced by new seeds. To achieve
out-of-order resilience, the double ratchet makes use of a second derivation
function within its KDF symmetric ratchets. While the KDF symmetric ratchets are
advanced normally, the KDF keys are passed through a second derivation function
before being used for encryption.

The double ratchet, nevertheless, does not provide asynchronicity by itself,
but it can be combined with a prekey scheme to achieve it. Prekeys are one-time
ephemeral public DH contributions that have been uploaded in advance to an
untrusted server.

In the OTRv4 protocol, we consider using the Double Ratchet Algorithm to improve
forward secrecy, while maintaining the same security properties of prior OTR
versions, like the deniability properties. Deniability properties are still
achieved by the usage of the DAKEs, and because messages are authenticated with
shared MAC keys rather than with signatures generated by long-term keys. OTRv4,
also, publishes the MAC keys and uses malleable encryption, to expand the set
of possible message forgers. OTRv4, therefore, will improve forward secrecy,
provide post-compromise secrecy, support out-of-order resilence and
asynchronicity (through the usage of prekey ensembles uploaded to a server).

Because of the usage of the Double Ratchet Algorithm, a correct way for
initializing it after a DAKE must be taken into consideration. To preserve the
security proofs of both DAKEs used in OTRv4 [\[4\]](#references), initial
ephemeral keys (that are not used for the Ring Signature or the derivation
of the first Mixed Shared Secret) must be used. These keys can be simply
attached to the first two interactive DAKE messages (the Identity message and
the Auth-R message) and to the second non-interactive DAKE message (the
Non-Interactive-Auth message). This design composes properly with the security
proofs, as it can be modeled as if the ratcheting ephemeral public keys are
exchanged in two flows before any DAKE even begins. Furthermore, these
ratcheting ephemeral public keys should be included in the "Phi" value.

As OTRv4 reveals the MAC keys, it is worth to note that OTR version 2 contains
a vulnerability related to message authentication when the revelation of MAC
keys is done immediately by both participants in a
conversation [\[2\]](#references). Two potential solutions to this problem are
possible:

1. Only the receiver will reveal the MAC keys, which gives weaker deniability as
   it puts full trust on receiver.
2. Both the sender and receiver can reveal MAC keys, but the sender must reveal
   only after two ratchet generations.

OTRv3 made the decision to only allow the receiver to reveal the MAC keys. In
OTRv4 the same decision is chosen.

To reveal MAC keys in the Double Ratchet for OTRv4:

1. The receiver of data messages will reveal the MAC keys on the first message
   sent per ratchet.
2. The participant expiring the session can reveal the MAC keys on the sent TLV
   type 1.

### Decision

For OTRv4, we decided to use the Double Ratchet Algorithm for key management.
This allows OTRv4 to support out-of-order resilience and to improve forward
secrecy (in the form of per-message forward secrecy).

As OTRv4 supports an out-of-order network model, message keys should be stored
for a reasonable amount of time so skipped (delayed or out-of-order) messages
can be decrypted. Implementers should, nevertheless, be careful with the
storage of message keys as attackers can try to cause Denial-of-Service attacks
(by, for example, forcing to store large amounts of message keys), or try to
capture and retroactively decrypt messages.

Sent data messages can always have a type 7 TLV attached. In the case of the
receiver, this participant is never sure of when a message corresponding to a
stored skipped message key will arrive with this TLV attached. For this reason,
every time a message key is stored, an extra symmetric key is also derived an
stored. Upon receipt of the message corresponding to the stored message key, the
extra symmetric key can either be used or discarded.

We decided that only the receiver will reveal the MAC keys in the first message
sent of every DH ratchet (even the MAC keys from stored messages keys). When the
session is expired or when stored message keys are deleted, their corresponding
MAC keys are placed in the `old_mac_keys` list so they can be later revealed
in either the next sent data message or in the immediate TLV type 1 sent when
a session is expired.

### Consequences

These decisions change how data is exchanged in comparison with previous OTR
versions.

The usage of the Double Ratchet algorithm improves forward secrecy, but key
management and ratcheting processes become somewhat complex. As a consequence of
allowing an out-of-order network model, message keys should be stored, which
changes how fragmentation of data messages work in comparison to previous OTR
versions.

### References

1. Marlinspike, M. (2013). *Advanced cryptographic ratcheting*, Signal blog.
   Available at: https://signal.org/blog/advanced-ratcheting/
2. Bonneau, J., Morrison, A. (2006) *Finite-State Security Analysis of OTR
   Version 2*. Available at:
   http://www.jbonneau.com/doc/BM06-OTR_v2_analysis.pdf
3. Unger, N., Dechand, S., Bonneau, J., Fahl, S., Perl, H., Goldberg, I., Smith,
   M. (2015). *SoK: Secure Messaging*, CACR, Available at:
   http://cacr.uwaterloo.ca/techreports/2015/cacr2015-02.pdf
4. Goldberg, I. and Unger, N. (2016). *Improved Strongly Deniable Authenticated
   Key Exchanges for Secure Messaging*, Waterloo, Canada: University of
   Waterloo. Available at:
   http://cacr.uwaterloo.ca/techreports/2016/cacr2016-06.pdf