adr screen architecture superceded current screen architecture bunch problem recreate application state state depends hidden behaviour rxbinding initial value observables emit current event immediately widget screen save restore state properly entire event stream replayed system setup way begin emission event like screencreated entire event handling loop setup controller handle business logic view logic come together make hard test maintain screen addition screen perform lot business logic memory require lot working around fact architecture depends state saved either persistence platform mechanism goal separate presentation business logic tested independently make state explicit saverestore manually instead depending hidden behaviour make easy migrate architecture existing screen implementation split controller two discrete piece responsibility uistateproducer responsible performing function controller related business logic uichangeproducer responsible performing function controller related presentation logic addition introduce helper class viewcontrollerbinding tie state producer consumer together event stream reference implementation reference implementation complete architecture found commit terminology event generated event typically event generated user interface might also include event generated platform like sensor camera etc generally represent kotlin data class implement uievent interface uistate kotlin data class represents everything needed render content given screen interface represents functionality actual screen provide controller uichange kotlin lambda signature unit screen setup process define uistate whatever viewscreen built create uistateproducer observabletransformerevent uistate class responsible business logic transforming stream event stream state create uichangeproducer observabletransformeruistate uichange responsible presentation logic transforming stream state stream lambda executed create controller observabletransformeruievent uichange compose uistateproducer uichangeproducer internally viewcontrollerbinding tie event stream view sample kotlin inject lateinit var uistateproducer shortcodesearchresultstateproducer inject lateinit var uichangeproducer shortcodesearchresultuichangeproducer lateinit var binding viewcontrollerbinding override fun onfinishinflate inject screen binding viewcontrollerbindingbindtoviewthis uistateproducer uichangeproducer newpatientbuttonsetonclicklistener bindingoneventsearchpatient goal review separation concern testability since business logic presentation logic separated two discrete component testing simpler since tested independently addition test behaviour business logic value testing asserting generated state readable verifying behaviour mock state savingrestoration since state screen represented data class saving restoring state easy two step make uistate class implement parcelable interface viewcontrollerbinding expose two function lateststate restoresavedstate conjunction platform lifecycle method migrating older architecture one major concern moving architecture breaking existing feature moving code around since architecture expose overall interface observabletransformerevent uichange replace controller test older screen composition state producer state consumer verify behaviour changed migrating consequence legacy controller event cached replayed soon screen inflated without waiting attached view hierarchy architecture event forwarded binding screen attached view hierarchy lost ignored correct way implement event older screen controller dependent behaviour might take effort migrate current architecture