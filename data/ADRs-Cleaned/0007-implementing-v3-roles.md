implementing role resource cloud controller control permission api resource maintaining role user example user space auditor role given space granted access read property space resource within space fewer privilege space developer space role modeled association user space user organization orglevel role client could view modify role endpoint like following put vorganizationsorgguidauditorsuserguid make user org auditor get vspacesspaceguiddevelopers list user space developer space delete vspacesspaceguidmanagersuserguid remove user space manager role put vusersuserguidmanagedspacesspaceguid make user space manager note possible access association either direction either going user get list managed space going space get list user space manager led large number endpoint achieved similar thing separate endpoint role type separate endpoint orgs space user aimed redesign model cut number endpoint simplify usage pattern led promote concept role toplevel resource role could managed smaller set endpoint post vroles get vroles basic idea role type spaceauditor relationship user either space space role org org role json guid examplespaceauditorroleguid createdat timestamp updatedat timestamp type spaceauditor relationship user data guid guidofuserwithrole space data guid guidofauditedspace since underlying database since wanted old endpoint still usable alongside new endpoint think carefully implement new resource top existing data posed several challenge challenge way role modeled database reflected endpoint structured meant simple join table representing single role type association user spaceorg example spacesauditors table two column userid spaceid since role firstclass resource guid createdat updatedat field fit pattern guid especially important since enables endpoint like get vrolesroleguid delete vrolesroleguid raised question add three field database since new knew would schema migration add ccdb migration complicated fact user environment may several api instance talking database rolling platform upgrade migration run first api instance update rest api instance still old code talking new migrated database mean migration must always backwardscompatible cannot control exactly migration run user environment potential approach considered several different approach tradeoff create new role table database would mean migrating data rolespecific join table single table table would column including guid type userid spaceid organizationid etc appealing data would closely match model role accessing listing role would straightforward would work like resource however meant potentially huge longrunning migration fill new table leading api downtime migration completes plus clear solution rolling upgrade old api instance would continue talking old table happens data addedremoved table migration occurring migration finish could ever drop old table would maintain data two different place indefinitely even worked would refactor rolerelated endpoint fetch new table risk seemed high moved create role view union existing table would mean introducing new sql view backed large union query idea make pseudotable combined existing table one make easier work quickly realized would work readonly view insert view supported small subset simple view would qualify still continued explore figuring could insert deletes underlying table view convenience fetchinglisting role got far pushing migration quickly revert work mysql ran error like mysqlerror view select contains subquery clause seems like later version mysql may support attempt compatible old version mysql well abandoned approach change role usage pattern hit one table time would mean changing proposed role endpoint instead get vrolesguid would request like get vrolesuserguidsuserguidspaceguidsspaceguidtypesspaceauditor idea work around fact role unique guid field instead would uniquely identified combination typeuserguidspaceguid space role might let get away changing underlying schema could structure endpoint usually talk one underlying table time listing would figure something else decided introduced strange nonstandard pattern like idea negatively impacting introducing longlasting complexity could figure resolve shortterm complexity upgrademigration end settled solution enabled originallyproposed role endpoint involve migrating data different table basic gist write migration add guidcreatedatupdatedat column underlying table generate value populate column introduce role sequel model backed union query dataset instead table let thing like rolewhereguid someguid roletype even though single underlying table write justintime migration fill guids role dont handle edge case role added underlying table api instance migration occurring creation role would given guids needed make sure assigned one lesson learned implementing first attempt write migration two migration one add new column table one fill column table occasionally led deadlock migration later split migration separate migration table also first attempt added column table called guid following usual pattern table unfortunately made existing query fail error like pgambiguouscolumn error column reference guid ambiguous line select guid user inner join spacesdevelopers join query could tell guid referring since user one spacesdevelopers noticed unit test locally tried fix modifying query however serious problem meant migration backwardscompatible since old code running nonupgraded api instance would still briefly ambiguous query migration finished caught pipeline job test specifically backwards compatibility reverted change reattempted time calling new column roleguid table resolved problem left strange inconsistency column named ever wondering column called roleguid instead guid consequence benefit achieved simpler usage pattern vroles endpoint designed provide move existing data around migration needed relatively small schema migration add new column data migration fill column benefit faster customer upgrading risky still one source truth role data underlying table already existed code mostly work asis approach since underlying data risk longterm may confusing table representing single concept role may especially true code ever deprecated removed since point would keep data separate however dont clear timeline recent kubernetes work raised question implementation role dont know enough today solve future problem since total migration added achieve may add time user upgrade bump version role however onetime cost since work done octoberdecember several month writing believe many operator already upgraded