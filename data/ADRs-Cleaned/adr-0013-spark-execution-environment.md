spark execution environment part raster foundry processing workflow requires source imagery ingest geotrellis catalog geotrellis depends apache spark parallelize work ingest work typically occurs apache spark enabled compute cluster prior iteration raster foundry attempted ingests apache yarn managed compute cluster via amazon elastic mapreduce emr perrequest basis unfortunately didnt perform well due overhead bootstrapping emr cluster goal iteration aim keep spark cluster component active time combination spot pricing usage based cluster autoscaling approach help minimize cluster bootstrapping duration keep costincurring cluster resource minimum given still early raster foundry product development desire keep cost low ship quickly carry significant weight order meet objective still minimize cluster bootstrapping overhead first pas spark enabled resource standby consist shared across staging production amazon emr cluster overall raster foundry infrastructure split across three amazon virtual private cloud vpcs staging spark production staging production vpcs peered spark vpc allow direct private network access necessary regardless public facing apis amazon emrs step api raster foundry api pas information system despite thought long hard consequence suspect section cover issue lie ahead hope least core idea remain future iteration spark execution environment shared cluster resource environment isolated environment vpc level build top amazon emr platform spot pricing autoscaling aggressively keep cost low consequence current vpcs configured cidr order modify cidr range almost resource housed within vpc destroyed recreated emr master instance group requires ondemand instance instance must instance family reserved instance considered keep cost low terraform yet complete support amazon emr basic support added october order take advantage costcutting feature like spot bidding spot fleet support hinted reinvent autoscaling core task instance group well lean cloudformation direct access aws emr api recommended autoscaling core task instance done clusterlevel yarn metric published cloudwatch well sort sweet spot automatically scaling given workload year clear best emr job submission method step api desirable integrates well existing airflow operator avoids number security group service discovery issue direct sparksubmit invocation node brittle require amount undesirable maneuvering configuration file copying security group access get working also lack builtin job tracking mechanism provided step api