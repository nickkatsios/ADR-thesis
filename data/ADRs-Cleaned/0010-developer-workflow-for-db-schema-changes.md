developer workflow schema change proposed adopting continuous delivery pipeline zerodowntime deployment brings challenge particularly regarding evolution underlying database schema chapter managing data continuous delivery david farley jez humble lifecycle application data differs part system application data preservedindeed data usually outlasts application create access crucially data preserved migrated new deployment rollback system case deploy new code erase previous version wholly replace new copy way certain starting position possible data limited case realworld system approach impossible system released production data associated grow significant value right indeed arguably valuable part system present problem modify either structure content underlying problem cant swap new version database old version like would bluegreen deployment code data question constantly motion zerodowntime deployment first define zerodowntime actually mean apply frontend service publicfacing frontend service perform zerodowntime deployment frontend application two possible decouple frontend backend frontend still provides useful service one backends decouple database schema change backend deployment perform change multiple backwardcompatible step frontend tolerate downtime backend service frontend offer reduced functionality backends still provide useful service user backend private accessible frontend service possible perform zerodowntime deploys taking backend service short time perform upgrade enables traditional database migration deployment note however backend doesnt support zerodowntime deployment must clearly documented new consuming service know appropriately decoupled frontend doesnt function without backend backend also publicfacing service api backend must also support zerodowntime deployment backend backed definedschema datastore rdbms extra step added release pipeline order facilitate traditional database migration deployment add new feature app including schema migration done instep single repo containing code update script update contained single unit work app work migration schema deploy stop application apply schema migration script usually managed tool flyway liquibase start new version application zerodowntime database deployment perform zerodowntime database deployment schema migration must separated code deployment database migration done right explains give example step required adding nonnullable column existing table essentially database migration must done way done independently application deployment underlying principle obey every change make must backward compatible rest system add nonnullable column scenario backward compatible step perform change add nullable column database system keep adding row null fine read ignore null code change write correct value new row handle reading unexpected null database doesnt change null row row data run data migration fill column might script bit code application either way app doesnt care row handle data null fine add nonnull constraint database null new code writing correct data remove code handle null case wont happen anymore