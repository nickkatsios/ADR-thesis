adr unordered transaction changelog dec initial draft yihuang tacturtle alexanderbez jan include section deterministic transaction encoding abstract propose way replayattack protection without enforcing order transaction without requiring nonce way support unordered transaction inclusion today nonce value account sequence number prevents replayattack ensures transaction sender included block executed sequential order however make tricky send many transaction sender concurrently reliable way ibc relayer crypto exchange typical example case propose add boolean field unordered transaction body mark unordered transaction unordered transaction bypass nonce rule follow rule described instead contrary default ordered transaction impacted proposal theyll follow nonce rule unordered transaction included block transaction hash recorded dictionary new transaction checked dictionary duplicate prevent dictionary grow indefinitely transaction must specify timeoutheight expiration safe removed dictionary expired dictionary simply implemented inmemory golang map preliminary analysis show memory consumption wont big example support block block contains unordered transaction safety limit range timeoutheight prevent long expiration limit size dictionary transaction format protobuf message txbody bool unordered replay protection order provide replay protection user ensure transaction ttl value relatively shortlived long enough provide enough time included block facilitate storing transaction hash durable map unorderedtxmanager prevent duplicate replay attack upon transaction ingres checktx check transaction hash exists map ttl value stale current block reject upon inclusion block delivertx transaction hash set map along ttl value map evaluated end block abci commit stale transaction transactions ttl value who beyond committed block purged map important point note theory may possible submit unordered transaction twice multiple time transaction included block however well note important layer protection mitigation assuming cometbft underlying consensus engine nonnoop mempool cometbft reject duplicate application leverage abci processproposal evaluate reject malicious proposal duplicate transaction application leverage application mempool mempool reject duplicate finally worst case duplicate transaction somehow selected block proposal attempt evaluate fail delivertx worst case end filling block space duplicate transaction golang type txhash byte const purgeloopsleepms unorderedtxmanager contains hash dictionary duplicate checking expire block production progress type unorderedtxmanager struct blockch defines channel receive newly committed block height blockch chan uint syncrwmutex txhashes defines map hash ttl value duplicate checking replay protection well purging map ttl expired txhashes maptxhashuint func newunorderedtxmanager unorderedtxmanager unorderedtxmanager blockch makechan uint txhashes makemaptxhashuint return func unorderedtxmanager start mpurgeloop func unorderedtxmanager close error closemblockch mblockch nil return nil func unorderedtxmanager containshash txhash bool mmurlock defer mmurunlock mtxhasheshash return func unorderedtxmanager size int mmurlock defer mmurunlock return lenmtxhashes func unorderedtxmanager addhash txhash expire uint mmulock defer mmuunlock mtxhasheshash expire onnewblock send latest block number background purge loop called abci commit event func unorderedtxmanager onnewblockblockheight uint mblockch blockheight expiredtxs return expired hash based provided block height func unorderedtxmanager expiredtxsblockheight uint txhash mmurlock defer mmurunlock var result txhash txhash expire range mtxhashes blockheight expire result appendresult txhash return result func unorderedtxmanager purgetxhashes txhash mmulock defer mmuunlock txhash range txhashes deletemtxhashes txhash purgeloop remove expired hash background func unorderedtxmanager purgeloop error block channelbatchrecvmblockch lenblocks channel closed break latest blockslenblocks hash mexpiredlatest lenhashes mpurgehashes avoid burning cpu catching phase timesleeppurgeloopsleepms timemillisecond channelbatchrecv try exhaust channel buffer empty block empty func channelbatchrecvt item block channel empty item nil channel closed return nil remaining lench result maket remaining result appendresult item remaining result appendresult return result antehandler decorator order facilitate bypassing nonce verification modify existing incrementsequencedecorator antehandler decorator skip nonce verification transaction marked unordered golang func isd incrementsequencedecorator antehandlectx sdkcontext sdktx simulate bool next sdkantehandler sdkcontext error txunordered return nextctx simulate addition introduce new decorator perform unordered transaction verification map lookup golang const defaultmaxunorderedttl defines default maximum ttl unordered transaction set defaultmaxunorderedttl type deduptxdecorator struct unorderedtxmanager maxunorderedttl uint func deduptxdecorator antehandlectx sdkcontext sdktx simulate bool next sdkantehandler sdkcontext error apply unordered transaction txunordered return nextctx simulate txtimeoutheight return nil errorsmodwrapsdkerrorserrlogic unordered must set timeoutheight txtimeoutheight ctxblockheight dmaxunorderedttl return nil errorsmodwrapfsdkerrorserrlogic unordered ttl exceeds dmaxunorderedttl check duplicate dmcontainstxhash return nil errorsmodwrapsdkerrorserrlogic duplicated ctxischecktx new included block add hash unordered manager dmaddtxhash txtimeoutheight return nextctx simulate transaction hash absolutely vital transaction hash deterministic transaction encoding malleable given transaction otherwise valid encoded produce different hash reflect valid transaction duplicate unordered transaction submitted included block order prevent transaction encoded deterministic manner adr provides mechanism however important note way transaction signed ensure adr followed want avoid amino signing state management start node ensure txmanagers state contains unexpired transaction committed chain critical since state properly initialized node reject duplicate transaction thus provide replay protection likely get app hash mismatch error propose write unexpired unordered transaction txmanagers file disk start node read file repopulate txmanagers map write file happen node gracefully shuts close note perfect solution store store omit explicit file handling altogether simply write transaction nonconsensus state state storage alternatively write transaction consensus state consequence positive support unordered concurrent transaction inclusion negative requires additional storage overhead management processed unordered transaction exist outside consensus state reference httpsgithubcomcosmoscosmossdkissues