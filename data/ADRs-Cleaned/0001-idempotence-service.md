idempotence service approved computing idempotent operation one additional effect called input parameter vast majority critical flow web service running required provide guarantee client thus make sense extract functionality library support common usecases two common approach industry come implementing support idempotency distributed inmemory data store redis database master node avoid issue caused possible replication lag client typically additional requirement client enable idempotency add unique identifier request expected side effect sometimes apis make mandatory property request security consideration lower chance collision recommended uuidv unique request identifier service critical requirement processing service persisted result successful failed nonretriable error request nonblocking concurrent request identifier rejected transient error result persistence aim avoid heavy computation retry duplicate request original request completed success nonretriable error client freedom choice exactly persisted format quick failure case aggressive retry policy client side ensures server resource blocked wasted concurrent request identifier request processing procedure persistence result transactional require request execution logic idempotence update happen transaction requirement come cost client flexibility allowing client control transactional introduces edgecases failure persist idempotency whereas action completed side effect taken place provide code idempotence service based database approach specific database integration pluggable inmemory database approach pro con going depth comparision mostly due lack adoption redis current infrastructure said definitely consider providing support future require request execution logic idempotence update happen transaction requirement come cost client flexibility allowing client full control transaction introduces edgecases failure update imdepotency action side effect already took place would require client verify side effect taken place execution consider suboptimal common case approach prof limiting certain flow extend core service interface allow client choose different execution strategy better control transactional consequence guarantee strong data consistency fast lookup near nonblocking execution