adr sampling erasure coded block chunk changelog created tendermints block gossiping peer gossip random part block data peer celestia node lightclients validators able sample rowcolumnchunks erasure coded block aka extended data square network necessary data availability proof highlevel implementationindependent formalization mentioned sampling data availability proof found fraud data availability proof detecting invalid block light client time besides academic paper formalization specification protocol exists currently celestia specification describes erasure coding construct extended data square block data adr describes highlevel requirement defines api different component celestia block gossiping block sync proof document implement core data structure erasure coding block already implemented celestiacore adrs change refer celestia specification case aspect existing implementation specification already par part exact arrangement data described rationale document specification happen appside abci boundary latter implemented celestiaorgcelestiaapp leveraging new abci method added new method subset proposed abci change aka abci mustafa albassam musalbas implemented prototype whose main purpose realistically analyse protocol although prototype make network request operates locally partly serve reference implementation rsmtd library implementation essentially ipfs apis reading writing chunk ipld dagservice precisely nodegetter nodeadder optimization also batch batch adding removing node achieved passing around coreapi object derive ipfs node created along tendermint node see code snippet exactly see goipfs documentation example construct ipfs node instance node corenewnodectx nodeoptions attache core api constructed node coreapi coreapinewcoreapinode mentioned ipld method operate called ipldnodes computing data root pas nodevisitor namespaced merkle tree library create inner leafnode tree becomes ipld node peer request ipld node celestia ipld plugin provides function nmtnodeparser transform retrieved raw data back ipldnode highlevel description change required rip current block gossiping routine including change block storage rpclayer potential change reactor either handled adr andor smaller separate followup adrs approach instead creating full ipfs node object passing around explained api http ipldlight client also better performance graphsync ipld selector via ipldprime also idea node receive header data root additional steprequest download header library feature considered assume node library header assumption likely change flesh part system detail note also mean light client would still validate data root merkelizing header yield result section record made best record much info possible discussion happened aid back pull request get needed information todo briefly summarize github discord slack discussion also mention mustafas prototype compare apis briefly requestsamples respondsamples processsamplesresponse mention ipld experiment detailed design add package library provides following feature sample given number random rowcol index extended data square given header indicate successful timeoutother error occurred store block network adding peer local merkledag whose content discoverable via dht store sampled chunk network reconstruct whole block given header get message particular namespace mention mostly completeness detail described implemented separate adr apart mentioned feature informally collect additional requirement randomness needed randomness source configurable reply network verified sufficiently covered library already ipfs possible request network happen parallel without dosing proposer instance library implemented two new package first subpackage added layzledgercore package know anything core data structure block header etc handle actual network request ipfs network operates ipfsipld object directly hence live ppipld extent part stack already exists second highlevel api live closer actual type subpackage celestiacoretypes new subpackage first describe highlevel library describe function detail inline godoc comment api operates celestiacore type mentioned part library knowledge core type hence depends deal ipfs internals validateavailability implement protocol described httpsfcifcaaipaperspdf specifically step protocol described section random sampling network block recovery carried detail first create numsamples random unique coordinate ask network leaf data corresponding coordinate additionally number request caller pas callback called retrieved leaf verified merkle proof among usecases callback useful monitoring progress process leaf data moment validated provide timeout todo constant lower bound sample func validateavailability ctx contexcontext dah dataavailabilityheader numsamples int onleafvalidity funcnamespaceprefixeddata error retrieveblockdata recover block data carry similar protocol described validateavailability key difference sample enough chunk recover full extended data square including original data rsmtdrepairextendeddatasquare func retrieveblockdata ctx contexcontext dah dataavailabilityheader api coreifacecoreapi codec rsmtdcodec typesdata error putblock operates directly block first computes erasure coding aka extended data square row row call lower level library handle adding row merkle dag case namespaced merkle tree note method could also fill header data pinned default func block putblockctx contexcontext nodeadder ipldnodeadder error describe lowerlevel library method provide detail inline godoc comment directly putblock method block erasure coding cached private field block change lower level api closer ipfs ppipld getleafdata take namespaced merkle tree root transformed cid leaf index retrieve caller also pas total number leaf tree internally translated ipld path corresponds ipfs dag get request namespacedcid retrieved data pinned default func getleafdata ctx contextcontext rootcid cidcid leafindex uint totalleafs uint corresponds extended square width api coreifacecoreapi byte error getleafdata validateavailability retrieveblock putleaves putblock note ipfsipld ipfs data content addressed basically mean data identified hash particularly celestia case root cid identifies namespaced merkle tree including content inner leaf node mean getleafdata request succeeds retrieved leaf data fact leaf data tree additionally verify merkle proof per leaf essentially done via ipfs layer resolving getting leaf data todo validate assumption link code show done internally implementation plan fully integrating data available proof tendermint rather larger change break work following package mentioning implementation work already done flesh change consensus message celestiaspecs celestiaspecs flesh change would necessary replace current block gossiping adr add possibility storing retrieving block data sample whole block celestiacore adr related integrate api addition celestiacore without directly replacing tendermint counterpart block gossip etc rip component redundant integration one even several smaller block gossiping see adr modify block store see adr make downloading full block optional flagconfig route rpc request ipfs see adr proposed consequence positive simplicity ease implementation reuse existing networking stack goipfs potential support large cool helpful community highlevel api definition independent stack negative latency connected public ipfs network might overkill peer fact care subset participates celestia protocol dependency large codebase lot feature small subset neutral two different layer exist celestiacore reference httpsgithubcomcelestiaorgcelestiacoreissues httpsgithubcomcelestiaorgcelestiacoreissues httpsdocsipldionodes httpsarxivorgabs httpsfcifcaaipaperspdf httpsgithubcomtendermintspecpull