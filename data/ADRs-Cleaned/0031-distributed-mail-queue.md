distributed mail queue lazy consensus implemented mailqueue central component smtp infrastructure allowing asynchronous mail processing enables short smtp reply time despite potentially longer mail processing time also work buffer smtp peak workload overload server furthermore mail exchange server ability add delay observed dequeing element allows among others delaying retries upon delivery failure remote site throttling could helpful considered spammer mailqueue also enables advanced administration operation like traffic review discarding email resetting wait delay purging queue etc spring implementation non distributed implementation rely embedded activemq implement mailqueue email stored local file system administrator wishing administrate mailqueue thus interact james server friendly distributed setup distributed james relies following third party software among rabbitmq messaging good holding queue however advanced administrative operation cant implemented component alone case browse getsize arbitrary mail removal cassandra metadata database due tombstone delete queue well known antipattern objectstorage swift hold byte content distributed james ship distributed mailqueue composing following software following responsibility rabbitmq messaging rabbitmq consumer trigger dequeue operation time series projection queue content order time list mail metadata maintained cassandra see later time series avoid aforementioned tombstone antipattern polling performed projection objectstorage swift hold large byte content avoids overwhelming software scale well term inputoutput operation per second detail table composing cassandra mailqueue view datamodel enqueuedmailsv hold time series primary key hold queue name rounded time enqueue designed slice bucketcount slicing enables listing large amount item given point time fashion achievable classic partition approach bucketcount enables sharding avoids writes given point time cassandra partition clustering key composed enqueueid unique identifier content hold metadata email table enables starting load email ever mailqueue content never deleted deletedmailsv tell wether mail stored enqueuedmailsv deleted queuename enqueueid primary key table updated upon dequeue deletes table queried upon dequeue filter deletedpurged item browsestart store latest known point time previous email deleteddequeued enables skip deleted item upon browsingdeleting queue content update probability based asynchronously piggy backed dequeue main mail operation sequence upon enqueue mail content stored object storage entry added enqueuedmailsv message fired rabbitmq dequeue triggered rabbitmq message received deletedmailsv queried know message already deleted mail content retrieved object storage entry added deletedmailsv notice email dequeued dequeue random probability trigger browse start update current browse start enqueuedmailsv content iterated checked deletedmailsv first non deleted dequeued email found point becomes new browse start browsestart never point start current slice grace period upon browse start update left tolerate clock skew update browse start done randomly simple way avoid synchronisation distributed system ensure liveness uneeded browsestart update triggered would simply waste resource upon browse enqueuedmailsv content iterated checked deletedmailsv starting current browse start upon deletepurge enqueuedmailsv content iterated checked deletedmailsv mail matching condition marked deleted enqueuedmailsv upon getsize perform browse count returned element distributed mail queue requires fine tuned configuration mostly depends count cassandra server mailqueue throughput slicewindow time period slice element enqueuedmailsv sharing slice retrieved bigger element going read frequent browse start update lower value might result many almost empty slice read generating higher read load recommend slicewindow chosen user maximum throughput approximately email contained slice value dividing current slicewindow allowed new value otherwize previous slice might found bucketcount enables spreading writes cassandra cluster bucketting strategy low value lead workload spread evenly higher value might result uneeded read upon browse count cassandra server good starting value increasing count bucket supported configuration update decreasing bucket count might result bucket lost updatebrowsestartpace governs probability updating browsestart upon dequeuedeletes recommend choosing value guarantying reasonable probability updating browse start every slice big value lead uneeded update yet finished slice low value end expensive browsestart update browse iterating slice content deleted value changed freely rely eventsourcing validate mailqueue configuration change upon james start following aforementioned rule limitation delay supported mail queue implementation thus suited mail exchange implementation following proposal could solution support delay enqueuedmailsv deletedmailsv never cleaned corresponding blob always referenced ideal privacy space storage cost point view getsize operation suboptimal thus efficient combined metric reporting mail queue size periodically performed james server lead upon increasing throughput cassandra overload configuration parameter allows disable mail queue size reporting temporary solution alternative presented like eventually consistent per slice counter approach proposed solution rely rabbitmq management api retrieve mail queue size however design cannot take account purgedelete operation read corresponding jira consequence distributed mail queue allows better spreading mail processing workload enables centralized mailqueue management james server yet additional work required mail exchange scenario reference jira