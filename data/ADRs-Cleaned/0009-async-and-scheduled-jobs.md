async scheduled job service process application automatically periodically order enforce timedependent business rule modify application state therefore way run domain logic code outside web request reliably proactivescheduled way finding considered findstyle run job via infrastructure sidekiqsidekiqcron clockwork gem sort secure api endpoint hit interval trigger sweep considering ability enforce timedependent business rule core functionality service decided follow best practice implement scheduling background processing properly similar approach find clockwork instead sidekiqcron pro sidekiqclockwork combination proven stable scalable combination take way public launch beyond code scheduling organisation transparent schedule defined within source code app call standard rail worker service also give update path schedule background task reusing standard deployment pipeline well auditing information git version control background processing handled sidekiq failed job retried automatically con requires additional azure work support multiple containersservices webworkerclock redis instance add following capability app scheduling achieved via clockwork gem alllows periodic job defined ruby file within main rail app example ruby configclockrb class clock include clockwork everyminute sayhello railsloggerinfo end clockwork requires scheduling daemon run separate process rail server codebase modelsservicesworkers defined rail available triggered extra process started like bundle exec clockwork configclockrb note many rail server instance may run scaling outloadbalancing scenario must always one clockwork process otherwise task triggered multiple time furthermore production process supervised restarted needed technically possible perform kind processing within clock process avoided application error could terminate scheduler prevent task running good practice suggests clock process triggerenqueue task processed within background processing system thats configclockrb list time sidekiq worker performasync statement background processing sidekiq gem current standard rail background processing also run separate process bundle exec sidekiq sidekiqyml concurrency setting also introduces infrastructure requirement redis worker usually placed within appworkers call class within rail app service object achieve goal consequence additional work required azure order run multiple container separate service azure based docker image set environment variable different start command add redis instanceservice stack ideally managedhosted service azure ecosystem logging adapted distinguish log different service service supervised platform restarted case error