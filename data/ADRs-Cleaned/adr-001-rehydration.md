architecture record rehydration able persist execute user intention across page load expressed number issue main agitator maintaining intent whenever user try anything requires authenticated situation get redirected page successful login get redirected back origin page without intended action fulfilled one example addtochecklist functionality whenever user want add material checklist click tilfj til huskelist button next material presentation get redirected adgangsplatformen successful login get redirected back material page material added checklist intent stated want intention executed even though page reload come way move implementing define explicit intention actual action tried executing user click button intent state generated committed implementation check intended action meet requirement case logged necessary payload intention meet requirement fire addtochecklist action material added user checklist difference two might seem superfluous important distinction make current implementation able serialize persist action application state across page load defining intent explicitly able serialize persist page load resolve implementation able rehydrate persisted state look persisted intention individual application implementation decide intention mock implementation case case business logic look follows jsx const initialstore authenticated false intent payload const fulfillaction storeauthenticated storeintentstatus pending storeintentstatus tried const getrequirements storeauthenticated storeintentstatus pending const abandonintention storeauthenticated storeintentstatus tried function addtochecklist materialid store useeffect fulfillaction fire actual functionality required add material checklist remove intention result fulfilled addtochecklistactionstore materialid else getrequirements redirect set tried redirecttologinstore else abandonintention abandon intent wont infinite loop retries every page load abandonaddtochecklistintentionstore materialid storeintentstatus return utilize session storage persist state client due short lived nature porous feature choose redux framework implemenent redux blessed choice instance widespread approachable design welldocumented best way current redux implementation reduxjstoolkit redux sufficiently advanced framework support application state even colocating shared state application persistence concern want commonly tool reduxpersist implementation detail take consideration integrating two alternative considered persistence url could persist intention url delivered back client page reload would still imply architectural described regard intent state different flag etc would needed since state virtually shared across page load url however simpler solution cannot handle complex situation described url feasibly usecontext react offer usecontext state management alternative redux prefer redux provides complete environment working state management already community established practice library integrate redux one example persist action redux handle reduxpersist usecontext would roll implementation disadvantage redux amount required boilerplate code addressed reduxjstoolkit consequence able support rehydration case therefore pick user flow left heavy degree complexity added task requires intention instead simple action saving immediate state session storage make yet another place clear cache