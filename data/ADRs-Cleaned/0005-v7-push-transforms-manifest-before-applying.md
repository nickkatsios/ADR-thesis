push transforms manifest applying issue motivating influence constrains note adr build idea introduced last push refactor havent read adr please reading one acceleration team working cli version push found implementation made certain feature difficult impossible implement refactored first part push described solve problem dream serverside manifest december capi cli acceleration team began discussing idea serverside manifest capi would build endpoint received manifest made necessary change api side previously push manifest file concept invented implemented fully cli result work app manifest space manifest endpoint one part dream serverside manifest cli would longer knowledge manifest content push command would pas manifest content directly api without ever parsing yaml api would apply manifest given cli would upload source code staging goal allow capi add additional manifest feature property without requiring implementation change cli side see topic including original goal serverside manifest serverside multiapp manifest server side manifest exploration adding support diffing point time push print diff output like feature push got lot positive feedback last piece push implement parity diff output meant show difference current state pushed apps desired state represented manifest flag override like diff push pushing manifest org org space space admin manifest file homepivotalworkspacecfacceptancetestsassetsdoramanifestyml getting app info updating app attribute name dora path homepivotalgosrcgithubcomcloudfoundrycfacceptancetestsassetsdora command bundle exec rackup configru port disk quota health check type port instance instance memory stack cflinuxfs route dorasheersharkliteclifun set explore adding diff output found straightforward way already parsing whole manifest actualizing property individually intentionally didnt parse whole manifest knowledge full desired state without knowledge could comparison necessary output diff unfixable bug due override handled late whole class bug could fixed push refactor case manifest property value invalid corresponding flag override acceptable example might memoryinmb manifest quota push fine prior change manifest property flag override handled separate api call manifest property applied first exactly manifest file applymanifest request successful flag override would handled sending request scale memory number specified flag manifest invalid memory setting would put app quota applymanifest step would fail even getting override step believe confusing unexpected behavior user user pass would expect number mattered memory value theyre overriding manifest example bug cli user get failed push flag override quota limit manifest value change proposing agreed implement refactored first half push step come uploading source code creating new droplet read detail push work change change push preserved manifest property exactly asis sent applymanifest endpoint flag override would handled applying manifest complete push work change push par manifest inmemory representation manifest transforms representation manifest based given flag override generates new yaml send applymanifest endpoint effect eliminate extra step fixing app applymanifest step run example longer send additional request scale apps process flag given instead manifest send api modified say instance see detailed explanation work addition api fully responsible handling logic validating resolving conflict manifest property case study lifecycle flag override see implemented follow path flag override take user code api imagine user run push manifest look like yaml application name dora instance pushcommand par manifest aswritten given flag override pass handleflagoverrides return transformed manifest func cmd pushcommand executeargs string error transformedmanifest err cmdactorhandleflagoverridesbasemanifest flagoverrides err nil return err handleflagoverrides method another example hexagonal pattern established refactor pass manifest sequence function transformmanifestsequence func actor actor handleflagoverridesbasemanifest pushmanifestparsermanifest flagoverrides flagoverrides pushmanifestparsermanifest error newmanifest basemanifest transformplan range actortransformmanifestsequence sequence transform function var err error newmanifest err transformplannewmanifest flagoverrides err nil return pushmanifestparsermanifest err return newmanifest nil list function transform sequence actortransformmanifestsequence handleflagoverridefunc app name override must come first trim manifest multiple apps one handleappnameoverride handleinstancesoverride instance transform function handlestartcommandoverride handlehealthchecktypeoverride handlehealthcheckendpointoverride handlehealthchecktimeoutoverride handlememoryoverride handlediskoverride handlenorouteoverride handlerandomrouteoverride must come routing related transforms handledefaultrouteoverride handledockerimageoverride handledockerusernameoverride handlestackoverride handlebuildpacksoverride handlestrategyoverride handleapppathoverride handledropletpathoverride handleinstancesoverride method responsible transforming manifest based iinstances flag given func handleinstancesoverridemanifest pushmanifestparsermanifest override flagoverrides pushmanifestparsermanifest error overridesinstancesisset manifestcontainsmultipleapps return manifest translatableerrorcommandlineargswithmultipleappserror webprocess manifestgetfirstappwebprocess webprocess nil webprocessinstances overridesinstancesvalue else app manifestgetfirstapp appinstances overridesinstancesvalue return manifest nil manifest transformed generate following new yaml sent applymanifest endpoint yaml application name dora instance updated apis point view flag override override behavior resolved fully cli side manifest ever applied consequence becomes easier difficult risk introduced change mitigated cleaner separation concern cli api one key outcome achieved clearer separation concern cli api come manifest idea flag override always clionly concept case responsibility getting blurred example consider noroute available flag noroute manifest property noroute true refactor order apply manifest exactly written still allow overriding behavior cli required introduced noroute query parameter applymanifest endpoint noroute given resulting request would look like post vspacesguidapplymanifestnoroutetrue although worked example specific oneoff solution broader problem want add query parameter every overridable manifest property instance making api overlytailored cli case change noroute override handled fully cli side applying manifest since flag override cli business able remove noroute query parameter api endpoint clean related code api side serverside manifest closer dream goal serverside manifest push much possible work related validatingapplyingresolving configuration change api side refactor get much closer goal cli lean fully api apply manifest rather applying manifest correcting configuration additional api call however goal serverside manifest cli know little possible content manifest refactor deliberate departure goal order apply flag override cli must parse almost entire manifest risk serverside manifest wanted allow capi introduce new manifest property could leveraged user manifest without requiring code change cli biggest risk refactor capi could make change manifest specification would break user push experience cli release new version mitigation accept risk described reason designed cli new manifest parser preserve unrecognized yaml property inmemory representation yaml sent along api end mean capi free make additive change manifest specification user leverage without needing cli change capi make breaking change manifest specification impact cli however discussed capi team unlikely anytime soon since also force user refactor manifest require change client dependent manifest spec want make breaking change likely introduce idea versioned manifest continue support multiple manifest specification time fewer leftover push fails refactor failed push could result state change change would get rolled back push exited error setup suppose cli user started existing app space memory quota supplied manifest yaml application name dora instance memoryinmb pushed command push refactor push would apply manifest create instance allotted per instance case allotted memory would within quota manifest would applied successfully apply manifest succeeded separate api call would apply flag override allot per instance instead however case push would fail error indicating desired memory quota however instance created would stick around despite failed push refactor push transforms inmemory representation manifest following yaml application name dora instance memoryinmb push would apply manifest would fail validation error indicating desired memory quota therefore never even get step scaling app instance fewer api request per app nice sideeffect refactor number api call required push app decrease considerably previously apply manifest property make one call apply manifest call app pushing roughly number flag override make one call apply manifest pushed apps mean push faster resilient flaky network connection likely fail middle due poor connection requires code implement maintainability refactor build hexagonal architecture established push refactor make push consistent easier reason diff possibility simpler path towards implementing diff output feature representation full desired manifest flag override applied make request api current manifest compare two manifest better capture user intent flag override superceding manifest property believe user run push manifest look like yaml application name dora instance intention really push instance refactor would create one instance first scale refactor feel better capturing user intent outset without intermediate step incorrect manifest applied