adr enable eventdriven computing via shared dedicated event service proposed weve adopted microservices architecture order attain certain technical characteristic scalability performance evolvability translate competitive advantage chef timetomarket business agility small singlepurpose service developed deployed independently cornerstone architectural style order reap benefit service must collaborate without introducing counterproductive dependency eventdriven computing aka eventdriven architecture eda allows service communicate remaining loosely coupled eventdriven system event producer generate event response significant change state event consumer listen event react additional processing dedicated intermediate component receives event generated producer publishes asynchronously consumer registered interest producer unaware consumer react change state consumer listen event without knowing detail event produced dependency introduced producer consumer event service ingests publishes event service producer consumer case eventdriven model include situation multiple component must notified change system state scenario demand near realtime response change system state case distributed transaction must coordinated single logical unit work twophase commit feasible due scalability performance concern complex event processing scenario consumer analyzes series event reacts condition aggregate meet prescribed threshold ability recreate system state demand replaying action occurred system event sourcing benefit high scalability performance facilitates parallelized operation loose coupling service pointtopoint integration easy addremovemodify consumer near realtime response system event lay groundwork event sourcing become direction want take challenge asynchronous processing make system harder test reason guaranteed delivery requires additional infrastructure pubsub messaging event streaming etc processing event order exactly requires extra thought effort dealing failure scenario complex retries compensating event etc event current flow example currently compliance service fire event profile created deleted scan job created updated deleted profile component call service internal event component via grpc interface publish event event component receives event channel process one one processing event component look correct handler event feedserviceclient example new goroutine make grpc call handleevent feed component feed component creates new feed entry document elasticsearch feed entry visible gui event feed timeline event persisted retries compensating strategy event failure enable eventdriven capability exposing compliance service event component independent service new event service abstract mechanic event publishing rest system acting generic interface event publishing distribution mechanism evolve replaced time event proposed flow example initial version new service persist event perform retries iterate event service development case require new capability message durability guaranteed delivery exactlyonce inorder processing failure handling etc consider third party solution framework pubsub messaging event streaming underpin event service abstraction advanced feature become necessary consequence implemented ass resulting yyyymmdd tbd