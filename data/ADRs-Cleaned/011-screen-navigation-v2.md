adr screen navigation supersedes currently navigation framework built top flow order provide singleactivity navigation setup individual screen built androidviewview instance approach work well case bunch issue inbuilt support modal framework inbuilt support modal bottom sheet dialog etc currently workarounds see adr app grown increasingly reliant bottom sheet workaround tedious add lot friction building screen good example moving app different screen based result selected bottom sheet requires open bottom sheet start activity result flow reading result instead directly loading screen required inbuilt support lifecycle component currently library framework depend android lifecycle component officially supported activity fragment view current framework built workarounds available increasingly harder integrate library depend component longer wait opening screen expecting result come screen expected send result back previous screen current framework fall woefully short currently implemented ioreactivexsubjectspublishsubject sometimes lead issue result delivered correctly based subtle race condition conjunction bottom sheet described earlier layout editor preview broken current framework setup expect individual screen added xml layout file inflated system easy make building nontrivial uis hard editor framework cannot instantiate class screen depends normally initialized dependency injection framework requires deploy real device testing increase time feedback loop overall impact current navigation framework illsuited build complex navigation flow especially involve modal like bottom sheet application moment heavily reliant bottom sheet add additional complexity whenever work navigation flow incorporate since requires implement several workarounds order support correctly goal new navigation framework one better suited fulfill following requirement inbuilt support modal bottom sheet dialog ideally minimal difference modal normal screen support android lifecycle component support opening screen returning result without requiring workarounds support overriding back press screenmodal level support layout editor preview ide easy incrementally migrate current navigation architecture without requiring lot upfront work solution build new navigation framework based fragment inspired simplestack designed work screen architecture see adr high level description framework core component described framework framework overall three primary component screenkey abstract class inherited class represent individual screen similar current implementation parcelable save restore backstack activity state restoration mechanism triggered history class represents overall backstack encapsulate list screenkey instance expose helper method manipulate backstack also parcelable save restore necessary router class externally push pop screen backstack manage converting history fragment transaction applied order update usage instantiating router simple kotlin val router router firstscreenkey initial screen supportfragmentmanager ridcontent reference fragment container viewgroup pushing new screen onto stack performed push method kotlin nextscreenbuttonsetonclicklistener routerpushsecondscreenkey going previous screen done pop method kotlin previousscreenbuttonsetonclicklistener routerpop building screen implementing screen quite simple standard fragment kotlin class firstscreen fragmentrlayoutscreennavigationfirst override fun onviewcreatedview view savedinstancestate bundle superonviewcreatedview savedinstancestate set event parcelize object key screenkey override fun instantiatefragment fragment return firstscreen passing argument screen quite easy framework put instantiated screenkey instance fragment argument argument key screenkeyargskey easily retrieved within fragment standard argument call overriding back press framework provides interface handlesback screen wish override default back behaviour popping stack implement handle back press required work normal screen well modal kotlin class secondscreen fragmentrlayoutscreennavigationsecond handlesback private val router router unsafelazy requireactivity navigationtestactivityrouter override fun onviewcreatedview view savedinstancestate bundle superonviewcreatedview savedinstancestate nextscreenbuttonsetonclicklistener routerpushthirdscreenkey override fun onbackpressed boolean routerpushconfirmationdialogkey return true parcelize class key screenkey override fun instantiatefragment fragment return secondscreen opening screen result router provides two method pushexpectingresult popwithresult expectsresult interface order implement request response flow screen accepts result kotlin class thirdscreen fragmentrlayoutscreennavigationthird expectsresult private val router router unsafelazy requireactivity navigationtestactivityrouter override fun onviewcreatedview view savedinstancestate bundle superonviewcreatedview savedinstancestate confirmscreenbuttonsetonclicklistener routerpushexpectingresultentertext textentrysheetkey override fun onscreenresultrequesttype parcelable result screenresult requesttype entertext result succeeded val enteredtext textentrysheetreadenteredtextresult thirdscreenlabeltext thirdscreenlabeltexttostring enteredtext parcelize class key screenkey override fun instantiatefragment fragment return thirdscreen parcelize object entertext parcelable screen return result previous one kotlin class textentrysheet bottomsheetdialogfragment companion object fun readenteredtextresult succeeded string return resultresult resultdatatext private val router router unsafelazy requireactivity navigationtestactivityrouter override fun oncreatesavedinstancestate bundle superoncreatesavedinstancestate setstyledialogfragmentstylenormal rstyleclinicvthemebottomsheetfragment override fun oncreateviewinflater layoutinflater container viewgroup savedinstancestate bundle view return inflaterinflaterlayoutscreennavigationtextentrysheet container false override fun onviewcreatedview view savedinstancestate bundle superonviewcreatedview savedinstancestate donebuttonsetonclicklistener routerpopwithresultsucceededresultdatatextentryfieldtexttostring parcelize private data class resultdataval text string parcelable parcelize class key screenkey override fun instantiatefragment fragment return textentrysheet override val type screentype get screentypemodal support modal marking particular screen modal easy overriding screentype property screenkey implementation returning screentypemodal value kotlin class textentrysheet bottomsheetdialogfragment override fun oncreateviewinflater layoutinflater container viewgroup savedinstancestate bundle view return inflaterinflaterlayoutscreennavigationtextentrysheet container false parcelize class key screenkey override fun instantiatefragment fragment return textentrysheet override val type screentype get screentypemodal incremental migration current architecture since current screen built androidviewview instance framework androidxfragmentappfragment instance intermediate solution switch framework new screen older screen continue function minimal change order facilitate framework provide wrapper fragment screenwrapperfragment accept older fullscreenkey property embed screen within change done way individual screen get access screen key screen argument screen static method provided fragmentmanager order get fragment instance encapsulates view get screen key argument fragment instance might choose provide helper method instead every screen fairly straightforward there particular case would require move screen fragment however situation autosubmit value text field based given length like pin entry screen would migrate screen specifically needed way screen state restoration work current screen architecture play well together wrapped fragment apart case migrate screen required misc comparing usage goal weve defined earlier one havent considered following support layout editor preview support lifecycle component given free screen architecture based fragment layout resource file provided fragment via constructor require embed custom class within layout resource file anymore addition since based fragment get access default lifecycle provided framework needed proof concept implementation available consequence fragment navigation fragment notoriously complicated given additional lifecycle decoupled one parent activity well separate lifecycle fragment instance child view however feel okay start couple reason work navigation directly router instance encapsulate complexity related fragment transaction screen write enforced participate flow enforce android tool team planning simplify fragment lifecycle time opt simpler fragment lifecycle available additional maintenance code write handle navigation additional code maintain however consider additional boilerplate write deal problem current architecture significantly lesser effort maintain alternative try android recommended way handle navigation navigation component small section project decided couple reason navigation state defined multiple place create navigation xml file defines navigation destination action action trigger navigation flow code problem way navigation behaviour defined two different place hard get entire picture happening call site tradeoff lose ability get visual representation entire screen navigation graph acceptable tradeoff given simpler navigation code support opening destination getting result navigation framework support opening destination waiting result official recommendation viewmodel architecture component decided component project adding support would require additional workarounds could rather spend effort creating framework work