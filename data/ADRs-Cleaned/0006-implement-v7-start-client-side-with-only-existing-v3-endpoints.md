adr implementing start command clientside abstract cli start command must function similarly start command stage start app push nostart see story capi endpoint see design board whether implement feature capi cli posed challenge ultimately implement cli implement staging unstaged package start command cli side following step check app already started exit detect package ready staged assume user package meant staged recently uploaded package hasnt successfully turned droplet already curl get vappscf app appname guidpackagesorderbycreatedatperpage convert json response package take guid curl get vpackagespackageguiddropletsstatesstagedperpage final curl get droplet staged state run latest package came empty list resource build latest package curl post vbuild package guid packageguid poll staging log wait complete assign resulting droplet app curl patch vappsrelationshipscurrentdroplet data guid dropletguid start app curl post vappcf app appname guidactionsstart poll get process endpoint web process started state share step receive feedback client close contact provide open source resource client dependent start behavior implementation overly complex prefers breaking existing user workflow leaf potential room error around case user get unpredictable state depends imperative declarative workflow consequence stemming implement cli positive consequence cli user experience breaking change maintains rest api purity granular endpoint give advanced api consumer lot freedom implement creative solution allows future cloud foundry api client historic knowledge workflow depend way allows current client evolve around way negative consequence multiple client reimplement logic coherent definition start across client cause complex clientside logic difficult predict specific implementation interact new workflow rollback chose implement capi implementing capi would break fundamental principle designed avoid unpredictable orchestrator type api endpoint vappsguidactionsstart endpoint still relies modelhook vbuild endpoint currently follows api style guide preference endpoint asynchronously communicate component return pollable job combining two single endpoint would definitely lead unwanted complexity distribution business logic across multiple component resource general unpredictability one reason two action originally separated migration furthermore serverside implementation would imperfect interpretation restful design capi meant follow one principle restful architecture separation client serverside concern allows user interface evolve independently around consistent api allows scalability serverside simplifying component source given concern brought specific client capi meant service single client implementing serverside would cause unnecessary complexity finally clientside implementation relies api imperative way declarative workflow might preferred implementing start thorough series imperative endpoint would mean client would responsible predicting state user would want get externally leaf room error user get unpredictable state particularly around rollback case feedback capi consumer although concern start stage start unstarted application brought cli user worth noting client depend workflow well concept start changed greatly api side stretch imagine many client dependent old behavior would reimplement potential clientside interpretation opened dialogue held meeting apps manager team clientside implementation hear concern told open either solution would want notified api change might break current start implementation depended endpoint history collecting user feedback acceleration team brought attention order maintain essential workflow given vat access cli capi code base fell engineer decide whether changed behavior would implemented cli capi engineer chose implement behavior cli