feature caching zonder service worker moeten zowel tile feature kunnen cachen ngkaart voor offline gebruik offline data voorzien ngkaart werd initieel beslist met service worker werken voor zowel feature kaart tile bounding box gebruikt feature vragen echter afhankelijk van extent van view kaart omdat service worker enkel url kan cachen die altijd dezelfde url parameter hebben werd volgend systeem bedacht komt een extent binnen van kaart feature vragen nosqlfsloader component van ngkaart gaat deze call opsplitsen aantal nieuwe call gebaseerd een vaste grid bvb gebieden service worker kijkt voor aantal call die vaste grid boundary een tile bestaat indien stuur terug indien nee vraag online deze oplossing gaat echter gevolgen van beperkingen van service worker doortrekken tot logica van feature loader van ngkaart bovendien het aantal effectieve call per request dan veel hoger met performantie gevolgen daarom werd beslist voor het ophalen van feature geen gebruik maken van een service worker maar die wel niet een indexeddb bewaren mee integreren binnen nosqlfs van ngkaart stappen komt een extent binnen van kaart feature vragen nosqlfsloader gaat feature voor die extent opvragen aan featureserver bij ontvangen van feature worden deze bewaard een indexeddb per laag gemanaged door ngkaart indien nosqlfsloader binnen seconden geen antwoord heeft gekregen worden feature uit indexeddb gehaald consequence iets meer fetch strategy ontwikkelingen binnen ngkaart maar efficienter ophalen beheren van feature mogelijkheden ook extra metadata bij feature slaan bvb time saved indexeddb implementatienotas indexeddb essentieel een keyvalue store bij basale keyvalue store vergen complexe query inhoud van value table scan bij indexeddb kunnen echter wel index aangemaakt worden opzoekingen versnellen voor gekozen oplossing hebben vaak query deletes een view extent nodig een extent dimensionaal maar een index dimensionaal bovendien heeft een feature het algemeen zelf een bounding box wat maakt dat een feature gedeeltelijk een view extent kan vallen performant opvragen van feature die geheel gedeeltelijk met een extent overlappen dus niet triviaal een eenvoudig verstaanbaar algoritme volgt maken index aan voor minx maxx miny maxy waarden van bounding box van feature halen key van alle feature waarvoor minx binnen minx maxx van extent ligt halen key van alle feature waarvoor maxx binnen minx maxx van extent ligt halen key van alle feature waarvoor miny binnen miny maxy van extent ligt halen key van alle feature waarvoor maxy binnen miny maxy van extent ligt maken doorsnede van alle key daarmee halen alle waarden hoewel deze aanpak correct kunnen toch beter doen eens een index gebruiken kunnen waarden die bij index horen inspecteren die feature weerhouden die met extent overlappen die manier hoeven maar een keer door feature lopen het meeste voordeel kunnen behalen die index nemen die het minste feature zal opleveren weten helaas niet voorhand welke dat zal zijn maar die dimensie nemen waarvoor extent het smalste dan hebben grootste kans best index kiezen evenwel ook een nadeel aan deze aanpak vergelijking met die met doorsnedes plaats enkel key itereren moeten waarden ook binnen trekken dat heeft deserialisatie overhead metingen voorbeelddata tonen echter aan dat zowel voor kleine feature van naar grote extent van naar significante snelheidswinst behaald wordt een ander belangrijk voordeel van een enkele index dat feature onmiddellijk tijdens het itereren gemit kunnen worden gebruikers kunnen dus direct feedback van hun selectie krijgen