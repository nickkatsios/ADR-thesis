generalized randomness holochain application distributed application like centralized one often source randomness confidence verifiability randomness pose particular challenge distributed specifically source randomness following property outside control influence dice roll card deck shuffle something may interest skewing result predictably reproducable node whether player game validating node later reproduce random seed reach random output purpose validation generalizable ideally every application wont build approach randomness take advantage useful underlying convention pitfall want help avoid distributed eventually consistent system doesnt require specific party online access randomness data later validators confirm even party private entry online longer part network case multiple party wanting generate randomness together cointoss provides example sharing hash secret later revealed combined create random number seed method generalized storing bunch private secret publishing hash secret later revealing secret combined another party cointoss revelation happens via nodetonode communication general case doesnt work way application environment includes interaction gossip validation combination highly unpredicable include thing like network latency timestamps verifiable fact example first four validation signature opponent last move random seed could one approach implement mixins provide randomness generation usecases cointoss combined secret method single event dht pushed multiple event provide app level access unpredictable gossipvalidation event explicit seed random number generator consequence want approach reviewed proof validity approach get included security review add protocolcallscallbacks network abstraction layer see adr gain access randomness example case shuffle card deck poker game player take turn dealer player including dealer sign private entry chain random seed send seed dealer dealer combine seed including create randomness shuffle commits private entry player cut deck particular card committing number public entry end game dealer republish combined seed public entry enables everyone fully audit game dice roll backgammon game sure many dice roll take complete backgammon game imagine randomness generated player start game player commit private entry respective chain random seed ideally would merkle tree entry type weve built support progressively reveal leaf merkle tree via merkle proof build final hash visible along public header private entry turn player next random seed combined next dice roll ensures single player ever determine outcome dice roll youve seed finishing game player automatically commit another block seed continue play proof possession private chain suppose want raise level securityassurance app currency beyond private key author chain source chain private content well similar backgammon example chain genesis create private entry randomly generated leaf merkle tree new transaction include capability token enables counterparties retrieve merkle proof next leave transaction leaf transaction expose leaf add tiny amount data transaction low computing power show proper owner key chain