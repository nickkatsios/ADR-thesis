architecture record core runtime point every arachne application start bootstrap static project deployment artifact initialize initializing begin servicing request connecting database processing data etc several logically inherent subtasks bootstrapping process broken follows starting jvm assembling project dependency building jvm classpath starting jvm arachne specific reading initial usersupplied configuration configuration script adr initializing arachne configuration given project set module described adr adr application specific instantiate user moduledefined object exist runtime start stop user moduledefined service discussed adr task starting jvm category inscope arachne rather offloaded whatever builddependency tool project usually either boot leiningen leaf arachne applicationspecific startup task arachne provide orderly structured startup shutdown procedure make possible module application author hook ensure code initializes start stop desired additionally must possible different system component dependency eachother starting service start service upon depend stopping occur reversedependency order service never state running one dependency stopped component arachne component library manage system component instead requiring user define component system map manually however arachne build one based upon arachne config via configuration entity appear configuration component entity may added config directly end user via initialization script per adr module configure function adr component entity attribute indicates component depend upon circular dependency allowed component dependency structure must form directed acyclic graph dag dependency attribute also specify key component assoc dependency component entity also attribute specifies component constructor function via fully qualified name component constructor function must take two argument configuration entity component constructed invoked component constructor must return runtime component object component library may object implement clojurelangassociative may also optionally satisfy component lifecycle protocol arachne runtime toplevel entity arachne system reified arachne runtime object object contains component system object configuration value upon runtime based satisfies lifecycle protocol started stopped component object contains started stopped appropriate order constructor function runtime take configuration value number root entity lookup ref component entity config root component transitive dependency instantiated added component system word component entity actually instantiated unused component entity defined config ignored lookup function provided find runtime object instance component given entity lookup ref configuraiton startup procedure arachne rely upon external build tool boot leiningen handle downloading dependency assembling classpath starting jvm jvm correct classpath running following step required yield running arachne runtime determine set module active module build configuration schema querying active module schema function adr update config initial configuration data user init script adr module dependency order give module chance query update configuration configure function adr create new arachne runtime given configuration set root component call runtimes start method arachne codebase provide entry point automatically perform step common development production scenario alternatively always executed individually repl composed custom startup function proposed consequence possible fully define system component dependency application configuration arachne achieves dependency injection inversion control possible explicitly create start stop arachne runtimes multiple arachne runtimes may coexist jvm although may conflict fail start attempt global resource http port specifying different root component constructing runtime possible run different type arachne application based arachne configuration value