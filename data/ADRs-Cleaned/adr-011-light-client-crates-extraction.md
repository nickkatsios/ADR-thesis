adr light client crate extraction changelog initial draft current design ibc module crate precludes light client implementation hosted outside ibcrs repository primarily due circular dependency tight coupling light client implementation ibc crate tendermint light client implementation rightly depends ibc crate trait definition clientstate light client expected implement ibc crate also depends tendermint light client clientstate impl define anyclientstate enum rust pub enum anyclientstate tendermintclientstateclientstate cfganytest feature mock mockmockclientstate rationale behind enum design choice described adr dealing chainspecific datatypes could alternatively model chainspecific datatypes boxed trait object boxdyn trait approach run lot limitation trait object inability easily require trait object clonable serializable define equality relation support functionality found thirdparty library overall experience developer subpar thus settle different strategy lifting chainspecific data enum possible chain type additionally place core module code indirectly depends light client specific type code clienteventstryfromtx function must able deserialize light client specific header updateclient event rust pub fromtxresponseeventheight height event tendermintabcievent optionibcevent let somemut clientres clienteventstryfromtxevent clientressetheightheight someclientres look add support lightclients would much desirable core module code light client agnostic allowing light client implementation hosted externally maintained audited independently would possible break circular dependency extracting core code type trait etc light client implementation would possibly separate crate say ibcbase ibc module crate light client implementation crate depend ibcbase crate implemented solution seems fragile unmaintainable adr proposes break circular dependency problem removing enums completely traitobjects place object safety total light client trait associated enum implement anyclient implement clientdef anyclientstate implement clientstate anyconsensusstate implement consensusstate anyheader implement header anymisbehaviour implement misbehaviour order replace enums trait object light client trait must object safe essentially mean trait cannot self sized requirement method cannot type parameter cannot self restriction implication possible workarounds documented trait require self sized cannot supertraits supertraits light client trait self sized requirement include coreconvertintot fromt tendermintprotoprotobuf clone etc erasedserde crate employ novel technique provide object safe version serde trait operate seamlessly original nonobject safe counterpart element technique provide object safe version tendermintprotoprotobuf trait supertrait rust mod erased coreconvertinto coreinto tryfrom coretryfrom mod sealed super pub trait sealedintot sized implt clone coreintot sealedintot pub trait sealedtryfromt implt coretryfromt sealedtryfromt pub trait intot sized sealedsealedintot intoself boxt implt clone coreintot intot intoself boxt boxnewselfcloneinto pub trait tryfromt sealedsealedtryfromt type error tryfromt resultself selferror self sized implt coretryfromt tryfromt type error self coretryfromterror tryfromt resultself selferror self sized self coretryfromttryfromt pub trait protobuf self erasedtryfrom erasedinto error display pub trait header protobuf clone cannot supertrait cannot derived type containing boxed trait object following made work dynclone crate rust deriveclone pub struct result pub clientid clientid pub clientstate box pub consensusstate box rust pub trait clientstate dynclonedynclone dyncloneclonetraitobjectclientstate dynclone also provides clonebox function get boxt deriving serdeserialize deserialize trait object replacing anyheader boxdyn header wouldnt work code deserialize requires self sized serialize generic type rust derivedeserialize serialize pub struct updateclient pub common attribute pub header solved ibcprotogoogleprotobufany type instead thereby deferring actual encodingdecoding host handler execution thankfully core module code doesnt serde derivation except log error host lightclient implementation optionally choose downcast concrete type serde derivation directly available light client trait cannot constructor restriction come fact trait method object safe trait cannot return self however would constructor able create clientstate consensusstate createclient handler done self sized clause trait method rust ibcprotogoogleprotobufany pub trait clientstate decodeany box self sized downcasting support ability upcast dyn dyn coreanyany able downcast concrete type done trait blanket implementation rust pub mod dynamictyping coreanyany pub trait asany asanyself dyn implt asany asanyself dyn self light client trait could add asany supertrait rust cratedynamictypingasany pub trait header asany usage would look like rust downcastheaderh dyn header resulttmheader icserror hasany downcastreftmheader okorelse icserrorclientargstypemismatchclienttypetendermint special case removing anyclient merging clientdef clientstate anyclient enum special mostly stateless always created onthefly clienttype verification handler updateclientprocess rust pub process ctx dyn clientreader handlerresult let clienttype ctxclienttypeclientid let clientdef anyclientfromclienttypeclienttype let clientstate ctxclientstateclientid let newclientstate newconsensusstate clientdef checkheaderandupdatestatectx clientid clientstate header anyclient enum implement clientdef trait defines light client verification function note host required store onchain creating clientdef instance onthefly problematic would require module code aware clienttype clientdef mapping known clienttypes solved merging trait method clientdef trait clientstate trait removing clientdef trait altogether rust pub trait clientstate clientstate method chainidself chainid clienttypeself clienttype followed clientdef method checkheaderandupdatestate self ctx dyn clientreader clientid clientid clientstate dyn clientstate header dyn header resultboxdyn clientstate boxdyn consensusstate error clientstate instance access verification function directly rust pub process ctx dyn clientreader handlerresult let clientstate ctxclientstateclientid let newclientstate newconsensusstate clientstate checkheaderandupdatestatectx clientid clientstate header domain type containing light client specific type raw type messagecreateclient contain light client clientstate consensusstate serialized googleprotobufany rust pub struct msgcreateclient light client state prostmessage optional tag pub clientstate coreoptionoptionsupersupersupersupergoogleprotobufany consensus state associated client corresponds given height prostmessage optional tag pub consensusstate coreoptionoptionsupersupersupersupergoogleprotobufany ideally domain type would contain validated clientstate consensusstate type possible anymore ibc crate cannot depend light client crate therefore proposed domain type continue type field defer validation handler light client specific code sizeable amount light client specific code exists ibc crate today hermes helper function extract ibcevents tendermintabcievents fromtxresponseevent fairly straightforward move code ibcrelayer crate case core type depend light client type icsclienterror icstenderminterrors variant rust crateclientsicstenderminterrorerror icserror defineerror derivedebug partialeq error tendermint icserror tendermint error tenderminthandlererror icserror formatargstendermintspecific handler error clientspecific variant provided workaround accompanying fromicserror impl ease rust modulessrccoreicsclienterrorrs defineerror derivedebug partialeq error clientspecific description string formatargsclient specific error edescription rust modulessrcclientsicstenderminterrorrs impl fromicserror icserror frome icserror self selfclientspecificetostring additionally code might helpful host implementation event conversion ibcevent tendermintabcievent required delivertx implementation note code lead circular dependency problem adr attempt address therefore continue live ibc crate although ideally recommended client specific code moved either ibcrelayer crate light client crate issue kind dealt casebycase basis light client registry proposal adr ibc crate would light client agnostic however host implementation must still aware light client wish support blockchain must able deserialize type persistent store restart furthermore protobuf emerged canonical serialization scheme ibc ibcs message definition usually serialize light client type googleprotobufany type typeurl uniquely represent specific light client type although standardized yet proposed standardize provide ibcclientregistry crate standardizes collect known light client implementation crate must provide one deserialization entrypoint function per light client type rust ibcprotogoogleprotobufany pub const tendermintheadertypeurl str ibclightclientstendermintvheader decodeheaderanyheader result error match anyheadertypeurl tendermintheadertypeurl tendermintheadertryfromanyheadermaperre errordecodeheadere errerrorunsupportedclient way standardized list supported light client host implementation would directly import every single light client crate wish support crate could feature gate light client support provide host granular control light client wish support crate could additionally reexport concrete light client type allow user downcast trait object returned library crate must come disclaimer inclusion registry imply guarantee correctness light client implementation note host implementation able add support light client regardless whether included registry splitting work across multiple suggested proposed change split across multiple following way remove enums usage light client implementation make light client trait object safe move tendermint specific code ibc crate either ibcrelayer crate light client implementation remove enums ibc crate pin workspace crate stable ibc version extract light client implementation separate crate update workspace crate new api longlived branch may block development module code meantime proposed consequence positive light client implementation hosted separate crate outside ibcrs repo light client implementation maintained audited independently resulting clearer ownership ibc crate would light client agnostic wouldnt updated add support newer light client host chain implementation able choose light client wish support facilitates separation clientspecific code negative restriction due object safety associated type cannot supertraits cannot sized supertrait cannot derive common trait copy serdeserialize deserialize etc type containing trait object etc possible performance hit due heap allocation dynamic dispatch neutral client registry must maintained kept uptodate although host implementation forced rely registry add support light client registry reference removing enums remove occurrence enums light client remove enums experimental extracting ibcbase crate rationale behind design choice enums adr dealing chainspecific datatypes erasedserde work