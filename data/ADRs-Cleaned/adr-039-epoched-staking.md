adr epoched staking changelog feb initial draft author dev ojha valardragon sunny aggarwal sunnya proposed abstract adr update proof stake module buffer staking weight update number block updating consensus staking weight length buffer dubbed epoch prior functionality staking module special case abstracted module epoch set block current proof stake module take design apply staking weight change consensus engine immediately mean delegation unbonds get applied immediately validator set primarily done implementationally simplest time believed would lead better client design choice allow buffering staking update delegation unbonds validators joining number block epochd proof stake consensus provides guarantee consensus weight validators change midepoch except event slash condition additionally hurdle may significant previously thought possible provide user immediate acknowledgement bond recorded executed furthermore become clearer time immediate execution staking event come limitation threshold based cryptography one main limitation validator set change regularly make running multiparty computation fixed validator set difficult many thresholdbased cryptographic feature blockchains randomness beacon threshold decryption require computationallyexpensive dkg process take much longer block create productively guarantee result dkg reasonably long time wouldnt feasible rerun dkg every block epoching staking guarantee well run new dkg every epoch light client efficiency would lessen overhead ibc high churn validator set tendermint light client bisection algorithm number header verify related bounding difference validator set trusted header latest header difference great verify header two limiting frequency validator set change reduce worst case size ibc lite client proof occurs validator set high churn fairness deterministic leader election currently way reasoning fairness deterministic leader election presence staking change without epoch tendermintspec breaking fairness leader election profitable validators earn additional reward proposer adding epoch least make easier deterministic leader election match something prove secure albeit still havent proven current algorithm fair validators presence stake change staking derivative design currently reward distribution done lazily fee distribution saving computational complexity lazy accounting requires stateful staking implementation right delegation entry track time last withdrawal handling challenge staking derivative design seek provide fungibility token staked single validator forcewithdrawing reward user help solve however infeasible forcewithdraw reward user per block basis epoch chain could easily alter design reward forcefully withdrawn iterating delegator account perepoch thus remove delegation timing state may useful certain staking derivative design design consideration slashing design consideration whether apply slash immediately end epoch slash event apply member actually staked time infraction namely epoch slash event occurred applying immediately viewed offering greater consensus layer security potential cost aforementioned usecases benefit immediate slashing consensus layer security obtained executing validator jailing immediately thus removing validator set delaying actual slash change validators weight epoch boundary case mentioned workarounds integrated avoid problem follows threshold based cryptography setting threshold cryptography original epoch weight consensus update let rapidly benefit additional security threshold based cryptography block liveness chain effectively raised liveness threshold remaining validators rest epoch alternatively jailed node could still contribute share plan fail extreme case validators jailed within single epoch extreme scenario chain already custom incident response plan defining handle threshold cryptography part light client efficiency bit included header indicating intraepoch slash ala httpsgithubcomtendermintspecissues fairness deterministic leader election applying slash jailing within epoch would break guarantee seeking provide reintroduces new significantly simpler problem trying provide fairness guarantee namely validators adversarially elect remove themself set proposer security perspective could potentially handled two different mechanism prove still difficult achieve one making security statement acknowledging ability adversary force aheadoftime fixed threshold user drop proposer set within epoch second method would parameterize cost slash within epoch far outweighs benefit due proposer however latter criterion quite dubious since proposer many advantageous sideeffects chain complex state machine namely defi game fomod staking derivative design issue introduced increase state size staking record since whether slash occurred fully queryable given validator address token lockup someone make transaction delegate even though immediately staked token moved pool managed staking module end epoch prevents concern stake spend token realizing already allocated staking thus staking fail pipelining epoch threshold based cryptography particular pipeline epoch change epoch want epoch weight fixed validator set dkg accordingly currently epoch stake weight epoch already fixed new stake change getting applied epoch handled making parameter epoch pipeline length parameter alterable except hard fork mitigate implementation complexity switching pipeline length pipeline length redelegate epoch redelegation applied prior beginning epoch pipeline length redelegate epoch redelegation applied prior beginning epoch reward even though staking update applied epoch boundary reward still distributed immediately claimed affect current stake weight implement autobonding reward feature implemented would setup reward autobonded epoch boundary parameterizing epoch length choosing epoch length tradeoff queued statecomputation buildup countering previously discussed limitation immediate execution apply given chain abci mechanism variable block time introduced illadvised high epoch length due computation buildup block execution time greater expected block time tendermint round may increment step implement buffering staking slashing message first create pool storing token bonded applied epoch boundary called epochdelegationpool two separate queue one staking one slashing describe happens message delivered staking message msgcreatevalidator move user selfbond epochdelegationpool immediately queue message epoch boundary handle selfbond taking fund epochdelegationpool epoch execution fail return back fund epochdelegationpool user account msgeditvalidator validate message valid queue message execution end epoch msgdelegate move user fund epochdelegationpool immediately queue message epoch boundary handle delegation taking fund epochdelegationpool epoch execution fail return back fund epochdelegationpool user account msgbeginredelegate validate message valid queue message execution end epoch msgundelegate validate message valid queue message execution end epoch slashing message msgunjail validate message valid queue message execution end epoch slash event whenever slash event created get queued slashing module apply end epoch queue setup slash applies immediately evidence message msgsubmitevidence get executed immediately validator get jailed immediately however slashing actual slash event get queued add method end blocker ensure epoch boundary queue cleared delegation update applied step implement querying queued staking querying staking activity given address return amount token staked also queued stake event address require work done querying logic trace queued upcoming staking event initial implementation implemented linear search queued staking event however chain long epoch eventually build additional support node support querying able produce result constant time doable maintaining auxiliary hashmap indexing upcoming staking event address step adjust gas currently gas represents cost executing transaction done immediately merging together cost overhead state access overhead computational overhead however transaction cause computation future block namely epoch boundary handle initially include parameter estimating amount future computation denominated gas add flat charge needed message leave scope weight future computation versus current computation gas pricing set weighted equally consequence positive abstract proof stake module allows retaining existing functionality enables new feature validatorset based threshold cryptography negative increase complexity integrating complex gas pricing mechanism consider future execution cost well epoch validators longer leave network immediately must wait epoch boundary