interpretation function rule applying function rule form equation implemented koreequationapplication purpose document describes function rule currently interpreted kore expose problem current approach explains function rule interpreted kore future solve problem notation refer element variable refer variable respective family element variable fun function symbol arbitrary pattern appearing argument function rule arbitrary pattern appearing righthand side function rule pre post respectively pre postcondition pattern background section briefly describe function rule interpreted kore continue next section expose problem interpretation consider function fun described family rule rule funy requires prey ensures posty rule interpreted kore axiom kore axiom impliesprey funy posty problem partial head see also runtimeverificationhaskellbackend rule partial head potentially unsound consider family rule rule sizemap mmap int sizemapm rule sizemap rule sizemapmap producing axiom kore axiom sizemapconcatmapelementmap mmap int sizemapm axiom sizemapelementmap axiom sizemapmap note first rule partial head instantiate elementmap prove kore sizemapconcatmapelementmap elementmap int sizemapelementmap sizemapbottom int sizemapelementmap sizemapbottom int bottom pattern see also runtimeverificationhaskellbackend consider family rule defining function fun rule funa rule funb interpreted kore two axiom kore axiom impliestop funa top axiom impliestop funb top language offer shorthand notation rule funa intended equivalent pair rule current interpretation rule produce axiom kore axiom impliestop funa top equivalent first interpretation specifically first interpretation satisfied funa funb second interpretation satisfied funa funb bottom funa bottom funb therefore current interpretation function rule faithful user intent priority priority attribute properly supported owise attribute supported implementation inefficient work duplicated rechecking rule family apply solution interpretation simplification rule change family rule defining fun rule funy requires prey ensures posty interpreted kore kore axiom impliesprey argsx priox funx posty kore argsx priox prey argsx priorityrule priorityrule predicate args interprets argument pattern elementwise matching user intent see avoiding problem described predicate prio encodes priority attribute precondition rule possible moved argument matching args precondition partial head troublesome example rule sizemap mmap int sizemapm interpreted kore kore axiom impliesx concatmapelementmap mmap sizemapx int sizemapm concatmap undefined precondition concatmap satisfied therefore rule sound pattern example orpattern rule rule funa interpreted kore axiom impliesx funx disjunction distributes kore implies kore impliesx funx impliesx funx impliesx funx original axiom equivalent two axiom intended kore axiom impliesx funx axiom impliesx funx priority priority owise attribute encoded explicitly precondition axiom consider function rule lint xint false requires notbool int rule xint uint false requires notbool int priority rule true owise interpreted kore axiom kore axiom implies true notboolintl false top axiom implies true notboolintx exists true notboolintl false top axiom implies top top exists true notboolintl exists true notboolintx true top