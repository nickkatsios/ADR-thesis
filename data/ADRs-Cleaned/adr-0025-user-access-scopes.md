user access scope application come interact raster foundry api control user permission different axis become apparent currently raster foundry api handle permission refer specific object instance access control rule assigned user point specific object indicates allowed action system support access control across object type rule encodes user cannot create project user cannot delete annotation adr seek develop solution problem technical goal minimize performance overhead related evaluating userscopes perrequest minimally develop approach prevents certain user creating new object project scene etc ideally develop approach flexible enough handle unforeseen access control scenario solution solution except last treat scope access reduction mechanism full access defined absence scope presence scope reduces access user question reason assumed majority user access restriction common application system preventing project creation specifying done would require many rule specifying cant done basic solution user column representing list readonly scope user user column named scope list containing project scene every value scope list member objecttype api endpoint affected would lookup requesting user see scope present prevent request fulfilled usage endpoint level might look like scala def createproject route authenticate user authorizeasync userdao withoutscopingobjecttypeproject transactxa unsafetofuture entityasprojectcreate newproject onsuccess projectdao insertprojectnewproject user transactxa unsafetofuture project completestatuscodescreated project advantage possible conflict handle readonly restriction minimal effect current datamodels requires one additional field user disadvantage support readonly scoping requires machinery encodedecode scope tofrom wild west solution solution almost constraint user column representing list scope example projectreadonly projectnodelete scope could defined within scopetype enforce value api endpoint affected would lookup requesting user see scope present prevent request fulfilled usage endpoint level might look like scala def createproject route authenticate user authorizeasync userdao withoutscopingscopetypeprojectreadonly transactxa unsafetofuture entityasprojectcreate newproject onsuccess projectdao insertprojectnewproject user transactxa unsafetofuture project completestatuscodescreated project advantage easy add new scope needed minimal effect current datamodels requires one additional field user disadvantage lack constraint make possible conflicting rule would necessitate programmatic resolution approach requires machinery encodedecode scope tofrom civilized solution solution constrained order solve conflicting rule problem user series column representing object type scope column named projectscope scenescope value column scope type readonly column would accept single value mean object type user single scope would prevent rule conflict scope type would defined within scopetype enforce value api endpoint affected would lookup requesting user see scope present prevent request fulfilled usage endpoint level might look like scala def createproject route authenticate user authorizeasync userdao withoutscopingobjecttypeproject scopetypereadonly transactxa unsafetofuture entityasprojectcreate newproject onsuccess projectdao insertprojectnewproject user transactxa unsafetofuture project completestatuscodescreated project advantage easy add new scope needed conflict prevention strategy builtin promotes consistency narrowing scopetype member disadvantage requires bunch column added likely user datamodeltable require machinery map objecttypes column granular variation solution similar civilized solution would absence scope certain domain imply full access example user project scope granted full access project operation solution differs others scope treated endpoint level example user instead scope projectread would allowed interact project read endpoint contrast approach invert process determine operation allowed scope could implemented single scope column column domain project scene etc column would contain list applied scope user scope type would defined within scopetype enforce value api endpoint affected would lookup requesting user ensure scope present relevant domain necessary scope present usage endpoint level might look like scala def createproject route authenticate user authorizeasync userdao hasscopeobjecttypeproject scopetyperead transactxa unsafetofuture entityasprojectcreate newproject onsuccess projectdao insertprojectnewproject user transactxa unsafetofuture project completestatuscodescreated project advantage easy add new scope needed promotes consistency narrowing scopetype member encourages granular approach scoping versus larger allencompassing scope type readonly much intuitive endpoint level disadvantage could require bunch column added could alternatively require complex encodingdecoding process lack flexibility enough discard basic solution conflict resolution probably enough discard wild west solution civilized solution clear granular variation seems require amount effort implement forward granular variation