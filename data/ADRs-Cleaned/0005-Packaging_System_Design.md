konduit serving packaging system proposed alex black discussed sam paul konduit serving complex modular tool intended deployed number different configuration multiple packaging format given modelpipeline deploymentpackaging scenario vary widely example user might want deploy tensorflow model via konduit serving one configuration many docker image packaging tensorflow cuda linux arm system serving via httprest selfcontained exe embedded jvm samediff tensorflow import run model cpu window avx system intel mkl mkldnn onednn included serving performed via grpc currently packaging konduit serving done via maven profile maven module user selects combination dopendencies functionality enabling number profile system property example building window cpu uber jar look something like mvn clean package dskiptests puberjar pcpu ppython pnative ppmml ptensorflow dchipcpu djavacppplatformwindowsx packaging executed adding different profile approach got quite far term packaging enabling flexible packaging including uberjars docker war debrpms tar file exe file running limit approach specifically approach following problem combination available user going continue grow many profile combination devsusers know understand combination difficult impossible profile property example building binary window linux mac ppc etc easy leave performance table ndjsamedifftensorflow etc binary built without avx support many incompatibility become apparent runtime example build cuda version find tensorflow release cuda hence runtime problem dataapi rewrite configuration execution separate one configuration run many different way example tensorflow model could run tensorflow samediff tvm possibly automated conversion onnx etc challenging support via profile property build approach usability issue example user know lot different profile configuration etc get optimal even functional deployment even know possible example user might build uberjar without pmml profile enabled discover jar cant run pipeline pmml model packaging custom code dependency asset inc model vocabulary file etc difficult impossible present building konduit serving artifact uberjars docker image etc requires cloning main source code repo though hide automatically case python clibased source build proposal scope proposal limited creationpackaging konduit serving uberjar may deployed many form docker rpm war etc note nonjava packagingdeployments pipeline scope deploy pure binary osgi support relevant scope extent osgibased system could work build top functionality described proposal proposal goal goal packaging proposal follows retain enhance existing deployment uberjar docker war exe etc remove reliance build source constructing konduit serving artifact enable greater flexibility builddeployment configuration enable custom java python code dependency easily included deployment improve usability reliability packaging following way remove reliance maven profile property least executing build automate selection recommendation module include given pipeline look pipeline config find whats necessaryuseful include add validation checking common pitfall dependency issue incompatible cpu architecture wrong cuda version etc make clear user requirement term hardware software satisfied deployment system requires cuda java etc proposal overview proposal number part build tool top gradle via buildgradlekts generation utilizes configuration format actually perform required build konduit serving build configuration format command line tool creating build configuration user pipeline necessary triggering build based generated build configuration file system packaging custom java code dependency note usability possible well make user doesnt aware build configuration file example simple cli might configure execute build cli would generate configuration pas build tool without user aware configuration file however advanced user case system administrator devops etc allow configuration file written modified directly outside cliui workflow user part build tool given configuration file specifies included build detail later build tool execute build necessary create requested artifact jar docker image etc note term build tool may ideal name proposed tool simply thin layer top maven comparable true build tool like maven gradle ant etc note also principle though proposed right multiple build tool creating final artifact configuration definition build tool build execution separate look pure deployment main possible second build tool would osgibased deployment however would still maven based proposed build tool generate execute via gradle buildgradlekts file based configuration file similar current module profile approach continue maven plugins actual packaging creation uberjars etc generated buildgradlekts file include repository section repository mavencentral plugin section plugins java dependency section listing direct dependency required konduit serving module konduitservingtensorflow konduitservingndj etc native library backend dependency ndj nativecuda backends example logging etc dependency property sourcecompatibility targetcompatibility section necessary creating build artifact docker image war file etc utility task enforcing dependency convergence etc one consequence packaging module would removed favor single konduitservingbuild module konduitservingdocker konduitservingrpm konduitservinguberjar etc longer exist future likely allow build tool create multiple different artifact based one configuration file one uberjar user target platform output example separate jar file one linux linux armhf window usability perspective note user usually wont interact build tool directly instead touching aware uicli layer top gradle maven near term either tool gradle maven adequate implementing proposal build tool maven advantage something team currently experience however gradle seems edge two respect build speedperformance httpsgradleorgmavenvsgradle extensibilityflexibility including coding directly buildgradle file plan proceed gradle result major blockes either switch add parallel implementation based maven gradle kotlin instead groovy generated build file practice wont make much difference build configuration generated written hand kotlin provide benefit groovy better ide support due static typing hence get benefit autocompletion easy navigation source easier refactoring etc work generated buildgradlekts file directly part configuration file configuration file provide information necessary determine build via generated buildgradlekts file set direct dependency plugins property profile end following information included part configuration konduit serving module include konduit serving version optional default latest specified deployment packaging type uberjar docker etc associated configuration deployment target architecture cpu gpu etc selected preferred pipeline step runner one exists one included pipeline step information necessary package required externalcustom code dependency file resource etc additional dependency configuration override dependency management exclusion etc metadata timestamps comment author etc jsonyaml proposed format build configuration file part cli cli build tool one way user configure build required deployment artifact uberjar docker image etc internally usually without user aware cli tool create build configuration pas build tool execution two mode operation proposed cli command line style wizard style command line style provide information necessary produce configuration file short form exact configuration designed detail later likely look something like following bash konduitbuild mypipelinejson module tensorflowndjimage deploy docker dockerconfig namexversiony incudejava comcompanymylibrary wizard style cli guide user selecting pipeline term implementation priority implementation command line style specific design worked suggested usage look something like following konduitbuild konduit serving build tool enter path pipeline json yml file ctrlc exit myfileyml select deployment environment comma space delimited case insensitive linux window mac osx lahf linux arm armhf linux arm arm lla wizard style would output command line style command entered optionally configuration file would execute build based configuration part build build would simple singlepage nothing fancy feature rich near term focused three thing guiding user configuration process pipeline main goal show user required module serving pipeline customing deployment target platform selected model runner configure step etc creating configuration file though would implemented backend based user selects via triggering build based generated configuration file user able load previouslycreated build configuration file partially completely specified starting point pipeline build later may add way visualize create pipeline configuration also look would separate adr proposed starting stopping build straightforward assuming user konduit python package similar installed konduitbuildui konduit serving build launched httpslocalhost ctrlc exit workflow would user would something like launch konduitbuildui select konduit serving pipeline deploy later allow generic model similar selection instead providing pipeline configuration select deployment environment cpu architecture cpu gpu avx support etc later device profile select pipeline step runner multiple available example running tensorflow model whether samediff tvm etc run model optionally add custom java code python code dependency java codedependencies simple specifying gav coordinate user project python packaging dependency tbd may something like directory requirementstxt optionally embed filesresources deployment artifact including model file required select packaging uberjar docker exe etc selected show configuration relevant packaging click verify check produce final report would check dependency estimate final file size verify binary compatibility etc necessary prompt user thing explicitly approve example necessary accepting license party software bundled click build execute build would pas configuration build tool create final artifact uberjars docker image etc point user would able save current configuration yamljson file load back later stage would allow user select consistent previous choice still visible grayed step regarding device profile idea would allow user select thing like raspberry jetson nano generic linux possibly even common cloud vms reduce amount knowledgeconfiguration required create pipeline part pipeline analysis module selection important component cli would determining konduit serving module included execute pipeline available runner could execute step contained within nearterm could add something semiautomatically trackaggregate execution supportcapabilities across module wed build mapping module name rather pipelinesteprunners pipelinestep configuration run basic version especially difficult idea would encode information like samediffpipelinesteprunner module konduitservingsamediff execute step type tensorflowpipelinestep advanced version actually check configuration would added later samediffpipelinesteprunner run tensorflow model well check configuration time one thing keep mind extensibility example one day might custom pipeline step available via konduit serving hub codedependencies custom pipeline step could pulled automatically however substantially alter basic approach analysismodule selection principle simply adding external web lookup step determine run given step part customexternal java code dependency pipeline user want write custom java code example custom pipeline step custom metric etc custom java code dependency direct transitive also included built jar easy system including code dependency konduit serving pipeline java proposal handling trivially simple user package code standard maven project user mvn install project including custom code local maven repository note uberjar standard modulejar direct transitive dependency fine user specify gav coordinate group artifact version custom functionality configuration file likely via cliui additional possible mechanism could added later would provide way building github repository clone install add konduit serving deployment would doable couple line configuration could useful cicd based pipeline install provide gav approach also work fine osgibased buildsdeployments future future adrs number aspect packaging system would worked future adrs adrs may may produced following component configuration format design custom python code dependency embedding architecture compatibility checking dependency native code include dependency actually work arm ppcle etc fileresource embedding usability isuses user pipeline access embedded file consequence advantage get flexible powerful build system enable mostall javabased packaging including improved configuration optionscontrol current profilesproperties approach improved build reliability via compatibility check built system move problem run time buildconfiguration time improved usability via guiding user available compatible via cli easier debugging build see exact generated standalone pombuildgradlekts work backwards something wrong try figure exactly included disadvantage check difficult implement may possible always perform reliably example arbitrary python library work arm add yet another configuration fileformat user know learn proposed custom java packaging via maven projectinstall might work well gradle sbt user however analogous workflow gradlesbt could added added discussion consider basing tool gradle may better match maven easier extend necessary gradle maven originally adr proposed maven also gradle may beneficial ifwhen deploy android though many issue android deployment consider beyond mavengradle note however pomxmlbuildgradle wont generated reused longlived project anything instead generated build config usability user experience ide support shouldnt matter maven gradle one benefit alex either building overseeing team generally maven experience also necessarily eitheror could maven gradle build tool implementation switch later without user really aware switch gradle pomxml file generator also might provide another make build tool live inside parent build tool motivation enable user access konduit serving build functionality without external installation though pip install konduitserving way get build tool probably serve average python developerdata scientist wont ideal jvmbased developer perhaps maven plugin gradle task would provide good usability mvn aikonduitservingforpipeline foobaryaml gradle dowhateverineed ability konduit serving build jvm maven gradle installed nothing else either potentially oneliners getting set konduit serving build tool include sudo aptget install konduitserving linux user konduitbuildw script wrapper script like maven gradle wrapper mvnw gradlew actually going build konduit serving source people build tool would require even encourage building source given generating pomxmlbuildgradle work release version without local copy source target audience build tool user usually wont interact build tool directly instead touching aware uicli layer top target whole package functionality cliuibuild tool etc pretty much user standard offtheshelf model serving anyone custom codedependencies customize build specific hardware specific execution framework etc line see expanding allow packaging deployment target like helping people deploy android expect every single user konduit serving building special build deployment thats kind tangential proposal there nothing stopping offtheshelf buildsartifacts common scenario linuxwinmac cpu example without tool either distributed directly via docker hub whatever simply simpledefault build one day well provide osgibased deployment allow automaticruntime download installation module dependency also