adr extending relationship field allow recordtorecord reference jean cochrane open source fellow summer introduced proposal extend relationship field allow reference record datastore adr investigates whether feature possible proposes next step background basic idea recordtorecord reference permit one record point another example imagine two recordtypes store data event well advertisement event poster poster image image datetime location coordinate event title string datetime location coordinate recordtorecord reference would allow link poster event represent poster image image datetime location coordinate event uuid poster could grouped searched filtered according event reference implementation description currently reference implemented localreference data type schema editor titled relationship permit reference field contained within referencing record schema editor recordtorecord foreign key could represented new field externalreference schema definition along line json externalreference allof ref definitionsabstractbasefield ref definitionsabstractrequirablefield title recordtorecord relationship property fieldtitle title relationship title type string minlength recordtype allof ref httpsgroutserverhostnameapirecordtypesreferentsjson fieldtype hidden true type string enum externalreference apirecordtypesreferentsjson endpoint would return list available recordtypes user select order choose value recordtype output endpoint would look like json title recordtype related record type string format select enumsource source title recordtypetitle value recordtypeuuid recordtypes api saving final schema schemasservicejs recordtype uuid user selected recordtype field would define available record value reference schema would make ref attribute load valid record dynamically grout api endpoint validation javascript propertyname allof ref httpsgroutserverhostnameapirecordtypesuuidreferentsjson case apirecordtypesuuidreferentsjson endpoint would resolve type definition listing available record type string format select enumsource source title digest record value record uuid record api import consideration pattern unlike dereks initial comment suggesting pattern would change schema editor specifically schemasservicejs order support new field necessary point process take recordtype selected user translates ref endpoint validating record however approach still benefit leveraging ref push validation burden onto json schema without write custom validators totally clear yet whether validation external ref work jsonschema draft latest version supported json editor see thread discussion reference validation confirmed moving ahead pattern assuming record appendonly meaning cannot deleted database grout api pattern always validate properly long apirecordtypesuuidreferentsjson endpoint return list active record well archived record however returning record recordtype regardless whether theyre active could potentially confusing end user data collection work might hard tell record active endpoint may return overwhelmingly large list record record returned api easily distinguishable based whether active ideally data collection allow record filled autocomplete search application list available record grow large performance referentsjson endpoint could cause problem client wait time server memory endpoint profiled performance pattern assumes referentsjson endpoint fully public could problem application sensitive data ideal world admin would able set permission endpoint requirement recordtorecord foreign key workable permit three basic operation filtering foreign key relationship support nested search filtering match rest grout field type validation incoming record includes foreign key validation function groutmodelsschemamodelvalidateschema able check whether referent exists database indexing database lookup based foreign key must performant without way index foreign key relationship lookup may reasonable large production system brief note null pointer one operation didnt make list resolution null pointer null pointer classic problem nonrelational data store document point document document removed system nosql database offer system automatically resolving null reference whether raising error setting default simply storing null value foreign key example given could imagine user deleting event referenced poster uuid stored posterevent would reference coherent entity database null pointer might appear issue recordtorecord reference however grout data model provides avenue easily protecting problem recordarchived field user try delete record schema editor set record archived true instead deleting behavior mean grout functionally appendonly system reference always validate correctly spite appendonly nature there still chance authorized user could delete record issuing delete command directly api fully protect null pointer grout api updated either deny request handle delete request way theyre handled setting archived true evaluating requirement filtering since recordtorecord reference would store uuids string referent record simple filtering recordtorecord reference grout json field namely django jsonfield operation apply including field lookup python recordobjectsfilterdatareferencefielduuid containment operation python recordobjectsfilterdatacontainsreferencefield uuid key lookup equivalent postgres operator python recordobjectsfilterdatahaskeyreferencefield limitation filtering jsonfields exist particular since parser assumes filter like datareferencefield nested json path standard set field operation available jsonfield limited operation listed however sql utility like case aggregation function work expected assuming lookup follows jsonfieldspecific format validation two approach could take validation first extend python jsonschema package builtin support validating foreign key expose refresolver class validate function resolving external reference one possibility would extend resolver validate reference pinging grout api pro easy integration existing jsonschema validation minimal change application code con extending thirdparty package risk introducing technical debt push core logic thirdparty package another approach would builtin ref keyword resolve reference described implementation section would require adding new endpoint grout api facilitating validation via jsonschema ref attribute pro make validation logic declarative explicit keep validation tied schema enforces separation concern abstract validation away pythonjsonschema implementation meaning jsonschema validator could validate con still unclear whether external ref reference supported jsoneditor degree indexing postgresql support indexing jsonb field gin index even three different degree flexibility jsonb index keyvalue index key value default flexible least performant keyvalue index expression index restrict index certain set predefined keyvalue pair medium flexible medium performant jsonbpathops index support containment operator much faster least flexible performant since currently containment operator grout anyway may able performant jsonbpathops gin index type pro seems like jsonb support kind indexing box con dont understand indexing well there chance reading doc optimistically hard get sense actual performance without running test performance issue derek suggested may case based research recommend moving forward recordtorecord foreign key grout leveraging ref keyword grout api endpoint support new field type facilitate work prioritize migrating djangos builtin jsonb type uptodate functionality next step include migrate djangos builtin jsonb type proofofconcept test confirm ref reference validate jsoneditor test succeeds implement grout api endpoint serving ref validation else extend refresolver jsonschema write custom resolver recordtorecord reference create index data field record recordschema data type update schema editor data model permit recordtorecord reference update schema editor expose recordtorecord reference review consequence new feature grout likely take day implement test properly update schema editor accommodate new feature