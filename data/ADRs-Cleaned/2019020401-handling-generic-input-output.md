handling generic inputoutput currently single view presenter render normal output case bound view interface general provider however handling different view might needed error message directly written stderr application regarding former allowing user choose output representation prefers get regarding latter decoupling presenter controller support segregation input output device cannot assume input device also able support output like segregation input output device assume generic application connected several different input output device mean input may come different input device example keyboard mouse output may different output device example stdout gui filesystem course requires drop assumption usual web application make input device output device web browser maybe webapplication server precise one objective modern architecture exactly allowing multiple different output device application also input device allow necessary controller oblivious specific output device example controller shouldnt know output going gui cli log audio speaker combination also important mention strict separation input output applicationlevel concern expects input come interface input boundary send output different interface output boundary important application doesnt care device providing input one receiving output however case input device also support kind output least display error input validation would weird input came device output sent different one user first device would expect see output well however kind architecture easily support also case input device output capability output sent somewhere else like game controller monitor controller presenter case interactor performs application logic may perform single presentation two reason many different kind presentation likely handled differently like main successful output error output presentation produced immediately like input validation result may produced asynchronously like command execution result reason interactor general define several different presenter interface instead one juggle various presenter according application logic unfolding describing ground presenter injected interactor theory possible achieve returning single response interactor instead letting interactor call presenter would actually work keep dependency inversion principle respected since interactor still know nothing detail presentation however stuff possible response case single response object instead cleanly separate various case controller parse response understand case call different presenter according adding much responsibility controller translate input data adapter format application format additionally controller would really unpacking information packaged application certain presenter called certain output situation controller cannot deviate logic either otherwise would taking presentation responsibility single response object could returning asynchronous output addition synchronous one controller also check part response treated asynchronous like attaching callback promise synchronous even interactor coroutine avoiding problem creating single response case controller would still check kind output return job interactor associating presenter kind output interactor already know information first place addition still handle asynchronous output reason although returning response interactor technically feasible certain scenario certainly best solution cannot chosen general approach rather regarded special case work best specific situation presenter view specific presenter implement output port represents specific output model characterized set view field data type conversion support word kind view model produce example screen view model might convert application response certain set field certain type intent displayed screen print view model might produce application response different set field different type specialized sent printer still view model representing certain output model rendered selected output device different way screen output model containing field belonging screen representation might still rendered html page txt file graph alternative represented different view mean specific presenter component example screen presenter component define screen view interface implemented multiple actual screen view instance like html screen view graph screen view etc one selected injected presenter rendering input definition borrow definition input rest standard according definition input made resource identifier example pathtomyresource uri web input parameter example somevaluesomeother resource representation example html pdf etc mean identifier pick couple controller action called perform requested case parameter passed action called representation related specific view render output generated case presenter additionally view selected presenter also chosen presenter might multiple view view belongs one presenter example let assume entitieslist control widget display specific representation list entity trigger update event entitieslist control widget specific input created identifier would reference controller action like entitiescontrollerupdate input parameter could perhaps name subset entity specific widget configured represent finally representation related specific widget sending input meaning resource different widget represented different view router interesting problem arises view chosen known input time related representation may lead think known controller however controller independent choice regarding output including representation solution introduce router component take input chooses combination controller action view according given input much like happens usual mvc web framework generalized kind adapter choice made router statically configured since depend user input input part quite easy router create right controller object call right action method passing right parameter output part trickier though since controller decoupled presenter doesnt return output object handled router rather forward execution presenter object way isnt control router router though select correct view container bind generic view interface way presenter built right view object automatically injected main output side output typical application many different kind output one talk back user provided input call main output would produced selected case side output would kind output produced application like logging monitoring etc directly related input usually expected received user produced input main output handled presenter side output handled message bus send nonspecified recipient application layer inside adapter one configured handler receive message output configured device case study consider verbose output console application first may seem case side output info log redirected main output console stdout whats really happening though side output produced way completely unrelated presenter view main output message sent containing side output adapter new handler configured listen message print output device main output way print output device keep two kind output completely independent handling error identify three broad category error application error input error system error error generated domain application service caught inside case passed back presenter response input error related wrong input input doesnt pas validation checked inside application interactors shouldnt handled controller controller way select specific output device forward error additionally better controller stick single responsibility translating data adapterspecific format request data applicationspecific format hand say case interactor taking role socalled controller traditional web application meaning validating input proper service produce output send output proper presenterview finally system error programming configuration error may happen adapterspecific code generally caught development may still happen production make application crash since error might happen outside application logic cannot handled application service like application input error still caught displayed output device notify user system error generated inside case dont concern case dont handled presenter way handle let piece code catching sending message widget responsible displaying error message without needing application logic error generated domain application service caught inside case passed back specific error presenter turn configured specific view situation user interface widget user interface whether graphical composed widget representing specific user interaction presentation data user interface meant frequently changed flexible possible support widget designed independent reusable replaceable possible key tool achieve event mechanism instead knowing existence specific widget calling specific method send event widget interested event respond action way easily replace widget add new one without disrupting existing functionality event generated domain application widget thus widget must allowed know existing event course generates event depends event belongs event represents completion domain task domain send whereas event represents change state graphical widget related application domain concern widget send sometimes however possible convenient interact widget event example happen sure specific widget actually called event system doesnt ensure widget respond event example want display error message doesnt make sense send event hoping message box widget catch rather want make sure message actually displayed way support case widget action must also callable directly widget regular object exposing set method registered event handler automatically called certain event caught called directly object way take account possible combination input output method without creating taxonomy widget input output input output etc really relevant user interface layer widget case model communication application layer port distinguishes controller presenter first responsible handling input second responsible handling output reason two must separated presenter injected case interactor since may call different kind presenter different situation also asynchronous fashion concern application layer adapter course case interactor know nothing widget adapter kind user interface cannot decide update widget rather interactor defines presenter interface representing kind output perform injected presenter actual widget selected however point view adapter layer user interface dont necessarily separate controller object presenter object example entity list widget might load controller action called directly load entity data application response event action delegate list entity case interactor query model fetch entity call given presenter display case presenter entity list widget fill method example fill list data point view interactor enough entity list adapter implement interface required interactor previous example case interactor likely injected also error presenter display possible error presenter perhaps implemented message box widget since list widget injected interactor wont required know existence message box widget fact list widget presenter thing decided application configuration provider additionally one situation method called going application layer cannot call fill method random data list widget contain domain entity gone application logic however since method public whether meant event handler nothing prevents object widget directly calling method passing somer random data left discipline implementer remember never call method directly handler proper application event risk however mitigated fact anyway following discipline letting controller known object really call directly virtue dependency injection example main application widget likely entity list widget call load show startup likely object reference regarding widget display data widget specific view representation data mean different widget even time representing data thus presenter mean presenter controller really part widget actually distinct object one widget example may multiple different widget dealing weather data one would display graph temperature time another display geographical map different color different temperature etc widget presenter convert entity data coming show temperature case simple value different view value differently graph widget receives signal temperature updated shared show temperature controller trigger case presenter injected presenter must able communicate multiple different view time actual view may change execution may hide widget example view interface presenter wont actual object interface messaging protocol interactor injected message bus calling interface would mean sending present message number actual view respond similar situation happens controller called multiple event handler method widget like load update entity list list entity controller action delegating case interactor application two way communicate widget direct one calling presenter injected however application also send message widget may respond however since calling presenter may also done sending message case support concurrent presenter there much difference two technical perspective real difference lay fact presentation method meant communicate adapter main output produced message meant communicate side event happened someone may want respond injecting presenter object important main output communicated object sending message keep intent communication clear message bus communicate presenter important message properly named make clear sending back main output example presentation situation common situation one create new entity view doesnt updated display updated entity data case create order given checkout view cart valid information request create new order new order created cart information notified successful order creation case error creating order given checkout view cart invalid information request create new order new order created notified error cart information let say gui adapter checkout window view order window view checkout window create order control method take data cart widget craft case request call case interactor already injected message box widget error presenter result presenter interactor called first validation request data immediately calling error presenter validation failed command model request creation new order otherwise command model executed asynchronously avoid blocking user interface create order update storage send message operation completed message caught interactor result presenter asynchronously notify order succcessfully created point user list order case open order window whose interactor read data denormalized storage present let see case create new entity view entity listed case create todo item given todo list view item form valid data request create new todo item new todo item created given information todo list updated show new todo item well case error creating todo item given todo list view item form invalid data request create new todo item view item created notified error item information single window todo list view following widget item form create new item button todo list error box loader widget user load window list item case performed meaning input sent load action todo list create request list item interactor injected list presenter query model get currently stored item denormalized database create response sent todo list presenter displayed widget user click create new item button controller read data form craft case request send create item interactor preinjected error presenter result presenter request data invalid error presenter sent response containing validation error interactor return otherwise interactor asynchronously call command model create new todo item call result presenter signal request could perhaps trigger loading animation start finally call result presenter signal request completed inside event handler command model completion event meanwhile todo list controller already register respond update action message sent command model creation item completed soon command model signal termination job todo list controller called triggering list item case update todo item list current value containing also new one form widget controller registered respond creation started message way request fails validation issue information present form field maintained allow user fix without retyping everything instead validation pass form clean field allow new item added next purely gui concern thats arent handled interactor must concerned explicitly mentioned case scenario common case one input data come source doesnt support output interested getting actuality described application layer cant adapter doesnt support output port provides one role adapter support case defined port thus think case doesnt produce outout case signal activates actuator sensor sends new signal actuator activated interactor receives input form signal produce output activating actuator secondary concern adn sensor doesnt support output since cant even receive data back adapter sloth machine view commandline application sloth machine process input device process addition perhaps filesystem output device particular want exit stdout stderr main output device important though highlight device also render output coming program executed virtual machine addition virtual machine also display side output example information message verbose configuration reason constantly keep mind output coming device displayed first thing clearly understand whats output case supposed provide case output comprises two element exit program execution error message might possibly happened important underline want error part output theyre still significant application including error response mean handled presenter view attached alternatively could chosen send error kind side output example event case whether display error would taken adapter application sending error response clearly stating want error displayed application rule thus application handle two output boundary exitstatuspresenter receiving exitstatusresponse errorpresenter receiving errorresponse concrete instance injected interactor adapter point view decide output model want support instance think console output meant application standard console application properly exit stdout stderr additionally think textual output meant data produced application available humanfriendly textual information output model define two distinct set presenter console output well consoleexitstatuspresenter consoleerrorpresenter textual output well textualexitstatuspresenter textualconsoleerrorpresenter consoleexitstatuspresenter convert exitstatus object response integer included default value needed sent console application exit abiding posix standard produce consoleexitstatusviewmodel textualexitstatuspresenter convert exitstatus object response string avoiding changing semantic produce textualexitstatusviewmodel consoleerrorpresenter textualerrorpresenter convert error object response string producing consoleerrorviewmodel textualerrorviewmodel output model rendered different widget view organized output configuration selected user example commandline argument integrated configuration run program virtual machine normal executables mean program exit returned application exit error message printed stderr exitstatuswidget return number exit console application stderrwidget print message stderr console integratedexitstatusview render consoleexitstatusviewmodel exitstatuswidget integratederrorview render consoleerrorviewmodel stderrwidget clean configuration run program virtual machine hiding error message keep console clean exit still returned application exit error message written file possible case actual program writing stuff stderr dont want mix error written application instead program exitstatuswidget return number exit console application outputfilewidget write message output file instead stdout stderr cleanexitstatusview render consoleexitstatusviewmodel exitstatuswidget could share single consoleexitstatusview previous case instead perhaps cleanerrorview render consoleerrorviewmodel outputfilewidget verbose configuration gather information centralized place immediately visible exit error message printed stdout stdoutwidget print message stdout console verboseexitstatusview render textualexitstatusviewmodel stdoutwidget verboseerrorview render textualerrorviewmodel stdoutwidget archived configuration gather information centralized place without clogging console notice stdout stderr may still contain actual program writing exit error message printed file outputfilewidget write message output file instead stdout stderr archivedexitstatusview render textualexitstatusviewmodel outputfilewidget archivederrorview render textualerrorviewmodel outputfilewidget here pseudocode would look like consoleexitstatuspresenter consoleexitstatuspresenterconsoleexitstatusview view presentexitstatusresponse response exitstatus normalizeexitstatusresponsegetexitstatus viewmodel new consoleexitstatusviewmodelexitstatus viewrenderviewmodel consoleerrorpresenter consoleerrorpresenterconsoleerrorview view presenterrorresponse response error responsegeterrorgetmessage viewmodel new consoleerrorviewmodelerror viewrenderviewmodel integratedexitstatusview consoleexitstatusview integratedexitstatusviewexitstatuswidget widget renderconsoleexitstatusviewmodel viewmodel widgetsetexitstatusviewmodelgetexitstatus integratederrorview consoleerrorview integratederrorviewstderrwidget widget renderconsoleerrorviewmodel viewmodel widgetseterrorviewmodelgeterror consoleui consoleuicontainer container thisconsole containermakeconsole thisexitstatus new exitstatuswidget thisstderr new stderrwidget containerbindexitstatuswidget exitstatus containerbindstderrwidget stderr getexitstatus exitstatuswidget return exitstatus getstderr stderrwidget return stderr render consolewriteerrorstderrgeterror consoleexitexitstatusgetexitstatus consoleui new consoleuicontainer send input render view uirender encapsulate related code single class bind specific instance widget class view built container get right widget specific case particularly interesting deal problem call consoleexit application terminated code might run wont able avoid instead directly call console method inside view let view populate widget render last thing allowed view directly call console order various presenter called inside interactor would important user interface concern interactor called exit presenter error one generic message one since error exit produced specific case application would terminated interactor even finished execution course unacceptable graphical interactive instead couldve displayed exit widget soon produced wouldnt caused application terminate proposed consequence everything regarding input output adapter following generic reusable standard different output representation output device supported input actually completely decoupled output