code structure proposed code rapidly grows common structure approach keep code tidy coherent various aspect initial concern data access separation issue initially talked could separated term orm objectrelational mapping dal data access layer however discussion also soon covered structure code general structure ease development best practise rejected considered following pubsweet way define base class model extend entity rejected another self made orm validation dont want orms waterline sequelize bookshelf general purpose orms rejected based experience time spent going learning curve sifting doc thing wrong greater simply rolling query builder knexjs entirely ruled deemed compatible good code structure would allow database access encapsulated way would allow query builder necessary summary serverside code structured server folder follows entity folder contain subfolders relating named entity system see data model specification entitiesentity example show mansuscript example entity folder contain common set file describe entity behaviour particular purpose explained indexjs main business logic manuscript could contain getauthor typedefsjs contains graphql type pertinent entity resolversjs contains graphql interface specified term query mutation entity general map onto exposed function indexjs example manuscript may contain query allmanuscripts mutation createmanuscript dataaccessjs contains function saving loading database reference database sql written remain private file manuscriptstatemachine anticipated orchestration entites take place created separate folder expand implement state transition currently defined manuscript example server entity manuscript typedefsjs resolversjs dataaccessjs indexjs entity typedefsjs resolversjs dataaccessjs indexjs manuscriptstatemachine indexjs consequence coordination team order implement structure outcome result developer instinctively knowing find particular piece code codebase scalable structure