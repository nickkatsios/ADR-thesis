write maintain custom tool generating foreignlanguage binding rust code deciders rfkelly linacambridge eoger thomcc thereabouts problem statement application service team successfully built several reuseable component sync storagerelated browser functionality following weve dubbed rustcomponents approach write bulk code rust crosscompile different target platform expose ccompatible ffi layer write small amount ffi binding code expose functionality several different target language swift kotlin ffi layer foreignlanguage binding code currently written hand tedious potentially errorprone process given expect build additional component style future expect team mozilla increase efficiency reliability work autogenerating code driver reduce time taken launch new rust component improve maintainability existing rust component reduce possibility error handwritten foreign language binding code continue shipping component regular cadence considered continue writing ffi foreignlanguage part rust component hand move webassembly wasmbindgen swig djinni another existing bindingsgenerator tool write maintain custom tool automates current best practice outcome chosen write maintain custom tool automates current best practice balance provides best tradeoff potential upside ability limit downside approach succeeds expect realize significant improvement maintenance cost rustcomponents code reducing boilerplate human error building involve least upfront investment start show result identify existing tool closeenough fit first version tool dont perfect even particularly good better valueproposition writing generated code hand accept risk writing tool may turn much complex expected mitigate aggressively timeboxing initial prototype developing parallel real shipping consumer real deadline regularly asking hard question whether approach working pro con continue writing ffi foreignlanguage part rust component hand could decide handwriting pub extern function wrapper bit custom swift kotlin etc isnt bad cost unlikely offset investment automated tooling good dedicate people building new component functionality rather working tooling good component whatever bespoke ffi detail work best usecase rather taking onesizefitsall approach good dont learn new tool maintain existing one bad time commitment maintaining binding grow build component bad easy make mistake writing binding hand proven hard avoid making similar mistake multiple time bad handwriting binding lowengagement work risk feeling like chore plenty chore already ultimately feel like potential longterm cost saving automation significant glad continue plan move webassembly wasmbindgen approach weve taken rust component many similarity webassembly particularly webassembly interface type proposal could try wasmbindgen automatically generating binding rust code rely portable nature webassembly run multiple platform good tooling around wasmbindgen seems quite sophisticated mature good toolchain maintained folk fulltime job good mesh well technical project strategically important mozilla bad wasmbindgen currently support javascript target language bad able identify mature solution running webassembly android important target platform bad significant departure weve written component past add timeline risk shipping solution ultimately imagine world webassembly ecosystem sufficiently advanced make compelling world seems far enough away doesnt make sense pursue right swig djinni another existing bindingsgenerator tool writing code system language generating binding highlevel language new idea among existing tool general space swig djinni could adopt one existing tool instead inventing thing good tool already exist mature saving development maintenance effort good would realize goal avoiding handwritten boilerplate swig bad doesnt appear support generating kotlin swift binding key language usecase bad designed rather rust meaning unknown amount exploratory work required integrate approach ship anything djinni good target several key languagesplatforms bad designed implementation language rather rust meaning unknown amount exploratory work required integrate approach ship anything bad explicitly put maintenance mode author ultimately could probably make one tool work could find one close enough fit avoid unknown amount exploratory integration work problem willing put shipping incremental progress long enough confident making integration work write maintain custom tool automates current best practice take pattern weve established writing ffi layer foreign language binding hand encapsulate custom tool automatically generate similar code good would realize goal avoiding handwritten boilerplate good first version tool good enough limited meaning defer complexity weve proven idea good designed upfront meet unusual integrating firefox desktop code built part larger shared library etc good able determine whether approach working within fairly strict timebox fall back handwritten binding required bad take development maintenance burden tool reducing time spent product feature bad risk isolating knowledge tool work small number people bad might spend time developing maintaining tool wed ever hope save generated code bad binding limited onesizefitsall lowestcommondenominator feature set bad generated code risk much harder debug handwritten binding especially tool heavy development ultimately risk approach seem sufficiently wellunderstood wellbounded try approach fall back handwritten binding doesnt seem working link engineering program review sync storage component earlier technical review rust component approach including discussion painpoints around manually writing ffi binding hidden cost sharing code android kind technical postmortem dropbox exploring abandoned codesharing approach similarly shaped one pursuing rust component many risk highlighted post also apply chosen solution