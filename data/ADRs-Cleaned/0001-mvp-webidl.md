build mvp based webidl manual workflow deciders rfkelly linacambridge eoger jhugman tarikeshaq thereabouts problem statement deciding build tool main risk identified wed spend much time ultimately unworkable unmaintainable idea early design make mitigate risk thing existential risk success project must included first version thing safely defer future work word build mvp tool minimal viable driver strictly timebox effort prove approach establish whether effectively maintain kind tool team support initial development new rust component externallyimposed nearterm deadline considered adr encompasses several several related design question feed together overall approach building mvp tool developer specify api component external interface definition file based webidl external interface definition file based custom language infer api directly rust code annotation macro developer integrate tool workflow buildscripts macro deeply integrate rust crate build system provide tool developer run hand prioritize work capability offered tool broad implementing many data type api capability even theyre slow incomplete deep implementing core data type api capability make sure theyre done well outcome chosen external interface definition file based webidl provide tool developer run hand broad implementing many data type api capability even theyre slow incomplete set chosen make explicit tradeoff preferring get something running quickly accepting certain amount jank developer experience dont build perfect tool right away build something thats better work hand like result polish mvp tool read api definition external webidl file bit weird inconvenient consumer webidl precise fit avoids bikeshedding perfect apidefinition experience first phase mvp developer experience involve cargo installing tool onto system manually running integrating build process risk mildly inconvenient consumer give lot flexibility learn better workflow might look like mvp tool may support feature turn strictly necessary interest ensuring multiple team member involved development early stage tradeoff mvp generated code allowed contain inefficiency limitation handwritten code might premise first consumer performancesensitive lot scope improving implementation detail time likely revisit every single one choice mvp tool prof successful attempt build theyre easy revisit pro con external interface definition file based webidl require developer specify component api external definition file syntax webidl provide something thats familiar existing spec good webidl exists feature first consumer good weedle crate provides readymade parser webidl good webidl base level familiarity around mozilla bad developer duplicate api rust code idl bad webidl designed different usecase likely awkward fit bad weedle doesnt generate particularly helpful error message seems designed parsing knowngood webidl definition rather helping develop new one ultimately seems like lowestcost way get started deferring importantbutnotexistentiallyrisky work making idl experience fit really well rust code external interface definition file based custom language require developer specify component api external definition file custom variant idl syntax good syntax custom designed fit well developer mental model generated code good already several different idl variant mozilla webidl xpidl chance building something feel familiar high bad developer duplicate api rust code idl bad make document whole syntax bad rust parsing crate nom seem generate particularly helpful error message default adding friction developer ultimately custom syntax would probably feel better consumer perspective webidl cost involved worth tradeoff mvp beyond mvp expect direct annotation rust code provide better developer experience leaving unnecessary middleground infer api directly rust code annotation macro allow developer sprinkle macro annotation directly rust code order declare component api similar approach taken wasmbindgen good rust code single source truth api definition good developer familiar approach tool bad team doesnt much experience working macro scale bad poke around wasmbindgen code seem pretty scary thing order make macro work various edgecases ultimately feel like good approach longerterm risk much timesink mvp buildscripts macro deeply integrate rust crate build system encourage consumer structure rust component crate take buildtime dependency tool magic thing existence part cargo build good slick developer experience make work bad assumes many detail consuming component built deployed dont know exactly work yet bad could hard integrate gradlebased build system android package bad build script arent supposed create file outside rust target directory doesnt really make sense generate foreign language binding directory ultimately approach provide enough flexibility initial consumer risking declaring bad fit based nonessential detail tool provide tool developer run hand provide consumer uniffibindgen commandline tool manually run component code order generate foreign language binding good give consumer lot flexibility generate different bit code bad consumer install external tool ultimately approach win based flexibility may also provide light wrapper around tool integrates cargo build convenience broad implementing many data type api capability even theyre slow incomplete focus initial effort fleshing broad suite data type api capability spending time focused performance edgecases generated code good consumer iterate api chance limited tool good make opportunity team member get involved implementing feature tool helping understand like maintain time bad suboptimal performance may offputting consumer bad might accidentally entrench design limit ability improve generated code future ultimately win based known first target consumer favour iteration performance team want ensure multiple developer familiar tool codebase get ground deep implementing core data type api capability make sure theyre done well focus initial effort identifying data type api capability required first target consumer implementing really well spending time feature unlikely required consumer good show resulting generated code best possible light bad might identify correct set feature bad harder parallelize kind work among multiple team member ultimately first target consumer make performance argument fairly weak selected link webidl specification reference