handling database corruption problem statement user corrupt sqlite database make related component unusable best way deal corrupt database simply delete database start fresh however want persistent error transient error like programming logic error disk full etc adr deal related question identify corrupted database identify corrupted database driver deleting valid user data avoided almost cost keeping corrupted database around almost bad currently prevents component working dont currently good way distinguish persistent transient error improved reviewing telemetry sentry data considered identify corrupted database assume error opening database corrupt database check error opening database compare known corruption error type check error database operation compare known corruption error type identify corrupted database delete database file recreate database move database file recreate database component fail outcome check error opening database compare known corruption error type delete database file recreate database follows choice since conservative identifying error delete database file relative confidence check error database operation compare known corruption error type also seems like reasonable solution may pursue future decided wait checking error opening time simpler solution implement fix issue many case plan implement first monitor sentrytelemetry decide next pro con assume error opening database corrupt database good sentry data indicates many error happen opening time good migration especially likely trigger corruption error good natural time delete database consumer code hasnt run query yet doesnt open connection bad delete valid user data several situation relatively common migration logic error oom error disk full check error opening database compare known corruption error type decided good eliminate possibility deleting valid user data good sentry data indicates many error happen opening time good natural time delete database consumer code hasnt run query yet doesnt open connection bad dont currently good list corruption error check error database operation compare known corruption error type good sentry data indicates many error happen outside opening time good eliminate possibility deleting valid user data bad consumer code probably doesnt expect database deleted recreated middle query however extreme case normal database behavior example given row deleted sync bad dont currently good list corruption error delete database file recreate database decided good would allow user corrupted database affected component bad misidentification lead data loss move database file recreate database would similar instead deleting file would move backup location started could look backup file try import lost data good misidentify corrupt database possibility recovering data good allows way user delete data theory consumer code executed wipe database could also delete backup data bad difficult write recovery function merged deleted data new data function would fairly hard test would easy introduce new logic error bad add significant complexity database opening code bad user experience would strange user would open app discover data gone sometime later discover data back return failure code good leaf chance user data deleted good simplest implement bad component usable database corrupt bad user data potentially exposed corrupted database file dont provide way delete