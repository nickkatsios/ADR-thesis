refactoring replacement legacy progress pun legacy code prestashop sadly lot recent code well rely heavily classsingleton legacy although convenient time many flaw completely mutable lot bug prestashop related value changed unexpected code way built well known mostly fragmented many different place current code lack validation exception feedback clear way knowing badly setup resulting hoursdays debugging understand root cause sometimes equivalent principle symfony forced rely legacy code even modern implementation legacycontext service merely accessor contextgetcontext static method principle contextualized data bad thing even required many case however build code independent prioritize stateless code rely parameter instead global state contextualized still real especially browser session purpose adr define new architecture intends replacing legacy modern code aim removingreducing current drawback ultimately new architecture completely replace old one least responsible building legacy one backward compatibility moder architecture split first new architecture split current contains everything split multiple sub way inject relevant part service sub split also mean built independently thus optimizing build process allowing process one would needed actually built identified main sub list may increase future shop language currency country employee api client new one building sub built upon three main component subcontext classservice gettersfunction allowing access data data must immutable ensure remains unchanged processrequest class basically immutable dto include method needed employeecontexthasauthorization subcontextbuilder provides getterssetters specify parameter required build subcontext class build method return subcontext instance builder also implement prestashopprestashopcorecontextlegacycontextbuilderinterface interface requires implementing buildlegacycontext initialize legacy backward compatibility course data build legacy must synced one modern service builder charge fetching data advance building operation however capable detecting required argument build like entity responsibility left listener symfony listener per sub responsible getting data required inject inside subcontextbuilder nothing responsible triggering actual build data initialized listener must kept minimum like locale code entity advanced fetching left builder listener also responsible defining default fallback needed multiple listener sub allow adapting initialization depending case environment one back office one oauth api one cli command one frontoffice one day based three element symfony favor subcontext service easily injectable place subcontextbuilder factory allows build service subcontext service must lazy service several reason improves performance even cost minimum wont built unless actually built late possible first time actually way leaf time process overridechange value set initial listener thus allowing flexibility instant building solve issue far service depending built request even data available resulting error code even run dto subcontext dto service immutable object field must readonly php readonly kept private field accessible via getter method required always accessible like shopcontext countrycontext mandatory always populated even requires fallback value direct dtos meaning extra layer represent subcontext data directly optional empty possible initialize sometime like employeecontext cannot created user logged core via oauth api case apiclientcontext equivalent extra dto data stored sub dto field optionalnullable subcontext service example country required example architecture divided three element country currencycontext currencycontextbuilder currencycontextlistener youll notice currencycontext class force setting data therefore allows accessing field straight away build method trigger exception called required data since required must fail early workfow indicate initialization failed listener run early request kernel event even mandatory shouldnt trigger exception case cannot find data could another listener example employee optional example optional sub employee employeecontext employee sub dto employeecontextbuilder employeecontextlistener youll notice nullable dto field allowing check code employee currently available sub dto follows rule mandatory immutable dto field accessible first level builder build method called even employee set trigger exception simply skip build phase dependency replacement new sub available time new code usage legacycontext allowed anymore usage contextgetcontext allowed anymore turn sub missing data accessible via legacy one sub must enriched new one may needed part sub needed service like language iso code still inject whole sub small needed part also start refacto current code rely legacycontext especially well able fix many improper dependency injection like yaml myservice serviceprestashopadapterlegacycontextgetcontextshopid replaced course autowiring possible even encouraged internal code also adapted mybetterservice prestashopprestashopcorecontextshopcontext lot code adapted better change actually impact class constructor adn internal code public behavior andor method line backward compatibility policy class onlymostly service constructor modified course change done major version ideally breaking change legacy building new sub bring stability building architecture also naturally centralize building process offer control highly unstable key component could also benefit place still relying legacy subcontextbuilder implement alternate interface legacycontextbuilderinterface single buildlegacycontext method since builder already able build new sub based parameter provided also correctly setfill legacy dedicated listener charge looping builder implement legacycontextbuilderinterface build legacy automatically long required data provided thanks new legacy building well able remove legacy code piece piece modern code symfony page since dont rely anymore legacy would still correctly built though core code still relies refactored rely new sub also mainly keep backward compatibility especially module backward compatibility layer implemented sub consider removingcleaning legacy code built legacy first place may split internal config front office back office many thing example done included file like configincphp new handled symfony theyre available yet