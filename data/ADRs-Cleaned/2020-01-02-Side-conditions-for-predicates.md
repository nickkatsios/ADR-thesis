side condition predicate background let say sgn function defined usual way sgnx requires sgnx requires sgnx requires let also say trying simplify toplevel configuration sgnx obvious evaluates uniquely solve passing toplevel condition side condition function simplifier prune unfeasible branch problem main question side condition simplifying predicate way make sense predicate either toplevel one could generated something like unification function application simplification one interesting issue simplify predicate sgnx toplevel predicate short term partly implemented added document long term combined version toplevel predicate except simplifying top condition safely toplevel predicate side condition simplifying top condition safely top condition previous rewrite step first step would allow simplify many predicate would fail sgnx condition side condition could try condition sidecondition intuition would simplifying sgnx part sgnx smt prune branch except one simplifying sgnx smt may prune branch except one assuming definition sgn main problem side condition cannot prune unneeded predicate seems priority right normally toplevel predicate evaluate sgnx since implies safely drop evaluation result keep part however try evaluating sgnx side condition say sgnx top predicate would get since sgnx implies well drop obviously wrong combining two could twostep simplification implemented time document written let say toplevel condition mentioned evaluating current toplevel condition either top level condition previous rewrite step let say subterm predicate yield filter resulting disjunction evaluating condition see example usual case functionlike pattern one defined note always case since evaluating sgnx part ceilsgnx toplevel condition still branch assuming one defined sometimes simplify condition predicate implies simply drop additionally predicate written usually simplify follows see example simplify described last step check whether implies let result simplify last step check whether implies let result general simplify last step check whether implies let result note simplifying cant take except side predicate last step since dont want simplify sgnx see example example let say smt solver understands sgn simplify sgnx absx sgnx absx first evaluate sgnx prune branch see absx implies simplify sgnx simplify sgnx naively would continue evaluate absx sgnx side condition would evaluate would see sgnx implies drop simplifying absx absx mean simplified entire predicate however simplified version sgnx get right answer evaluate absx pruning branch described example evaluate absx simplify entire predicate example say want evaluate sgnx let also say dont definition sgn suitable smt solver three branch sgnx sgnx sgnx obviously want first branch default way selecting evaluate sgnx smt solver able reject safe evaluate sgnx sgnx good enough