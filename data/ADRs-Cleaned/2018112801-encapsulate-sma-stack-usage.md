encapsulate sma stack usage real world assembly programming expose stack pointer base pointer allowing assembly code directly mess example changing stack pointer regardless push pop instruction despite allowing wild optimization really error prone extensively make program obscure reason dont want support thing sma architecture prevent code messing stack well avoid adding public stack pointer base pointer register rather two concept still implementation stack object client wont able directly since interface allowed usual push pop take care properly updating stack pointer base pointer since pointer directly usable code add way abstract concept stack frame role pushframe popframe method first one take return address take care pushing stack right moment second one return previously stored return address another problem encapsulating frame handling passing procedure argument stack regular assembly one first push argument push return address base pointer jump procedure inside procedure get passed argument necessary first temporarily pop base pointer return address pop argument push back return address base pointer since dont want write boilerplate every time call procedure well provide alternative call instruction supporting argument passing instruction take size pushed argument byte automatically move pushed argument return address base pointer pushed procedure code immediately find argument top stack without boilerplate consequence procedure consistent interface always stack never register although theyre still visible thus usable course argument found stack return value returned stack course still possible mess stack example someone pop many thing right procedure call could end popping return address base pointer stack probably smell design criterion simplifying usage stack implemented partially hand main design goal project close implementation real processor make sense solution intended compromise