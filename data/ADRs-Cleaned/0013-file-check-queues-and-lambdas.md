queue lambda run backend file check user uploads folder tdr consignment tdr run set check file mvp release check antivirus scan sha checksum compared checksum calculated user browser file format useful metadata preservation system ingests file transferred tdr highlight file national archive accept like passwordprotected file file user might uploaded mistake like executable file file uploaded bucket workflow run scan uploaded file user may upload several thousand file size could range byte gigabyte warn user file check may take time think user experience better user review file check result soon possible uploading file ideally take minute rather hour may add file check future additional checksum algorithm antivirus software architecture flexible enough add remove check later aws lambda run file check sqs coordinate step see architecture diagram file check workflow fit overall architecture step workflow user uploads file tdr frontend trigger upload event aws sends topic message contains object key includes tdr file uuid message passed first sqs queue lambda connected sqs queue take message extract file downloads file efs temporary file store lambda finished add message three sqs queue one backend check sqs message trigger respective backend check lambda checksum file format antivirus lambda sends message api update sqs queue containing result check final lambda pick message sends result consignment api stored database check single short process make suitable serverless workflow user uploads thousand file process parallel let sqs lambda work backlog without scale instance also trying serverless service tdr possible remove patch server testing far havent reached maximum lambda execution time minute hit limit could consider moving slow step task doesnt execution time limit slower start would way trigger task sqs would otherwise fit workflow way lambda moment considered step function instead sqs coordinate task decided tried alpha prototype found failed hit lambda concurrent usage limit currently function hit limit user uploads consignment thousand small file dont problem sqs message wait queue aws let start another lambda initial step downloading file lambda necessary antivirus file format task access file disk file downloaded efs rather lambda disk storage efs network file store access slower local file lambda disk storage limit lambda currently efs let run check much larger file file check lambda read file efs store file downloaded save transfer storage cost reduces complexity individual file check separate lambda sending result api introduces another sqs queue lambda several advantage making file check send result api separately api update step fails retry api update dont rerun whole potentially slow file check choose throttle api update lambda api cannot handle load receiving result thousand file without reducing throughput file check reduces number api client make easier roll api client library update file check apply business logic report raw result check example file format step find zip file report result api record failure warning antivirus check perform action addition reporting result copy file clean quarantine bucket depending whether file passed failed virus scan file clean bucket later tdr workflow exporting data file quarantine bucket inspected tdr admins want find file failed scan queue configured retry message three time attempt fail message sent dead letter queue able inspect message queue monitor size spot processing problem current limitation load testing time writing havent done systematic load testing uploading large file consignment large number file may modify architecture deal performance issue find slow file format identification droid extract file format information droid designed run folder file rather individual file lambda function normally make file format step slower antivirus checksum step becomes problem user wait hour result could consider extracting core logic droid suitable running lambda could also consider batching file would require change message passed step potential concurrency issue result check identical check repeated unless file replaced check function updated example update antivirus file format signature mvp user way replace file tdr support future user replace passwordprotected file unencrypted one think store metadata version file sometimes update file check currently way user admin rerun file check seems quite likely well build functionality order rerun failed file check low volume careful scrutiny transfer expected mvp dont think concurrency problem old data overwrites new data current architecture parallel file check make possible revisit find way fix one store check version number alongside metadata optimistic locking prevent metadata older version number overwriting newer metadata another add pessimistic lock prevent new check given file starting old check finished significant change architecture could slow processing another possible concurrency issue come temporary file store currently file saved folder name based consignment mean message added queue file file downloader try download file location twice could lead conflict file check running incomplete file could fix saving file unique folder uuid lambda task passing file download task file check way mark check complete currently infer file check complete antivirus file format checksum metadata saved database every file consignment long term plan also save kind consignment process determine state without inspect potentially thousand database row implement well decide update result file check arrive independently there obvious point theyre finished without looking rest result later refinement discovered performance issue large number file uploaded didnt change architecture described decide change configuration value see adr detail