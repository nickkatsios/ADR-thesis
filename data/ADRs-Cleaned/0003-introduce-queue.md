introduce unbundled queue based architecture current design based around single bob node written clojure responsible exposing rest api implementing step execution logic via local docker daemon implementing registration creation update resource controlling lifecycle pipeline node expected replicated based scaling would simply load balanced behind simple application load balancer like nginx brings forth following issue backpressure support node overwhelmed way queue build result dropping job error shared state exactly pipeline really running request like stopping pausing exactly delivered concerned node clean way node implemented clojurejvm docker implement step opinionated view platform either unsupportedresource constrained jvm cannot addressed simple manner build special privileged arent simple implement central place error ability programorchestrate error case machine learning scale bottle neck runner scale unit whole bob quite suboptimal simple implement declarative style cicd without queueing backpressure based fact following decided break core service api server implementing specfirst api entity implementing creation registration entity like pipeline resource provider artifact store runner implementing step execution logic based docker streaming log pushing error queue rabbitmq central queue rendezvous point service following reason quite ubiquitous well battle tested protocol client ecosystem quite diverse mature quite resilient independently scalable fanout capability queue broadcast stop pause request connected runner consequence queue brings forth much needed backpressure support thats crucial cicd tooling also enables independent granular horizontal scaling component apart since runner unbundled diverse runner specialized ability plugged