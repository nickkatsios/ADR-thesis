push refactor issue motivating influence constrains acceleration team developing version push team saw opportunity structure code make easier understand maintain general push command logic complex codebase command still considered experimental seemed like right time place invest energy refactoring cli code push split roughly two method conceptualize actualize conceptualize responsible taking user input flag manifest property etc generating push plan app pushed struct containing various piece information needed createpushupdate app actualize responsible taking push plan based plan taking necessary action complete push process refactor preserve spirit division prevents two method growing large unmaintainable goal refactor make easier add feature push new flag new flag new manifest property make easier unit test component push workflow mean meant splitting command several smaller function tested individually composed sequence based given user input change proposing agreed implement conceptualize actualize part push process split refactored manner inspired hexagonal architecture hexagonal architecture purpose hexagonal architecture mean following one place code responsible calling given sequence function order output one function passed input next function function signature central place function called agnostic function new featuresbrancheslogic added one function new function added encapsulate generally shouldnt touch place function called splitting conceptualize previously called conceptualize look roughly like note still iterating code may evolve time longer look exactly like still code illustrates idea going var pushplans pushplan manifestapplication range geteligibleapplicationsparser appnamearg plan pushplan orgguid orgguid spaceguid spaceguid updateplan range actorpreparepushplansequence var err error plan err updateplanplan override manifestapplication err nil return nil err pushplans appendpushplans plan return pushplans nil central place prepare push plan function called loop actorpreparepushplansequence array function call one push plan opportunity return modified push plan get passed next function case function also called override manifestapplication represent user input form flag manifest property respectively let function inspect user input modify push plan accordingly loop completes original push plan flowed function sequence modified include information based given flagsmanifest let look actorpreparepushplansequence defined actorpreparepushplansequence updatepushplanfunc setupapplicationforpushplan setupdockerimagecredentialsforpushplan setupbitspathforpushplan setupdropletpathforpushplan actorsetupallresourcesforpushplan setupdeploymentstrategyforpushplan setupnostartforpushplan setupnowaitforpushplan setupskiproutecreationforpushplan setupscalewebprocessforpushplan setupupdatewebprocessforpushplan simple array bunch function conform correct interface type updatepushplanfunc example one func setupscalewebprocessforpushplanpushplan pushplan override flagoverrides manifestapp manifestparserapplication pushplan error overridesmemoryisset overridesdiskisset overridesinstancesisset pushplanscalewebprocessneedsupdate true pushplanscalewebprocess vactionprocess type constantprocesstypeweb diskinmb overridesdisk instance overridesinstances memoryinmb overridesmemory return pushplan nil simple function populates field push plan based flag override return enhanced push plan making easy test function run updated push plan actualize step doesnt know flag manifest property anymore receive push plan user input resolved combined push plan object splitting actualize still time writing function called actualize look like changeappfunc range actorchangeapplicationsequenceplan plan warning err changeappfuncplan eventstream progressbar warningsstream warning err nil errorstream err return planstream plan quite similar loop actorpreparepushplansequence loop actorchangeapplicationsequenceplan return array function call one push plan one return push plan get passed next function note rest code stream report progress error warning focus adr may end changing well biggest difference conceptualize instead static list function like actorpreparepushplansequence actorchangeapplicationsequence function take push plan return array changeapplicationfuncs allows dynamically build sequence action run based push plan rather run sequence every time let look work actorchangeapplicationsequence funcplan pushplan changeapplicationfunc var sequence changeapplicationfunc sequence appendsequence actorgetupdatesequenceplan sequence appendsequence actorgetprepareapplicationsourcesequenceplan sequence appendsequence actorgetruntimesequenceplan return sequence function responsible building sequence based given plan delegate three helper build subsequence action here one func shouldcreatebitspackageplan pushplan bool return plandropletpath plandockerimagecredentialsneedsupdate func actor actor getprepareapplicationsourcesequenceplan pushplan changeapplicationfunc var preparesourcesequence changeapplicationfunc switch case shouldcreatebitspackageplan preparesourcesequence appendpreparesourcesequence actorcreatebitspackageforapplication case shouldcreatedockerpackageplan preparesourcesequence appendpreparesourcesequence actorcreatedockerpackageforapplication case shouldcreatedropletplan preparesourcesequence appendpreparesourcesequence actorcreatedropletforapplication return preparesourcesequence case want include one three function final sequence determined based property push plan since function small straightforward easy unit test composed together different sequence build different push workflow based different flagsmanifests refactor really start pay consequence becomes easier difficult risk introduced change mitigated becomes easier figuring write code add new flag becomes easier consider recent commit added nowait flag push command bulk change needed add new branch workflow new threeline method implementing updatepushplanfunc interface plus unit test oneline change actor add new method changeapplicationsequence simple change pas new push plan property method change commit highlight part relevant adr becomes harder slightly harder grasp piece fit together first glance array function detailed immediately clear called since abstracted away different part codebase believe spending time understanding new structure thing developer appreciate straightforward make change