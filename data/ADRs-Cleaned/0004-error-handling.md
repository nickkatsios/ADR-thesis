error handling mercury stack rfc since application expected operate error resistant way important lay detect manage unexpected situation prinicples described article partially rustspecific applies design testing activity space principle described followed every contributor existing code refactored asap guideline design error resilience application operating unstable possibly hostile environment plan error condition happen quite often following guideline taken account design communication protocol detect hostilebadly behaving peer early disconnect immediately case connection issue make reconnection polite process dont try reconnect tight loop consider apply exponential reconnection strategy eventually wrap one component httpsenwikipediaorgwikiexponentialbackoff network protocol relaxed accept strict send would enable errorfree operation across multiple version different component impose strict limit buffering across level protocol stack prevent erroneoushostile peer take application via overflow every operation take account detect report error related specific operation try scale protocol well minimizing resource assigned requestsconnections possible apply backpressure minimize queueing protocol design implementation semiformally defined format beyond source code fsm httpsenwikipediaorgwikicommunicatingfinitestatemachine dont make assumption unreliable channel plan implementing timeouts unreliable operation avoid deadlock implement error handling rust specific standard error handling primitive error handling stderror stdresult case low level code wrap error code higher level construct asap best case naked error code even show even private interface panic always signal critical error attention panic production always mean either deployment broken bug hand implies panic recorded properly call stack log eventual error report user also mean naked unwrap call almost always bad thing never throw away error even affecting normal operation still worth least logging implies compiler warning eventually treated error fixed layered architecture important preserve lowlevel error code attaching higher level error error travelling stack purpose consider usage crate help implement structured error handling one example httpsgithubcomrustlangnurseryerrorchain credit wigy development test implement negative test also careful checking error condition recoverable code return normal operation error try create stress test error protocol deficiences appear heavy load even important code aimed relatively resource constrained titania box postmortem analysis requires much information available possible mean log backtrace persisted study purpose might want consider httpsdocsrshumanpanichumanpanic credit bartmoss concrete error handling example error chain layered design lower layer errorchain error lowlevelconnectionmsg string descriptionlow level connection failure displaylow level connection failure msg pub dosomethinglowlevel result errstdioerrornewstdioerrorkindconnectionaborted failed connect serverchainerr errorkindlowlevelconnectionconnecttostring higher layer errorchain error highlevelconnectionmsg string descriptionhigh level connection failure displayhigh level connection failure msg pub dosomethinghighlevel result lowerlayerdosomethinglowlevelchainerr errorkindhighlevelconnectionpeer connection failedtostring application layer recursionlimit macrouse extern crate errorchain mod higherlayer mod lowerlayer main let errref higherlayerdosomethinghighlevel printlnerror eiterskip printlncaused backtrace always generated try run example rustbacktrace let somebacktrace ebacktrace printlnbacktrace backtrace stdprocessexit outcome hcmbperrorhandling andrei cargo run finished dev unoptimized debuginfo target running targetdebugerrorhandling error high level connection failure peer connection failed caused low level connection failure low level connection failed somehow caused failed connect server