adr graphql error response structure trello card deadline author pylipp proposed updated problem statement boxtribute web app graphql define interface frontend backend reason graphql specific framework found elsewhere according request frontend data error transferred via graphql interface data error response field especially case error important provide clear information error occurred time development well runtime app currently backend follows strategy similar one apollo server custom exception extension attribute containing least alphabetical error code description however arbitrarily extending possible raised case error processing response frontend act depending error code defining result type description text condition necessary approach convenient default graphql error response structure mentioned ariadne community brittle error code string might changed missspelled backends exception definition description text past showed complex bulk operation like mutation receive box shipment handle various error dont define dedicated structure indicate instead error might ignored leading confusing state frontend bug driver clarity app reliability impact development considered keep current state string code defined backend distinguish error union type defined graphql schema indicate error result custom result type encapsulating data error set mutually exclusive detail approach taken recommend read blog post also highlight idea operation possible result considered directly woven graphql schema let look issue approach putting error error response field like boxtribute backend error treated matter kind hard know error came esp complex operation hard client know error care proposed approach think possible result operation model union type fetching user username might turn exist blocked unavailable example schema query graphql type user name string type doesnotexist type isblocked message string blockedbyuser user type unavailableincountry countrycode int message string union userresult user isblocked unavailableincountry doesnotexist query userusername string userresult example query graphql userusername ash typename user name doesnotexist isblocked message blockedbyuser name unavailableincountry countrycode message success response graphql data userresult typename user bbee name ash ketchum error response graphql data userresult typename isblocked message user blocked ash blockedbyuser username brock advantage result customizable entity user different result type example tweet know error came error come query attached entity actually encoded schema client decides error care error ignore client query query different result decides whats important detail approach taken ariadne documentation adaption discussion discouraged main error field convey error since message present key technical nature shouldnt displayed end user instead one define custom result type including field data case success error case failure set mutually exclusive graphql type query userid userresult type mutation createuserinput createuserinput userresult type userresult user user nonexisting user invalid input user name user organisation missing permission arguably could custom error type like error string depending success failure mutation resolver may return either error message displayed user newly created user api resulthandling logic may interpret response based content two key falling back main error key make sure wasnt error query syntax connection application likewise query resolvers may return none instead requested object client developer may interpret signal api display requested item doesnt exist message user place requested resource allows return multiple error back client instead single error actual resolver implementation able collect error success result like python def resolvecreateuser input error authorize errorsappendnot authorized validationerrors validateinput validationerrors errorsextendvalidationerrors error return user none error error user dbcreateuserinput return user user error none apply new addition graphql schema existing operation updated refactor would changed anyways clarity possible error operation immediately obvious graphql schema app reliability since dont integration test currently incautious change error code description backend spelling error frontend error response handling might undetected automated testing end production impact development frontend devs dont look backend business logic code find type error possibly returned operation dont define additional result type either however query body verbose due handling union type see example resolver verbosity resolvers return lengthy result one two field set none anyways there real advantage returning multiple error anyways since occur frequently would potentially overwhelm end user consequence improved errorprone graphql interface mixed error response style schema frontendbackend code base reference graphql framework adr httpswwwapollographqlcomdocsapolloserverdataerrorserrorcodes httpsgithubcomboxwiseboxtributeblobfcdeadacbdcbdbackboxtributeserverexceptionspyll httpsgithubcomboxwiseboxtributeblobfcdeadacbdcbdfrontsrchooksuseqrresolvertsll httpsgithubcomboxwiseboxtributeblobfcdeadacbdcbdfrontsrcviewstransferscreatetransferagreementcreatetransferagreementviewtsxll httpsgithubcommirumeeariadneissuesissuecomment httpsgithubcomboxwiseboxtributeblobfcdeadacbdcbdbackboxtributeserverbusinesslogicboxtransfershipmentcrudpyl httpstrellocomcrblcigkxbugwhenamultibaseusergoestoashipmentfromanotherbaseheshecannotreconcileitbutheshegetsasuccessmessage httpssacheemediumcomokerrorhandlingingraphqlecaecbc httpsariadnegraphqlorgdocserrormessaging httpsgithubcommirumeeariadnediscussions