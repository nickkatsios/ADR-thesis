architecture digital paper edit deciders pietro dave eimi james alli technical story httpsgithubcombbcdigitalpapereditissues additional story httpsgithubcombbcdigitalpapereditapiissues problem statement digital paper edit three milestone transcript paperedit annotation want make sure transcript phase solid architecture provide storage uploaded content transcription later phase want consider technology resilience scalability cost point view opensource compatibility extensibility driver resilience scalability cost number user opensource compatibility extensibility considered framework infrastructure docker serverless cosmos component lambda aws storage local postgresql rds dynamodb mongodb queue sts rabbitmq potential problem framework infrastructure serverless docker cosmos serverless framework make easy deploy serverless many component cli might easy begin quick deploy serverless becomes difficult maintain transfer local development production also isnt platform agnostic initially suggested give flexibility another platform still configure platform specific variable code developing mean also lack transparency resilience deployment occurs someone local development docker considered simplify orchestration microservices docker mean could separation concern application however mean would still select platform aws gcp deploying also implies extra level abstraction docker image inside cloud debugging also requires extra set decided docker able cosmos would give bulk configuration including http access free aws cosmos mean tying aws architecture make difficult move away also overhead learning cosmos also flexibility way would deployment would set jenkins restricted rhel rpm packaging method component lambda aws lambda pro con article pro con summarised following pro reduced cost execution improved application resiliency decouple server architecture code idempotent resource allocated needed con loss control environment machine guaranteed ami capability hotcold function cause delay packaging lambda dependency could problematic complex call pattern runtime limitation time out time out removed stepfunctions unverified could slower may beneficial ffmpeg unknown around ffmpeg binary requirement cold lambda article read httpsreadacloudgurudoescodinglanguagememoryorpackagesizeaffectcoldstartsofawslambdaaedc httpskevinslincomawslambdacoldstartidleresultsuseast httpsreadacloudguruhowlongdoesawslambdakeepyouridlefunctionsaroundbeforeacoldstartbfdb tldr three article lambda idleness cause lambda terminated call timeout return error next successful call cold meaning slower cold start happen idle time around mark set stone cold start vary depending allocated memory code size language lambda running python work best scenario little time taken start cold java take longest static typing worst case scenario memory size order avoid cold restarts would create step function retain lambda warm step function periodically call lambda every minute reduce idle time message delivery queue sqs well known pattern fan message service subscribed topic service http queue lambda subscribe topic typically called pubsub model sqs often combined fanout single message many different service realtime sqs considered architecture retry logic sqs best effort fifo queue work sqss cost based number polling call done queue first million free every subsequent million call consumer queue either lambda lambda beneficial case wanted asynchronous behaviour job queue however since microservices uniform approach subscribe queue update via api nicer retain uniform approach saving cost polling clear benefit lambda article read httpsdocsawsamazoncomawssimplequeueservicelatestsqsdeveloperguidesqsbestpracticeshtml httpsdocsawsamazoncomlambdalatestdgwithsqshtml httpsawsamazoncomsnsfaqsreliability httpsdocsawsamazoncomlambdalatestdgwithsqshtml httpsmediumcomtomkeebertopsnsawsdesignpatternsbacc httpsdtechcomfanoutwithsnssqslambda storage local benefit term resilience remote storage however could introduce issue infosec storing business critical item easy integrate platform stt database sqlite postgresql dynamodb mongodb postgresql flexibility json column mongodb dynamodb verbose quite clear shape database model already reading article guardian migration mongodb postgres seems like many organisation moving postgres rds see article linked think wanted longlived project want ensure reliable resilient wanted json data yes postgres sqlite good enough fully production database doesnt scale well either however sqlite could inside electron single user access also postgresql already meant json would give enough flexibility local server rds considered requirement maintaining state transcript uploaded speed access database cost database critical operation also modularity separate database separate server maintained quite useful rds give benefit backing well server database could lose information instance failsover additionally based size database would increase size machine adding cost although smaller cost rds instance initially ruled hosting website cloudfront http certbased authentication address based authentication outcome going lambda gateway lambda sqs advantage maintainable transparent transferable existing pipeline benefit cosmos mean automatically certbased security elbs also solid process around project including transparency around deployment issue disadvantage initial learning curve around cosmos understand rhe extra file cosmos opensource repository require additional documentation security checking cost aws entirely sure much right minimum instance running tsmall tsmall instance plus lambda execution well sqs locking aws advantage common pattern easier set locally good opensource developer aws account test integration locally lambda gateway disadvantage operational concern might unnecessary lambda gateway advantage cheaper isnt full instance running lambda better environment operational cost disadvantage could timeout issue lambda difficulty debugging due lambda operating system abstracted away loss control lambda sqs developed two month architecture fleshed show clearer responsibility defined interface weve added sqs fanout pattern reliable job delivery microservices microservice queue asymmetrical queue growth signed url communication via api rather direct upload api improve data transmission different component stt queue job published audio ffmpeg service subscribed stt client proxy pushed stt service treated black box completion stt task client update api directly video preview section tinted yellow currently inscope advantage fault tolerance queue avoiding timeout issue lambda running long job uniform interface across medium processing microservices polling queue posting api upload via api supposedly improves data transmission time benefit previous disadvantage additional component technology polling although cost negligible optimisation