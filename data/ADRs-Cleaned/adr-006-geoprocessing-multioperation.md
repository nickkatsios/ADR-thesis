multioperation geoprocessing operation current operation currently geoprocessing service provides set operation rastergroupedcount rastergroupedaverage rasteraverage rasterlinesjoin rastersummary operation take multipolygon list raster query raster cropped multipolygon performs respective calculation return result grouped given raster operation configured called model watershed mmw different set raster result aggregated mmw python case mapshed project invokes separate call geoprocessing service result aggregated python sent back frontend performance operation shape around size huc slightly smaller tile larger shape like huc time larger average time since frontend invokes number job spends time polling celery average wait time huc mapshed job around far acceptable geoprocessing service return successfully cache result another user selects shape raster queried cached result overall wait much shorter subbasin modeling subbasin modeling divide larger huc component hucs improve accuracy result new scheme instead running single huc run mapshed component hucs aggregate result severely affect runtime point usable discussion methodology affect runtime please see much additional runtime come processing tile multiple hucs example consider following case red shape intersects five tile purple shape intersects one tile one red five querying red shape fetch five tile querying purple shape fetch tile kind duplication happens across huc since querying number adjacent hucs furthermore understanding fetching tile largest portion single request execution time thus removing duplication greatest speedup could achieve single step proposed solution optimize reuse tile fetch geoprocessing service aware reused thus rather performing operation single shape geoprocessing service take set shape set one parent shape rest component shape parent shape fetch tile store memory operation performed every component shape choosing intersecting subset tile already memory instead output single set result list set result order incoming component shape done either existing operation adapting output mmw account new list return format previous operation still supported singleton list output implemented new multishape version operation furthermore since number geoprocessing call invoked mapshed query raster nlcd including geoprocessing call would speed well would require sending set shape set operation well operationtype list raster output list list set result first list match list component shape second list operation optionally investigate capturing sequence tile compositetile per raster benefit compositetile child shape intersects small subset total tile intersecting parent shape iterate intersecting shape compositetile however since current code implemented operating sequence tile changing compositetile remove parallelism individual tile however parallelize operation per query geometry possibly alleviating issue since benefit optimization hard estimate defer refactor unless performance good enough change since input output operation quite different current implementation added new operation type rather modification existing one subbasin modeling wrapper around mapshed decomposes parent shape child shape run mapshed aggregating result together order fully take advantage optimization mapshed must updated new operation new operation also support submitting single shape instead list shape case single huc case output singleton list list result allow regular mapshed operation rather competing implementation subbasin modeling add new operation geoprocessing service take list shape list operation first shape list assumed parent shape contains child shape parent shape pull tile corresponding every raster list operation collect sequence child shape list operation calculate result respective tile sequence result collected order returned list adr approved next step define input output new geoprocessing operation implement new geoprocessing operation benchmark new operation current one make new release geoprocessing service publish update mmw new geoprocessing service update mapshed new operation update subbasin code new operation consequence change limited geoprocessing service mmw updated accordingly running new operation get list list set result cached independently right key compiling list operation perform check result cached may require rearchitecting caching happens current spot geoprocessingpy check see entire operation cached changed support checking suboperation cache every shape execute havent cached workflow may look something like django receive request start celery job celery enumerate shape operation needed subbasin mapshed run celery check cache key make list available invoke geoprocessing geoprocessing execute new multioperation geoprocessing one available celery result come back cache right key celery get result cache return underlying wisdom seems order gain efficiency must move execution logic python scala efficiency could come loss flexibility far avoided right design input format furthermore existing operation continue function available case analyze task