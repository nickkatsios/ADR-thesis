adr dynamic capability store changelog december initial version april memory store revision full implementation ibc specification requires ability create authenticate objectcapability key runtime transaction execution described ibc specification capability key created newly initialised port channel authenticate future usage port channel since channel potentially port initialised transaction execution state machine must able create objectcapability key time present cosmos sdk ability objectcapability key currently pointer memory address storekey structs created application initialisation appgo example passed keeper fixed argument example keeper cannot create store capability key transaction execution although could call newkvstorekey take memory address returned struct storing merklised store would result consensus fault since memory address different machine intentional case key would predictable couldnt serve object capability keeper way keep private map store key altered transaction execution along suitable mechanism regenerating unique memory address capability key map whenever application started restarted along mechanism revert capability creation failure adr proposes interface mechanism cosmos sdk include new capabilitykeeper abstraction responsible provisioning tracking authenticating capability runtime application initialisation appgo capabilitykeeper hooked module unique function reference calling scopetomodule defined identify calling module later invoked initial state loaded disk capabilitykeepers initialise function create new capability key previously allocated capability identifier allocated execution past transaction assigned particular mode keep memoryonly store chain running capabilitykeeper include persistent kvstore memorystore inmemory map persistent kvstore track capability owned module memorystore store forward mapping map module name capability tuples capability name reverse mapping map module name capability name capability index since cannot marshal capability kvstore unmarshal without changing memory location capability reverse mapping kvstore simply map index index key ephemeral gomap retrieve capability original memory location capabilitykeeper define following type function capability similar storekey globally unique index instead name string method provided debugging capability simply struct address taken actual capability type capability struct index uint capabilitykeeper contains persistent store key memory store key mapping allocated module name type capabilitykeeper struct persistentkey storekey memkey storekey capmap mapuintcapability modulenames mapstringinterface sealed bool capabilitykeeper provides ability create scoped subkeepers tied particular module name scopedcapabilitykeepers must created application initialisation passed module claim capability receive retrieve capability name addition creating new capability authenticating capability passed module type scopedcapabilitykeeper struct persistentkey storekey memkey storekey capmap mapuintcapability modulename string scopetomodule create scoped subkeeper particular name must unique must called initialiseandseal func capabilitykeeper scopetomodulemodulename string scopedcapabilitykeeper cksealed paniccannot scope module via sealed capability keeper ckscopedmodulesmodulename panicfmtsprintfcannot create multiple scoped keeper module name modulename ckscopedmodulesmodulename struct return scopedkeeper cdc ckcdc storekey ckstorekey memkey ckmemkey capmap ckcapmap module modulename initialiseandseal must called exactly loading initial state creating necessary scopedcapabilitykeepers order populate memory store newlycreated capability key accordance key previously claimed particular module prevent creation new scopedcapabilitykeepers func capabilitykeeper initialiseandsealctx cksealed paniccapability keeper sealed persistentstore ctxkvstoreckpersistentkey map ctxkvstoreckmemkey initialise memory store name persistent store index value range persistentstoreiter capability capabilitykeyindex index moduleandcapability range value modulename capabilityname moduleandcapabilitysplit memstoresetmodulename fwd capability capabilityname memstoresetmodulename rev capabilityname index ckcapmapindex capability cksealed true newcapability called module create new unique unforgeable objectcapability reference newly created capability automatically persisted calling module call claimcapability func sck scopedcapabilitykeeper newcapabilityctx name string capability error check name taken memory store capstoregetrev name nil return nil errorsnewname already taken fetch current index index persistentstoregetindex create new capability capability capabilitykeyindex index set persistent store persistentstoresetindex setsingletonsckmodulename name update index index persistentstoresetindex index set forward mapping memory store capability name memstoresetsckmodulename fwd capability name set reverse mapping memory store name index memstoresetsckmodulename rev name index set inmemory mapping index capability pointer capmapindex capability return newly created capability return capability authenticatecapability called module check capability fact correspond particular name name untrusted user input calling module previously associated func sck scopedcapabilitykeeper authenticatecapabilityname string capability capability bool return whether forward mapping memory store match name return memstoregetsckmodulename fwd capability name claimcapability allows module claim capability key received another module future getcapability call succeed claimcapability must called module receives capability wish access name future capability multiowner multiple module single capability reference func sck scopedcapabilitykeeper claimcapabilityctx capability capability name string error persistentstore ctxkvstoresckpersistentkey set forward mapping memory store capability name memstoresetsckmodulename fwd capability name set reverse mapping memory store name capability memstoresetsckmodulename rev name capability update owner set persistent store owner persistentstoregetcapabilityindex ownersaddsckmodulename name persistentstoresetcapabilityindex owner getcapability allows module fetch capability previously claimed name module allowed retrieve capability func sck scopedcapabilitykeeper getcapabilityctx name string capability error fetch index capability reverse mapping memstore index memstoregetsckmodulename rev name fetch capability gomap index capability capmapindex return capability return capability releasecapability allows module release capability previously claimed owner exist capability deleted globally func sck scopedcapabilitykeeper releasecapabilityctx capability capability err persistentstore ctxkvstoresckpersistentkey name capstoregetsckmodulename fwd capability name nil return errorcapability owned module delete forward mapping memory store memorystoredeletesckmodulename fwd capability name delete reverse mapping memory store memorystoredeletesckmodulename rev name capability update owner set persistent store owner persistentstoregetcapabilityindex ownersremovesckmodulename name ownerssize still owner keep capability around persistentstoresetcapabilityindex owner else owner delete capability persistentstoredeletecapabilityindex deletecapmapcapabilityindex usage pattern initialisation module dynamic capability must provided scopedcapabilitykeeper appgo newcapabilitykeeperpersistentkey memorykey modkeeper newmodkeeperckscopetomodulemod modkeeper newmodkeeperckscopetomodulemod initialisation logic load initial state ckinitialiseandsealinitialcontext creating passing claiming capability consider case mod want create capability associate resource ibc channel name pas mod later module would following code capability scopedcapabilitykeepernewcapabilityctx resourceabc modkeepersomefunctionctx capability args somefunction running module could claim capability func modkeeper somefunctionctx capability capability ksckclaimcapabilityctx capability resourceabc logic later module retrieve capability name pas module authenticate resource func modkeeper someotherfunctionctx name string capability ksckgetcapabilityctx name moduseresourcectx capability resourceabc module check capability key authenticated resource allowing module func modkeeper useresourcectx capability capability resource string ksckauthenticatecapabilityname capability return errorsnewunauthenticated something resource module passed capability key module module could claim call module like module case module module module would able capability proposed consequence positive dynamic capability support allows capabilitykeeper return capability pointer gomap reverting writes persistent kvstore inmemory memorystore failure negative requires additional keeper overlap existing storekey system future could combined since superset functionalitywise requires extra level indirection reverse mapping since memorystore must map index must key map retrieve actual capability neutral none known reference original discussion