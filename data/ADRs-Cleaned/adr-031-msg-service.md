adr protobuf msg service changelog initial draft remove servicemsgs follow protobuf anys spec see abstract want leverage protobuf service definition defining msg give significant developer improvement term code generated fact return type well defined currently msg handler cosmos sdk return value placed data field response return value however specified anywhere except golang handler code early conversation proposed msg return type captured protobuf extension field protobuf package cosmosgov message msgsubmitproposal cosmosprotomsgreturn uint string delegatoraddress string validatoraddress repeated sdkcoin amount never adopted however wellspecified return value msg would improve client instance xgov msgsubmitproposal return proposal bigendian uint isnt really documented anywhere client would know internals cosmos sdk parse value return user also may case want return value programmatically instance httpsgithubcomcosmoscosmossdkissues proposes method intermodule ocaps msg router welldefined return type would improve developer approach addition handler registration msg type tends add bit boilerplate top keeper usually done manual type switch isnt necessarily bad add overhead creating module decide protobuf service definition defining msg well code generated replacement msg handler define look submitproposal message xgov module start msg service definition protobuf package cosmosgov service msg rpc submitproposalmsgsubmitproposal return msgsubmitproposalresponse note backwards compatibility msgsubmitproposal request type instead canonical msgsubmitproposalrequest message msgsubmitproposal googleprotobufany content string proposer message msgsubmitproposalresponse uint proposalid commonly grpc overloading protobuf service definition like violate intent protobuf spec say dont want grpc also possible protocol buffer rpc implementation approach would get autogenerated msgserver interface addition clearly specifying return type benefit generating client server code server side almost like automatically generated keeper method could maybe instead keeper eventually see package gov type msgserver interface submitproposalcontextcontext msgsubmitproposal msgsubmitproposalresponse error client side developer could take advantage creating rpc implementation encapsulate transaction logic protobuf library asynchronous callback like protobufjs could register callback specific message even transaction include multiple msg msg service method exactly one request parameter corresponding msg type example msg service method cosmosgovvbetamsgsubmitproposal exactly one request parameter namely msg type cosmosgovvbetamsgsubmitproposal important reader understands clearly nomenclature difference msg service protobuf service msg type protobuf message difference fullyqualified name convention decided canonical msgrequest name mainly backwards compatibility also better readability txbodymessages see encoding section transaction containing cosmosgovmsgsubmitproposal read better containing cosmosgovvbetamsgsubmitproposalrequest one consequence convention msg type request parameter one msg service method however consider limitation good practice explicitness encoding encoding transaction generated msg service differ current protobuf transaction encoding defined adr encoding msg type exactly msg service method request parameter involves packing binaryencoded msg type url decoding since msg type packed decoding transaction message done unpacking anys msg type information please refer adr routing propose add msgservicerouter baseapp router keyvalue map map msg type typeurls corresponding msg service method handler since mapping msg type msg service method msgservicerouter exactly one entry per msg service method transaction processed baseapp checktx delivertx txbodymessages decoded msg msg typeurl matched entry msgservicerouter respective msg service method handler called backward compatibility old handler removed yet baseapp receives legacy msg corresponding entry msgservicerouter routed via legacy route method legacy handler module configuration adr introduced method registerqueryservice appmodule allows module register grpc querier register msg service attempt extensible approach converting registerqueryservice generic registerservices method type appmodule interface registerservicesconfigurator type configurator interface queryserver grpcserver msgserver grpcserver example module func appmodule registerservicescfg configurator typesregisterqueryservercfgqueryserver keeper typesregistermsgservercfgmsgserver keeper registerservices method configurator interface intended evolve satisfy case discussed msg service registered framework verify msg type implement sdkmsg interface throw error initialization rather later transaction processed msg service implementation like query service msg service method retrieve sdkcontext contextcontext parameter method sdkunwrapsdkcontext method package gov func keeper submitproposalgoctx contextcontext params typesmsgsubmitproposal msgsubmitproposalresponse error ctx sdkunwrapsdkcontextgoctx sdkcontext eventmanager already attached baseapps msgservicerouter separate handler definition longer needed approach consequence design change module functionality exposed accessed deprecates existing handler interface appmoduleroute favor protocol buffer service service routing described dramatically simplifies code dont create handler keeper protocol buffer autogenerated client clearly separate communication interface module module user control logic aka handler keeper exposed module interface seen black box accessible client api worth note client interface also generated protocol buffer also allows change perform functional test instead mocking appmodules router mock client server stay hidden specifically never mock moduleamsgserver moduleb rather moduleamsgclient one think working external service online server assume transmission client server correctly handled generated protocol buffer finally closing module client api open desirable ocap pattern discussed adr since server implementation interface hidden nobody hold keepersservers forced relay client interface drive developer correct encapsulation software engineering pattern pro communicates return type clearly manual handler registration return type marshaling longer needed implement interface register communication interface automatically generated developer focus state transition method would improve approach chose adopt generated client code could useful client test dramatically reduces simplifies code con service definition outside grpc could confusing doesnt violate proto spec reference initial github issue proto language guide defining service adr adr