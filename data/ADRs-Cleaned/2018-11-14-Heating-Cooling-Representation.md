template background order evaluate expression usually one evaluate expression term first expression evaluated example may evaluated order following equivalent pattern placeholder expression extracted larger one evaluation separate expression evaluated heating rewriting cooling heating rewriting cooling rewriting many case desirable allow expression evaluated fairly free order consider following example side effect according standard function called order valid call allpath reachability proof one attempt show starting given pattern matter evaluated one reach certain target pattern coinductive proof whenever cycle pattern rewritten indirectly anything proven problemquestions encode heating cooling rule kore way rewrite cycle compute pattern reachable given one prove reachable allowing evaluation order heatedcooled term thats desirable equation rewriting rule like following function symbol injexp kab injexp injexp kab injexp rewriting rule changed bit solution would also solved problem reasoning considered considered plain rewriting rule rule like following generates rewrite cycle rewriting rule side condition value value value value side condition solve rewrite cycle issue allow possible expression evaluation allow evaluating background section example equation solve evaluation order issue elegant way usually computationally feasible compute possible expression expansion problem though first note constructor cant constructor make unification difficult whenever try unify must expand term possible equation match top form would constructor continue unifying child example unify abcsomething may expand former following set abcsomething abcsomething abcsomething bacsomething cabsomething would following unification xab zsomething zcsomething second problem would equation applied anywhere could also abcsomething expansion helpful way could try heat thing top sort injection injexp kab injexp depending define symbol involving may may inj around former constructor equation equivalent original one back weird expansion problem seems constructor one actually general problem sure given set equation inferred preferably would like know cant get contradiction equation simplify problem expanding symbol byneed could always expand pattern fully rewriting unify function would constructor result would messy may expand part pattern needed current rule probably better expand needed unification algorithm whenever unify nonconstructor symbol something else expand nonconstructor top child nonconstructors top nonconstructor child note requires least one equality term nonconstructor top probably want cache expansion result reuse future unification want able merge various rewriting branch also help check dont infer unwanted stuff see unwanted inference subsection guess want expand needed cache result third problem seems rather difficult prove one consider rewrite starting expansion one want find reach target pattern matter evaluate rewrite start pattern however might possible prove meta level assume problem somewhat solvable unwanted inference know equation applied expanding given term might easier time finding issue impractical example equation nonconstructors top term made symbol variable domain value might able include thing replace free variable term special symbol vsort make undirected multigraph node equation edge also add edge node make equal check connected component make sen separately equation look like node graph would vsortvsort vsort vsort vsort vsort would edge vev vev intended design doc would check unwanted inference one see would two node constructor top connected component might worry get contradiction check path said node see indeed reachable also easy see condition change model much wellbehaved shouldnt replace equation subterms contain nonconstructors variable vsubterm predicate look like also bit work also handle subterms nonconstructors rewriting rule changed bit abx value abx value int value rely nonvalues thing always evaluated note allow decomposing expression way possible long extracting value allow recomposing something changed time non heatingcooling rewrite mark term changed start expression always extract expression want evaluate first top evaluation stack evaluating changed bit becomes allows repack expression back repeating extraction needed extracting nonvalues ensures dont get stuck expression cant evaluate top stack allowing expression repacking something changed prevents rewrite cycle main problem original semantics something bit different prove equivalence