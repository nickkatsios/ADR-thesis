mvp pas complex datatypes ffi simple explicit serialization deciders rfkelly thereabouts problem statement passing complex datatypes rust foreignlanguage code back well complex given rust struct named field corresponding autogenerated data class foreign language binding one turn driver ensuring safety generated code fitting mvp goal favouring initialtimetoship performance considered declare complex datatypes protocol buffer pas serialized byte declare complex datatypes reprc structs pas directly implement simple direct serialization scheme pas serialized byte outcome chosen implement simple direct serialization scheme pas serialized byte choice come simplicity safety mvp serializing complex datatypes bytebuffer make easier pas data safely across ffi strictly control shared access memory side boundary simple serialization scheme reducing number moving part relative thirdparty serialization library choice come nontrivial performance cost thats acceptable mvp likely revisit choice mvp tool prof successful expect incrementally without changing consumerfacing experience pro con declare complex datatypes protocol buffer pas serialized byte following approach currently taken handwritten component binding applicationservices could generate protocol buffer schema complex data type generated serialization code send across ffi bytebuffer good familiar approach existing component good protocol buffer exist decent tooling generating serialization code various target language good hard mishandle data way introduces memorysafety issue bad wed calling protobuf codegenerator inside codegenerator seems like complex setup bad there likely noticeable serializationrelated performance overhead bad protocol buffer contain complexity isnt useful usecase affordances backwardscompatibility similar set consideration apply thirdparty serialization scheme flatbuffers added disadvantage unfamiliarity ultimately additional build complexity integrating codegenerator inside code generator make unattractive declare complex datatypes reprc structs pas directly following approach currently taken handwritten component binding glean project could generate reprc struct complex data type corresponding struct foreign language binding pas structs directly across ffi boundary either value pointer good minimal serialization overhead good avoid copying data rustmemory foreignlanguagememory bad raw pointer give opportunity memorysafety issue bad obvious handle nested value without raw pointer bad codegen seems likely complex ultimately given mvp explicitly prioritizes feature performance good choice mvp seems worthwhile revisiting postmvp performance becomes important implement simple direct serialization scheme pas serialized byte could invent simple serialization scheme without bellsandwhistles protocol buffer serialize complex data type send across ffi bytebuffer good similar familiar protocolbuffers approach good directly codegen serialization logic part generating code data structure good hard mishandle data way introduces memorysafety issue bad might introduce bug new codebase already shaken mature thirdparty serialization library bad there likely noticeable serializationrelated performance overhead ultimately simplicity safety approach make best choice mvp link crossing rust ffi frontier protocol buffer discussion application service component pas complex data type serializing protocol buffer deserializing side week glean byte memory android discussion glean library pass complex data type mapping reprc structs