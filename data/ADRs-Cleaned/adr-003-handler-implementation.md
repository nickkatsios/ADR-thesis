adr ibc handler implementation changelog initial proposal rename handler message processor revamp definition chainspecific message reader keeper consolidate adr implementation adr provide recommendation implementing ibc handler within ibc module crate concept introduced order given topological sort dependency event ibc handler must able emit event broadcasted via node pubsub mechanism eventually picked ibc relayer event arbitrary structure depending handler produce list ibcrelated event seen relayer note consumer event production would relayer directly instead consumer nodesdk ibc module executes nevertheless handler reuse event definition rust pub enum ibcevent newblocknewblock createclientclienteventscreateclient updateclientclienteventsupdateclient clientmisbehaviorclienteventsclientmisbehavior openinitconnectionconnectioneventsopeninit opentryconnectionconnectioneventsopentry logging ibc handler must able log information introspectability ease debugging handler output multiple log record expressed pair log line interface emitting log record described next section rust pub enum logstatus success info warning error pub struct log logstatus body string impl log successmsg impl display self infomsg impl display self warningmsg impl display self errormsg impl display self handler output ibc handler must able return arbitrary data together event log record described handler may fail necessary keep track error end introduce type return value handler rust pub type handlerresult result pub struct handleroutput pub result pub log vec pub event vec introduce builder interface within handler implementation incrementally build handleroutput value rust impl handleroutput pub builder handleroutputbuilder handleroutputbuildernew pub struct handleroutputbuilder log vec event vec marker phantomdata impl handleroutputbuilder pub logmut self log impl pub emitmut self event impl pub withresultself result handleroutput provide example usage builder api rust someibchandler handlerresult let mut output handleroutputbuilder outputlogloginfodid something outputloglogsuccessall good outputemitsomeeventallgood okoutputwithresult ibc submodule various ibc message processing logic described ibc specification split collection submodules pertaining specific aspect ibc protocol client lifecycle management connection lifecycle management packet relay etc section propose general approach implement handler submodule running example dummy submodule deal connection mistaken actual connection submodule reader typical handler read data chain state current height via private provable store avoid coupling handler interface store api introduce interface accessing data interface called reader shared handler submodule typically access data highlevel interface purpose help avoiding coupling make writing unit test handler easier one provide concrete store mock one rust pub trait connectionreader connectionendself connectionid connectionid optionconnectionend production implementation reader would hold reference private provable store current height handler executes omit actual implementation store interface yet defined general ibc toplevel module machinery mock implementation connectionreader trait could look follows rust struct mockconnectionreader connectionid connectionid connectionend clientreader mockclientreader impl connectionreader mockconnectionreader connectionendself connectionid connectionid connectionid selfconnectionid selfconnectionendclone else none keeper handler executes successfully data typically persisted chain state via privateprovable store interface vein reader defined previous section submodule define trait provides operation persist data consideration wrt coupling unittesting apply well rust pub trait connectionkeeper storeconnection mut self clientid connectionid clienttype connectiontype result error addconnectiontoclient mut self clientid clientid connectionid connectionid result error submodule implementation come actual definition handler submodule recommend handler defined within rust module named handler example create client handler would defined modulesicsclienthandlercreateclient message type handler must define datatype represent message process rust pub struct msgconnectionopeninit connectionid connectionid clientid clientid counterparty counterparty handler implementation section provide guideline implementing actual handler divide handler two part processing persistence processing actual logic handler expressed pure function typically named process take argument reader corresponding message return handleroutputt concrete datatype error type defines potential error yielded handler current submodule rust pub struct connectionmsgprocessingresult connectionid connectionid connectionend connectionend process function typically read data via reader perform check validation construct new datatypes emit log record event eventually return data together object persisted end process function create manipulate handleroutput value like described corresponding section rust pub process reader dyn connectionreader msg msgconnectionopeninit handlerresult let mut output handleroutputbuilder let msgconnectionopeninit connectionid clientid counterparty msg readerconnectionendconnectionidissome return errkindconnectionalreadyexistsconnectionidinto outputlogsuccess connection state found readerclientreaderclientstateclientidisnone return errkindclientforconnectionmissingclientidinto outputlogsuccess client found outputemitibceventconnectionopeninitconnectionidclone okoutputwithresultconnectionmsgprocessingresult connectionid clientid counterparty persistence process function specified succeeds result value yielded passed function named keep responsible persisting object constructed processing function keep function take submodules keeper result type defined performs sideeffecting call keeper method persist result given implementation keep function create connection handler rust pub keep keeper mut dyn connectionkeeper result connectionmsgprocessingresult result error keeperstoreconnectionresultconnectionidclone resultconnectionend keeperaddconnectiontoclientresultclientid resultconnectionid submodule dispatcher section much work progress investigation productionready implementation ctx parameter toplevel dispatcher required implementers feel free disregard recommendation encouraged come amendment adr better capture actual requirement submodule responsible dispatching message given appropriate message processing function successful pas resulting data persistence function defined previous section end submodule define enumeration message order toplevel submodule dispatcher forward appropriate processor definition connection submodule given rust pub enum connectionmsg connectionopeninitmsgconnectionopeninit connectionopentrymsgconnectionopentry actual implementation submodule dispatcher quite straightforward unlikely vary much substance submodules give implementation connection module rust pub dispatchctx mut ctx msg msg result ctx connectionreader connectionkeeper match msg msgconnectionopeninitmsg let handleroutput result log event connectionopeninitprocessctx msg connectionkeepctx result okhandleroutputbuilder withloglog witheventsevents withresult msgconnectionopentrymsg omitted essence toplevel dispatcher function message wrapped enumeration introduced implement reader keeper interface dealing chainspecific datatypes client submodule stand submodules deal chainspecific datatypes header clientstate consensusstate abstract chainspecific datatypes introduce trait specifies type abstract interface client submodule trait look follow rust pub trait clientdef type header header type clientstate clientstate type consensusstate consensusstate clientdef trait specifies three datatypes corresponding interface provided via trait defined submodule production implementation interface would instantiate type concrete type chain tendermint datatypes concrete datatype must provided instance lift corresponding enumeration purpose unittesting mock implementation clientdef trait could look follows rust struct mockheaderu impl header mockheader omitted impl anyheader frommh mockheader self selfmockmh struct mockclientstateu impl clientstate mockclientstate omitted impl anyclientstate frommcs mockclientstate self selfmockmcs struct mockconsensusstateu impl consensusstate mockconsensusstate omitted impl anyconsensusstate frommcs mockconsensusstate self selfmockmcs struct mockclient impl clientdef mockclient type header mockheader type clientstate mockclientstate type consensusstate mockconsensusstate since actual type client determined runtime cannot encode type client within message limitation rust type system namely lack proper support existential type currently impossible define reader keeper trait agnostic actual type client could alternatively model chainspecific datatypes boxed trait object boxdyn trait approach run lot limitation trait object inability easily require trait object clonable serializable define equality relation support functionality found thirdparty library overall experience developer subpar thus settle different strategy lifting chainspecific data enum possible chain type example model chainspecific header type would define enumeration following way rust deriveclone debug partialeq serialize deserialize todo add pub enum anyheader mockmocksmockheader tenderminttendermintheaderheader impl header anyheader heightself height match self selfmockheader headerheight selftendermintheader headerheight clienttypeself clienttype match self selfmockheader headerclienttype selftendermintheader headerclienttype enumeration dispatch method call underlying datatype runtime hiding latter thus akin proper existential type without running limitation rust type system impl header bound allowed everywhere header able treated trait object clone partialeq serialize deserialize bound etc chainspecific datatypes clientstate consensusstate require enumeration possible implementation top also lift specific client definition clientdef instance enumeration follows rust deriveclone debug partialeq pub enum anyclient mockmocksmockclient tenderminttenderminttendermintclient impl clientdef anyclient type header anyheader type clientstate anyclientstate type consensusstate anyconsensusstate message defined generically clientdef instance rust deriveclone debug partialeq serialize deserialize pub struct msgcreateclient pub clientid clientid pub clienttype clienttype pub consensusstate cdconsensusstate pub struct msgupdateclient pub clientid clientid pub header cdheader keeper reader trait defined client rust pub trait clientreader clienttypeself clientid clientid clientstateself clientid clientid consensusstateself clientid clientid height height pub trait clientkeeper storeclienttype mut self clientid clientid clienttype clienttype result error storeclientstate mut self clientid clientid clientstate anyclientstate result error storeconsensusstate mut self clientid clientid consensusstate anyconsensusstate result error way one implementation clientreader clientkeeper trait required delegate serialization underlying datatypes serialize bound wrapper process keep function defined take message generic actual client type rust pub process ctx dyn clientreader msg msgcreateclient handlerresult error pub keep keeper mut dyn clientkeeper result createclientresult result error toplevel dispatcher rust pub dispatchctxctx mut ctx msg clientmsganyclient resulthandleroutput error ctx clientreader clientkeeper boilerplate way one write test mock client associated mock datatypes fairly straightforward way taking advantage instance lift concerete mock datatypes enumeration rust test testcreateclientok let clientid clientid mockclientparseunwrap let reader mockclientreader clientid clientidclone clienttype none clientstate none consensusstate none let msg msgcreateclient clientid clienttype clienttypetendermint consensusstate mockconsensusstateinto lift anyconsensusstate let output processreader msgclone match output okhandleroutput result event log snip errerr panicunexpected error err proposed consequence positive clear separation message handler logic processing persistence logic store provide support mock handler test handler functionality isolation negative data type system around submodule relatively complex neutral reference