typerighter rule management service architecture proposed typerighter requires rule management system serve rule owner managing corpus rule rule user receiving match via typerighter service summary key user story include browsing sorting filtering rule crud rule including ability evaluate rule draft applying published corpus understanding history rule including seeing changed adding feedback rule based match performance see user story doc comprehensive list position backend well backend interact service persist publish rule typescript express similar potentially share model code typescript frontend would one cannot share model checker service issuing cooky yet possible via pandomainauth node scala play share model code checker service cannot share model code typescript frontend frontend rendering front end application serverside play template quicker write model state pas interactivity splicing javascript manage changing straightforward managed react interactivity integration existing tooling including prosemirror source design system work replicate model across clientsrv boundary fetch data manage async state version control split project across repos maintain single repository split repos allows versioning common dependency add release friction anything maintained common project monorepo simpler make change common dependency potential common project becoming bit bucket implication coupling comprehensibility project persistence weve got data persist think therell least high singlefigure entity welldefined relationship data integrity wed like schemaonwrite integrity guarantee join esp satisfy rule history requirement availability dont mind limited downtime two three nine would fine availability ruleset published bottleneck rule delivery service durability care great deal lose data time effort spend maintaining corpus significant well backup regular schedule agreement rule owner regular mean nosql trivial interface well understood department meet availability durability requirement meet integrity requirement posthoc indexing painful certain circumstance potential limit question reasonably answer timely way corpus grows rds postgres meet data integrity requirement caveat well set backup meet availability durability requirement flexible indexing mean easier answer question dont yet know well ask effort define schema interaction code backend prefer scala therell plenty share checker service scala backends across tool generally speaking standard consequence see frontend frontend prefer react face unknown amount interactivity reqs app future cover possibility think cost great may able code generation manage syncing model across back frontends consequence well invest time either duplicating api model across clientserver boundary coming solution generates code version control well monorepo enable dependency sharing across project model project contain data structure common management checker service avoiding loose naming location code shared common shared hope avoid location becoming general purpose code bucket lead unnecessary coupling application structure difficult understand consequence well model project typerighter repository clear guideline included persistence well postgres persist application data well tooling satisfies data integrity concern consequence well make interact via scala project scalikejdbc seems consensus within tool ecosystem