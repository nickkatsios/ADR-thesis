adr screen architecture supersedes intermediate architecture step screen architecture however still problem uistateproducer still sort god class since reponsible business logic happen effect change system make testing cumbersome since test integration test end verifying business logic implementation detail architecture heavily dependent rxjava rxjava good lot thing current architecture encourages everything eventually lead test production code becoming increasingly harder maintain refactor addition rxjava steep learning curve requires significant onboarding effort new contributor able reach acceptable level productivity current architecture scalable framework build screen let manage business logic effect receptive change goal separate business logic presentation logic effect tested independently make state explicit saverestore manually instead depending hidden behaviour restrict rxjava managing event effect let business logic implemented pure function choosing framework evaluated many pattern framework common industry including limited android recommended architecture android recommended architecture depends architecture component work together viewmodel retain state across configuration change livedata provide lifecycleaware reactive notification lifecyle automatically manage subscription reactive notification livedata instance provided via viewmodel architecture make sense new codebases codebase already existing architecture lend well specific setup problem lifecycle component designed work screen built top activity fragment class however current architecture single activity setup individual screen implemented view subclass livedata component give much benefit unless transition view based screen fragment instance already rxjava reactive notification livedata would mean would either replace usage rxjava livedata neither feasible desirable point mvrx airbnb mvrx library built top rxjava android viewmodel architecture component good architecture couple limitation stopped choosing core model based rxjava already issue overuse rxjava across app part goal new architecture restrict usage rxjava limited section codebase support custom view designed fragment based screen suffers problem android recommended architecture mvi mvi modelviewintent one promising architecture reviewed problem mvi however generally set principle architecture mean many implementation mvi industry implemented differently based project oneway implement took look core principle mvi implementation based similar redux single source truth state readonly change made pure function decided look librariesframeworks based principle build new screen architecture based result looking framework available android world built redux principle found mobius reactive framework managing state sideeffects spotify objective framework also aligned well architecture thus decided basis screen architecture basing new screen architecture framework let satisfy following goal separation concern satisfied mobius since enables separate concern even granular level three core component update responsible deciding business logic effecthandler responsible making change system real world uirenderer responsible updating response change state component responsible discrete part system smaller focused thereby making easier test maintain making state explicit support state restoration handled mobiusdelegate class enforced since class expects model parcelable default restricting rxjava usage update component solely responsible business logic implemented pure function usage rxjava limited setting event source feed mobius loop perform asynchronous operation effecthandler component usage two thing consider look architecture implementation perspective create new screen mobius core component created component top order build screen architecture component mobius documented page migrate older screen new architecture migrating newer architecture involved process requires follow deliberate measured step migration process detailed document reference reference implementation complete architecture found commit consequence legacy controller event cached replayed soon screen inflated without waiting attached view hierarchy architecture event forwarded binding screen attached view hierarchy lost ignored correct way implement event older screen controller dependent behaviour might take effort migrate current architecture migrating architecture architecture process take time understand get migration completes new developer onboarded onto architecture codebase maintained time creating document mobius framework maintained production scale single company spotify event company stop framework might either take maintainenance move something else architecture boilerplate code compared earlier architecture