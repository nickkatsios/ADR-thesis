batch asynchronous posttransaction unlock call functionally remains implementation superseded disruptor autobatchers part atlasdb transaction protocol write transaction acquire lock lock service typically acquire two type lock immutable timestamp lock atlasdb estimate oldest running write transaction state database timestamps lowest active immutable timestamp lock considered immutable thus eligible cleanup sweep row lock cell lock depending conflict handler table involved write transaction row cell written lock prevent multiple concurrent transaction simultaneously writing row committing transaction may also acquire additional lock part atlasdbs precommit condition framework condition arbitrary thus focus optimising transaction commits release lock acquired part transaction protocol releasing immutable timestamp lock help atlasdb keep stale version data around possible factor performance certain read query pattern releasing row cell lock allows transaction update proceed currently lock released synchronously separately transaction commits thus overhead two lock service call transaction successfully committing control returned user correctness transaction protocol compromised even lock released though effort made release performance reason consider permissible atlasdb client crash performing putunlessexists transaction table case transaction considered committed instead releasing lock synchronously release asynchronously control returned user quickly transaction commit however maintaining relatively low latency transaction commit unlock important avoid unnecessarily blocking writer sweep two main design considered maintain thread pool consumer thread work queue token unlocked transaction commit place lock token queue consumer pull token queue make unlock request lock service maintain concurrent set token unlocked transaction commit place lock token set executor asynchronously unlocks token solution simpler solution term implementation however opted solution various reason firstly latency provided solution sensitive choosing well choosing small mean noticeable gap transaction commit relevant lock unlocked conversely choosing large incurs unnecessary overhead choosing value general difficult would likely require tuning depending individual deployment product read write pattern unscalable solution also decrease load placed lock service fewer unlock request made implementation solution singlethreaded executor mean average additional latency incur rpcs lock service assuming make majority time spent unlocking token network call involved tryunlock api timelockservice expose tryunlock api function much like regular unlock except user wait operation complete api exposed java http implemented new default method timelockservice delegate unlock usefully remote feign proxy calling tryunlock make rpc standard unlock also give backwards compatiblity new atlasdbtimelock client talk old timelock server knowledge endpoint concurrency model essential adding element set outstanding token efficient yet also ensure token left behind least indefinitely thus guard concurrent set java lock permit exclusive shared mode access transaction enqueue lock token unlocked perform following step acquire set lock shared mode read reference set token unlocked add lock token set token unlocked release set lock task scheduled schedule task setting task scheduled boolean flag compareandset one task scheduled task running safe set must concurrent set task unlocks token set performs following step unset task scheduled flag acquire set lock exclusive mode read reference set token unlocked write set reference point new set release set lock unlock token set read step model trivially safe token wasnt enqueued ever unlocked since token ever become unlocked must added step enqueueing unlocking lock token idempotent modulo uuid clash interestingly guarantee liveness every token enqueued unlocked absence thread death enqueue successful compareandset step token must set visible synchronize set lock enqueue successful compareandset thread must already scheduled perform unlock token must relevant set must visible synchronize set lock avoid issue starving unlocks fair lock scheme unlocking thread attempt acquire set lock enqueues still running may finish fresh call enqueue able acquire set lock unlocking thread acquired released may lower throughput unfair lock deemed necessary reader committing transaction far exceed writer unlocking thread otherwise unlocking thread might starved lock timelock failure embodiment lock service provided remote timelock server may fail request retry logic transport layer underneath previously running transaction task would throw exception unlocking row lock immutable timestamp failed allow user code proceed emit diagnostic log indicating unlock operation failed safe change throwing would make lock become available user code cannot safely assume lock transaction free commits since another thread may well acquired practice lock released timeout refreshed client mean retrying unlocks safe long continue attempt refresh lock atlasdb client automatically refresh lock acquire ensure token unlocked synchronously removed set lock refresh put unlock queue consequence improvement transaction longer wait immutable timestamp lock rowcell write lock unlocked returning anticipate make transaction faster usercode perspective two roundtrips lock service many deployment lock service remote timelock server meaning save two network call transaction succeed even problem unlocking lock transaction committed load timelock server reduced fewer unlock call made though call larger total number token still constant overhead transport layer reduced drawback transaction may hold row lock average half roundtrip time atlasdb client timelock longer partially mitigated timelock load lower feeding performance improvement across multiple call transaction protocol one background thread allocated unlock lock needed may incur overhead deployment small hardware