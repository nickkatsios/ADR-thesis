quota jmap uploads lazy consensus implemented override adr cleaup jmap uploads jmap protocol offer distinct api upload blob later referenced creating email specification mention implementers enforce quota case security reason quota set user exceeded quota result older data deleted apache james currently implement limitation data uploaded user meaning authenticated user essentially store unlimited amount binary data especially problematic deployment whose user attacker saas implement quota jmap uploads generic interface jmap upload quota current value existing implementation implement store current value per user basis current value increased upon uploads decreased blob deleted limit set globally via jmap configuration default value consequence improved security saas operation storing value cassandra incurs cost extra table count table shall limited memory operational overhead per table plan complementary work expose technical cassandra storage interface quota implement arbitrary quotalike case cassandra counter would keep track user current space usage easy get synchronisation namely counter consistency level one usage nonidempotence causing driver retry failed update thus corrective task order recompute current value care taken concurrency given nature quota expect data race storage space much exceeding quota considered regular operation client uploading file parallely might trigger data race upon older data deletion practice mean eventually consistent cleanup data upload return upfront quota validation jmap upload constraint cassandra counter data model especially prone data race upon cleanup free least space would decrease frequency update expose configurable probability recomputing upload quota inconsistent space usage reported recompute quota jmap upload storage evolution add application behaviour common implementation layer design order mutualize quota handling implementation service layer uploadservice would expose jmap facade today uploadrepository interface would responsible enforce quota related behaviour ten would act storage layer uploadreposiory implemented cassandra memory upon exceeded quota delete older uploads order add upload upload metadata migration trivial assume unix timestamp missing causing upload considered oldest recomputation jmap upload quota requires listing stored upload metadata add way list uploads user uploadreposiory without retrieving uploads content uploadservice method delete asynchronous storage based cleanup cassandra ttl object storage bucket furthermore question application aware stored order expose coherent quota rework jmap uploads order base item stored uploadrepository alternative operating saas mode would allow better trust user might simply document limitation skip work proposal acceptable member community might chose store maximum limit jmap upload quota requires extensive webadmin endpoint incurs extra cassandra read upon uploads slight minor performance negative impact aggregating global domain user scope together might also complex logic write work limited moderate space like plenty enough dozen mail composed parallel without issue even power user furthermore jmap specification behaviour lenient space exceeded hence never block user clearly claim simpler storing current value listing actual uploads order retrieve current value might lead huge tombstone read queue case likely want avoid even solves concurrency issue furthermore frequent case performance cost event sourcing would sow stopper casandra implementation lightweight transaction based reference jmap api uploads jira ticket james adr pull request