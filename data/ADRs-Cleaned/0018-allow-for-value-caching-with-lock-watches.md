allow value caching lock watch caching caching value useful optimisation system employ reduce request latency instead repeating computation load value require database read remote procedure call andor complex logic read performed return result memory however correctness perspective caching sound far able invalidate value cache may longer accurate general case difficult distributed system since cache resilient writes performed another service node locking atlasdb transactional writes atlasdb take timelock lock anything persisted unlock lock transaction completes either successfully committing unsuccessfully exact type lock guarding cell way depends table conflict handler unless table conflict handling ignoreall lock taken row level lock cell level lock consequence guarantee lock guarding cell taken since last time cell read cached value last read transaction could written since idea behind lock watch provide timelock server api specifying interesting lock monitored registering lock watch getting information last time taken since cache value construction lock descriptor time lock descriptor reach timelock generally binary string way generated varies depending whether lock row level cell level row level lock descriptor form tablename rowname cell level descriptor form tablename rowname columnname operator denotes concatenation zero byte table name contain zero byte restriction row name type blob row level lock descriptor unique cell level descriptor also given lock descriptor may always possible determine type descriptor example lock descriptor could row lock descriptor row bnullcnulld table cell lock descriptor row column cnulld table cell lock descriptor row bnullc column table criterion good solution problem demonstrate following characteristic correctness lock watch must accurately report lock unlock event lock descriptor watched circumstance minimal noise lock watch may report lock unlock event lock descriptor watched kept minimum independence wallclock time atlasdb operates assumption wallclock time relied changed lock watch excessive performance overhead critical path operation lock refreshes transaction start transaction commits exhibit large performance regression expect encounter performance regression lock unlocks dont value much generally critical path operation implementation timelock server registering interest yaml conjurelockwatchingservice name lock watching service defaultauth header package compalantiratlasdbtimelocklockwatch basepath endpoint startwatching http post swnamespace args namespace type string safety safe request lockwatchrequest lockwatchrequest wrap set lockwatchreferences indicate timelock kind lock client want watch currently two type supported full table lock watch exact row match lock watch former generally exposed user latter currently currently expose full table lock watch user many case sufficient also prone error various reason lock watch work effectively cell updated frequently extremely sensitive accidental inclusion cell exposing complex expressive api would allow user shoot foot easily example user enable lock watch row prefix foo without realising specific row prefix say food actually updated frequently would cause lock watch caching become much effective lock event log timelock leader maintains lockeventlog namespace server side purpose event log able answer user query state lock watched might java valueimmutable public interface lockwatchversion uuid long version public interface lockeventlog lockwatchstateupdate getlogdiffoptional fromversion lockwatchstateupdate union type either success indicating event happened since last known version fixed sequence number snapshot indicating state world far watched lock concerned sequence number implementation internally track bit state facilitate update including uuid identifies lock event log ring buffer tracking recent lockevents long indicating sequence number next event reference heldlockscollection mainly taking snapshot uuid generated creation event log ensure client know state log completely invalidated leader election particular even edge case node loses regains leadership since lock state cleared lock unlock called timelock evaluate relevant lock descriptor set registered lock watch match timelock enqueue lockevent indicating given descriptor locked unlocked ring buffer returning done synchronously user query getlogdiff must consider provided fromversion argument absent different log determined uuid matching far event behind heldlockscollection give user snapshot world version set active lock watch set lock descriptor corresponding lock already taken also matching lock watch otherwise relevant part ring buffer served user creation event implement registration new lock watch another event log recall definition correctness minimal noise costly synchronise matching lock unlock request lock watch created dont make guarantee suffices first add lock watch set tracked lock watch new lockunlock request evaluate look currently open lock add lockunlock event client aware open lock add lockwatchcreated event log havent implemented deregistration though conceptually simpler client flush everything cached thats starting transaction timelock provides api atlas client start transaction atlas client track last version know provides part request body said starting atlasdb transaction requires timelock multiple thing careful ordering starting batch transaction requires locking immutable timestamp getting fresh timestamps start timestamp transaction providing correct lockwatchstateupdate client based lastknownversion provide starttransactionrequest update return entirely must ensure information lock request completed request started already included log returned user take start timestamps looking lock log could event occurred interim didnt see thats allowed consider lock event happening parallel must relate transaction already started run transaction task definition atlas transaction protocol got commit timestamp yet since already taken start timestamp know start timestamp must transaction commit timestamp cannot see write doesnt matter implementation atlasdb requirement atlasdb track term event know lastknownversion also ensure transaction able read transactionally cache particular older transaction run time subsequent transaction write read watched cell old transaction invalidate value read cell atlasdb also expose schema configuration point allow user specify want caching table based also actually register watch timelock starting transaction todo deployment testing todo consequence todo