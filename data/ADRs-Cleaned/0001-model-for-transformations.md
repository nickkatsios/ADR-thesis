model transformation build computation result winery yaml parser tservicetemplatejava plugins deal model directly convenient way plugin developer access tosca topology considered alternative inherit tservicetemplate extends way build data model describe metamodel eclipse emf generate instance model outcome chosen alternative build data model come best see pro con alternative inherit tservicetemplate extend way new model class different package inheriting model class class get new method orgeclipsewinerymodeltoscayaml reused emf resource set handling implemented manually plugin developer deal model inconvenient way type expressed via java class design ugly plugin would define class supported node type map contained element tservicetemplate individually proper java instance build data model build data model instead reusing tservicetemplate object oriented normative node type webserver modelled java class instance class nodetemplate node type new model accessible via graph jgrapht whereas modeled nodetemplates vertex relationship edge clean data model cleaner design plugin developer convenient usage model plugin developer type safety code duplication plugins central definition specific supported node type easier troubleshoot due strong typing uml diagram java class taken care describe metamodel eclipse emf generate instance model resource set handling transparent solution uml code stay synchronized changing model emf cause huge overhead getting emf nonosgi project hard team doesnt know technology hard tell suitable high risk