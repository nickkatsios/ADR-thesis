stateful set custom controller update decided refactor code towards statefulsets order manage elasticsearch pod mostly order get closer kubernetes standard simplify persistentvolumes management stay open future improvement ecosystem detail check statefulsets discussion issue rejected superseded httpsgithubcomelasticcloudonksissues deciders nkvoll problem statement manage stateful workload statefulsets designed order manage stateful workload statefulsets like everyone else driver statefulsets overview manages deployment scaling set pod provides guarantee ordering uniqueness pod pod end sticky network identifier ordinal index reused rescheduling along persistent storage global order pod statefulset pod pod pod determines scaling ordering rolling operation elasticsearch topology given statefulset pod exact spec perspective instance configured several elasticsearch version node type masteronly masterdata dataonly masterdataingest coordinatingonly apm availability zone instance configuration type hotwarm architecture complex productionready scenario might want configure cluster dedicated master different dedicated data node different hot index warm index node dedicated ingest node mapping statefulsets definition would probably lead least different statefulsets resource single cluster rolling upgrade good way rollingupgrade elasticsearch cluster maybe snapshot cluster proceed node node probably start data node first master node last call elasticsearch api exclude allocation node removed wait shard node migrated node safely remove node add new node wait shard replicated properly maybe restore snapshot thing went wrong move next node step specific elasticsearch cannot accomplished statefulset controller extra control way node shutdown statefulset various update strategy rollingupdate rollingupdatepartition last one offer bit control performing rolling upgrade several stage leaving time control api call perform replacing node become quite close manually updating pod onebyone still forced perform upgrade following ordinal index defined statefulset though unless one statefulset per node certain scenario might prefer upgrading cluster growandshrink fashion add extra node remove old one case node cluster instance easy achieve statefulsets probably requires manual tweak partitioned rolling upgrade overall would lose lot flexibility way wed like run rolling upgrade statefulsets considered multiple stateful set implementing custom controller outcome decided implement controller manages pod directly positive consequence immediate benefit working pod directly control cluster lifecycle handle rolling upgrade version migration cluster growth volume reuse multiaz orchestration much flexibility relying statefulsets force depend statefulset controller release update bug fix since direct control pod pod core concept wellknown behaviour thoroughly tested field spec behaviour likely evolve direction suit could rely statefulsets would simplify part code complexify another part code complex cluster topology would still handle several statefulsets single cluster much simpler handling several pod directly negative consequence thing reimplement since statefulset orchestration manually create delete pod comparing expected pod actual pod statefulsets would compare statefulsets spec rolling upgrade manually handled give flexibility nondetermistic identity cache inconsistency handle potential resource cache inconsistency relying expectation similar replicasets link statefulsets documentation etcdoperator one first popular operator rely statefulsets check comment xiang statefulset flexible enough achieve quite thing easily benefit bring right significant best practice building kubernetes operator stateful apps google example statefulset workload however many advanced case backup restore high availability core kubernetes primitive may sufficient thats kubernetes operator come sad state stateful pod kubernetes problem statefulset understand anything going inside stateful pod abstraction layer definition abstraction bad dealing detail