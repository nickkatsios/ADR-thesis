district data storage adr briefly discus research experimentation carried order determine efficient method perform merging geographic area form new district determined topojson topology stored memory leading candidate adr assumes well topojson lay approach well storing district data given well access inmemory topology make one open task going research gain experience topojsons capability storing multiple geolevels within single topology sharing arc data storing static topology data manner allows build district mixing matching geounits different geolevels lead large performance gain building district solely block particularly case districtbuilder standard user workflow work larger geolevels building district drop blocklevel fine tuning order test created rough script read blocklevel geojson file construct topojson file multiple geolevels blocklevel geojson file tested delaware reference tract county note likely blockgroups production rather tract similarly sized shouldnt noticeable impact performance measurement script mktopojsonhierarchyjs another script benchmarkjs produced consume topojson output randomly create district several way blocksonly build district tractsonly build district combination block tract build district running script multiple time carbon gen laptop result constructing district blocksonly tractsonly combination number block gradually increased none block expected result show making multiple geolevels opposed block provides significant performance improvement also note performance scale roughly linearly number merge operation good know since help accurately gauge performance dealing larger boundary several consideration take account efficiently store district data able create data easily clientside able process data quickly serverside construct district payload data sent client server reasonablysized able support nonfixed set geolevels since blockblockgroupcounty wont one available minimize potential data inconsistency invalid state data structure propose accomplishing tree structure array built based underlying structure topology hierarchy structure element either district array array also contain district array example consider configuration county county contains blockgroups blockgroup contains block initial structure district represents county assigned unassigned district user add first county district would become user add first blockgroups third county district would become user add first block third tract third county district would become geolevel hierarchy specific instance specified part instance configuration order able determine level represents straightforward create district manner clientside planning loading large amount static data clientside provide access topological structure prototype code already creates district similar manner via single array positional base geounits reference district change additional hierarchy needed order support much larger amount geounits efficiently prototype doesnt support block likewise serverside access topology code referenced gist demonstrates general way may accomplished data payload kept compact relying fact knowledge positional data district never large since instance configured limited number possible district main usecase user infrequently drop blocklevel keep payload especially small much later redistricting process approach also allows flexibility configuration geolevels since structure nest arbitrarily deep depending many geolevels defined hardcoding geolevelkeys data inconsistency invalid state kept low since structure easily validated room data defined multiple place opposed approach array geolevel would issue term actually persisting data necessary postgresql aware content since wont running query read data javascript object topojson operate point forward able get away storing bytea similar consequence main consequence proposal push path heavily relying topojson therefore javascripttypescript library performing geospatial operation considered bit risky given typically rely postgresql python library work upfront research writing script linked well additional tinkering helpful alleviating concern undoubtedly face new technical challenge along way future work storing data manner proposed likely get far term efficiency however nice optimization consider fact run performance concern main performance improvement imagine adding caching layer likely redis store version district construction make user make change district reading previous version district applying change requested would dramatically cut number merge operation required since longer building district scratch time related clientserver payload may significantly reduced sending diff change upon interaction two optimization may developed separately dont affect work done base set logic would still place described propose dont ahead optimization base system place since may efficient enough asis