adr data availability sampling light client changelog initial draft decided augment existing rpcbased tendermint light client adding possibility additionally validate block data availability sampling general give light client assurance data behind block header validated actually available network hence state fraud proof could generated see adr great introduction tendermint light client light client general found series blog post well paper adr describes change necessary augment existing tendermint light client implementation well protocol perspective approach ideally light client request signed header preconfigured peer instead also discover peer network eventually implement refer issue would require signed header provided via mean rpc see abandoned pull request issue tendermint repository also suggestion wondertan repository usecaseslike light validator node light client data availability layer run full node optimistic rollupit would even make sense light client passively participates consensus protocol extent run subset consensus reactor consensus message vote etc come early possible light client would wait canonical commit included next block rpcbased light client could also make sense add new rpc endpoint tendermint client retrieve dataavailabilityheader daheader embed daheader commit contains signedheader header commit signature light client full daheader though superlightclients mvp decide modify existing rpcendpoint based light client mostly want ship mvp quickly possible independently make sense provide familiar experience engineer coming cosmos ecosystem later implement mentioned variant exactly described separate adrs though detailed design user perspective little change existing light client command get additional flag indicates whether run additionally light client operator decide number successful sample make deem block available hence valid case enabled light client retrieve daheader corresponding data root header request parameterizable number random sample sampling request succeed whole block available high enough probability main change light client command add new flag indicate run additionally user choose number succeeding sample required block considered available diff diff git acmdtendermintcommandslightgo bcmdtendermintcommandslightgo acmdtendermintcommandslightgo revision bfeddeebadcdab bcmdtendermintcommandslightgo dir string maxopenconnections int dasampling bool numsamples uint sequential bool trustingperiod timeduration trustedheight int lightcmdflagsboolvarsequential sequential false sequential verification verify header sequentially opposed skipping verification lightcmdflagsboolvardasampling dasampling false data availability sampling verify header sequential verification additionally verify data availability via data availability sampling lightcmdflagsuintvarnumsamples numsamples number data availability sample block data deemed available data availability sampling light client run ipfs node make sense make mostly opaque user everything around ipfs configured ipfspath ipfs path simply subdirectory inside light client directory later add ability let user configure ipfs setup granular note compatible sequential verification case light client parametrized run skipping verification cli return easytounderstand warning even error explaining make sense light client protocol light store light client store data badgerdb instance given directory err badgerdbnewdblightclientdb dir critical feature least try reuse instance local ipld store otherwise introduce yet another instance something want avoid especially long run see first implementation might still simpler create separate instance tackle cleaning separate pull request together instance rpc change rpc endpoint absolutely required although convenience ease either add daheader existing commit endpoint introduce new endpoint retrieve daheader demand certain height block hash first downside every light client daheader second explicitly reveals fullnodes client implementation note additional modified rpc endpoint could work simple first step implement downloading daheader given data root header also light client called provider retrieve lightblocks signed header validator set currently http provider implemented hence first implementation step augment provider lightblock optionally include daheader detail parallel separate pull request add separate rpc endpoint download daheader certain height store dataavailabilityheader full node able serve dataavailabilityheader without recompute time stored somewhere independent concrete serving mechanism relevant rpc endpoint ongoing work make tendermint store store header dataavailabilityheader time writing adr another pull request work isolated change add dataavailabilityheader blockid hence daheader stored along blockmeta first implementation could first build top adapt changed storage api header daheader stored inside tendermints store drafted major downside storing block data inside tendermints store well ipfs block store redundantly stored data also intense work slow full node change simple highlevel perspective assuming light client ability download daheader along required data signed header validator set given height every time light client validates retrieved lightblock additionally start background light client important sequential verification skipping verification skipping verification work assumption voting power honest whole point state fraud proof remove assumption see also related issue specification independent existing implementation three way could implemented light client accepts header valid trust succeeds additionally tendermint verification wait succeeds error timeout way aka light client stage header tendermint verification pass valid spin sampling rotines background staged header committed valid iff routine successfully return time light client optimistically accepts header valid trust regular tendermint verification succeeds run background potentially much longer timeouts background routine return errs time already trusted header marked unavailable might require rolling back already trusted header note implementation point view simplest approach would also work best currently implemented light client design approach implemented first approach seen optimization higher latency conducted parallel various height could speed catchingup sequentially light client went offline shorter weak subjectivity time window approach general move responsibility wait rollback header caller hence undesirable offer much flexibility data structure lightblock mentioned lightblock optionally contain dataavailabilityheader diff index typeslightgo diff git atypeslightgo btypeslightgo atypeslightgo revision aaffdaabbba btypeslightgo type lightblock struct signedheader jsonsignedheader validatorset validatorset jsonvalidatorset dataavailabilityheader populated light client others nil dataavailabilityheader dataavailabilityheader jsondataavailabilityheader alternatively could introduce daslightblock embeds lightblock dataavailabilityheader nonoptional field would explicit new type instead adding field existing lightblockis backwards compatible require code change new type requires fromproto function least provider provider changed additionally provide dataavailabilityheader enable light client implementation interface additionally retrieve dataavailabilityheader modified lightblock user provider indicate provider could either augment lightblock method flag add new method solely providing dataavailabilityheader could introduce new method light client latter preferable explicit clear still keep place without code change hence diff index lightproviderprovidergo diff git alightproviderprovidergo blightproviderprovidergo alightproviderprovidergo revision daeecacadbdfcfc blightproviderprovidergo error returned lightblockctx contextcontext height int typeslightblock error daslightblock return lightblock containing dataavailabilityheader including dataavailabilityheader behaves exactly lightblock light client daslightblockctx contextcontext height int typeslightblock error reportevidence report evidence misbehavior reportevidencecontextcontext typesevidence error alternatively exact result could embed existingproviderinto new interface egdasprovider add method completely equivalent approach better become clear spent time implementation regular light client call lightblock light client call daslightblock first case result vanilla tendermint second case returned lightblock additionally contain dataavailabilityheader requested height running ipfs node already method initialize run ipfs node place refactored effectively light client well mean method exported available place introduce interdependence package user able run light client single command hence initialization logic coupled creating actual ipfs node made independent tendermint init command example found ipfs code might want provide slightly different default initialization though see overridable ipfs daemon cmd note operating fully functional light client ipfs node could running client mode dhtmodeclient actually want light client also respond incoming query light client hence default run dhtmodeserver environment bandwidth must saved network condition allow server mode make easy change default behavior client add another client indicates client indicates sequential verification request daslightblocks provider change affect unexported method validateavailability order light client perform validate availability aware fact ipfs node run instead existing validateavailability function defined adr implemented note expects ipfs core api object coreapi passed interface major benefit could even change requirement light client run ipfs node without changing validation logic ipfs node custom ipld plugin could run different process machine could still pas coreapi interface orthogonal adr also note could change ipfs readonly method accept minimal interface actually namely something implement resolvenode maybe additionally nodegetter validateavailability called time header validated light client request daslightblock per able pas dataavailabilityheader testing ideally add light client existing test might worth catch relevant change tendermint upstream particular tenderminttendermint previous change depends additionally provide simple example documentation walk light client would good light client log info output related provide feedback user proposed consequence positive simple implement understand familiar tendermint cosmos devs allows trying mvp without relying celestiaapp instead simple abci app like modified kvstore app could demo light client negative light client discover peer requires light client currently run simple rpc request run ipfs node rpc make extremely easy infer light client initial light client implementation might still confusing devs familiar tendermintcosmos reason state fraud proof get rid underlying honest majority assumption still check related honest majority assumption download validator set commits validate signed header neutral light client additionally obtain daheader data root header able actually reference linked reference inside text already