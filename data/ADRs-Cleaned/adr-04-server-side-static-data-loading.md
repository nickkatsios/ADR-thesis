serverside static data loading order support performant blocklevel redistricting state able quickly perform manipulation operation statespecific topojson object adr provides rationale topojson adr describes clientside approach storing data adr provides rationale approach storing data serverside current approach keep topojson file stored retrieved loaded memory application start increase startup time allows rapid access file loaded memory however size topojson object increase complexity districting geometry california particularly complex geometry requires approximately mib memory state complex upper bound memory required per state calculate memory requirement based assuming state requires much memory california get upper bound approximately mib gib reality amount memory required lower give worstcase scenario boundary additional constraint timeline time adr written planning launch support blocklevel redistricting state within week appropriate solution attainable within timeline considering upper bound gib keep state loaded memory would allocate additional memory order application continue serving request allocating approximately gib memory sufficient fargate also requires additional vcpus provisioned higher memory allocation add additional cost running task vcpus gib ram would cost approximately per month per task likely run one instance userfacing environment enable rolling deployment alternative approach would implement external caching layer service like aws elasticache approach external shared inmemory data store good fit architectural perspective would require substantial integration effort application perspective term cost rlarge instance gib ram would cost additional per hour approximately per month would reduce amount memory allocate per application task though would still maintain baseline ability serve application compute district manipulation may desirable longterm solution situation able scale ability serve application beyond two task likely feasible current timeline worth additional engineering cost low scale could also define separate service individual state way distribute memory load appealing ongoing infrastructure cost perspective would allow separate userfacing application service data processing service introduces significant amount architectural complexity especially respect routing request particular state appropriate service also doesnt solve memory allocation problem fargate merely distributes would allow independent scaling busy tenant large amount generic application traffic doesnt tax individual tenant however optimization may premature without recent production metric usage pattern rely given time constraint desire minimize application development work decided provision memory fargate allow keeping topojson object state memory application service instance allocate memory per task start running minimum number task necessary two task production allow rolling release one task staging allow testing prior production release consequence approach couple application server topojson inmemory store mean add application service instance handle web traffic computation would scale inmemory store well rather scaling independently given allocating gib service instance additional instance cost additional per month could become expensive period high traffic usage may make external caching service appealing cost perspective may account data loading process application health check task declared healthy added load balancer rotation inmemory cache warmed state likely increase application startup deployment time however given intend run multiple instance application task primarily impact time recovery deployment time rather application availability deploy also keep mind fargate currently upper limit gib allocated ram task arent likely run shortterm could become problem introduce significant amount additional geographical unit processed districtbuilder offer support custom unit service support geographic unit beyond state district may merit alternate approach memory requirement reevaluated additional factor aware point may want able support multiple version data state example well launching state census data census data becomes available well load well would two version data state would effectively double amount memory needed