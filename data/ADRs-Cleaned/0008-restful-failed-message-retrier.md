layout page title restfulfailedmessageretrier failed message retrier rest endpoint deciders lewin chan matt warman aaron mcgrath sebastien belin paul higginson problem statement deployed somewhere ephemeral filesystem cant rely standard error handlersretriers failed message unless docker volume mount similarl story codified best practise people easily deployed docker container like full esb stylings deadletter queue perhaps doesnt matter since everything would work queue triggered message queue driver minimal configuration required get desired behaviour upgrade behaviour require change multiple interlok configuration filesystem agnostic think might manifest workunit considered workflow based nothing pluggable storage localfss initially moving jclouds parity outcome jetty trigger however documentation happen around behaviour retrymessageerrorhandler visavis jms async producer vanilla workflow based system take base implementation blog post configuration detailed therein could made template subsequently imported multiple interlok instance maintaining configuration harder visavis upgrading managing multiple instance want concept good change bad hard maintain jetty trigger still taking blog post feature set design separate raw payload away metadata simply pragmatic choice dealing arbitrarily large message dont think encode payload metadata single blob target able something like curl xget httplocalhostapilistfailed get json array back essentially target directory curl xpost httplocalhostapiretrymsgid get message automatically retried target workflow described pretty diagram generated via plantuml boil new failedmessageretrier implementation retryfromjetty supporting interface interlokcore since failedmessageretriers know workflow right object reuse whatever component java public class retryfromjetty implement failedmessageretrier configuring jettyconsumer jettyconsumer reporting apiretry apiretry apiretry apiretry apiretry apiretry private string retryendpointprefix private string reportingendpoint private jettyconnection connection private bloblistrenderer reportrenderer private retryhandler handler advancedconfigraretrue private string retryhttpmethodpost advancedconfig private boolean deleteaftersubmit java public interface retryhandler listremotefile report adaptrismessage buildforretrying void deletestring msgid ultimately manifest xml two separate element xml failedmessageretrier classretryfromjetty retryendpointprefixapiretryretryendpointprefix reportingendpointapilistfailedreportingendpoint jettyconnection classembeddedjettyconnection reportrenderer classjsonbloblistrenderer handler classfromfs baseurlfilelocalhostfserrorsbaseurl payloadnamepayloadbinpayloadname metadatanamemetadatapropertiesmetadataname handler failedmessageretrier service understands write filesystem rather standaloneproducer fsproducer xml service classputmessageonfilesystem bucketnamebucketbucketname baseurlilelocalhostfserrorsbaseurl payloadnamepayloadbinpayloadname metadatanamemetadatapropertiesmetadataname consider locational piece metadata later service failedmessagepayloadfilelocalhostfserrorsmsgidpayloadbin failedmessagemetadatafilelocalhostfserrorsmsgidmetadataproperties service good pluggable good abstract behavioural complexity bad probably free form powerusers want switching cloud storage consider extended usecase azure blob storage would custom implementation explicitness xml handler classgetfroms awsconnection classtimebombedcredentials bucketnamebucketbucketname sprefixmyinterlokinstancefailedsprefix payloadnamepayloadbinpayloadname metadatanamemetadatapropertiesmetadataname handler something thing part messageerrorhandler chain xml service classuploadmessagetos awsconnection classtimebombedcredentials bucketnamebucketbucketname sprefixmyinterlokinstancefailedsprefix payloadnamepayloadbinpayloadname metadatanamemetadatapropertiesmetadataname consider locational piece metadata later service failedmessagepayloadsbucketpathtomsgidpayloadbin failedmessagemetadatasbucketpathtomsgidmetadataproperties service