retention service approved idempotency guarantee action normally provided limited period time creates opportunity service periodically cleanup stored action result avoid ever growing storage requirement performance implication weve considered approach problem partition periodical purge performance wise introducing partition idempotentaction table seemed like best idea performance benefit outweighed complication facilitating dropping partition way automatically create partition postgres issue come absence global index across partition database postgres creates limitation idempotent action key uniquely map partition since natural choice partition key would mean actionid would come along bit embedded uuidv far weve tried avoid imposing limitation key format hence put idea partitioning hold periodical purge seemed like feasible approach database lacking timetolive ttl index come challenge like multiinstance set performance client extremely careful batch size purging avoid negative effect database performance avoid coordination purge job execution multi instance setup dependency zookeeperetcd leader election opted lightweight database scheduler dbscheduler guarantee single instance execution allow client configure retention policy idempotent action client specify retention period iso format cron schedule purge job spring format batchsize removal operation yaml idempotencej retention enabled true period pymd purge schedule batchsize purge job executed single node multi instance set consequence service database support ttl index wont enable retention feature otherwise retention policy purge property carefully configured taking performance account single instance purge execution becomes bottleneck iterate approach allow mutliinstance execution longterm global index across partition becomes generally available majority database reevaluate