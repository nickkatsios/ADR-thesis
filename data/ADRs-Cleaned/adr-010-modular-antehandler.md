adr modular antehandler changelog aug initial draft sep superseded adr superseded adr current antehandler design allows user either default antehandler provided xauth build antehandler scratch ideally antehandler functionality split multiple modular function chained together along custom antefunctions user rewrite common antehandler logic want implement custom behavior example let say user want implement custom signature verification logic current codebase user would write antehandler scratch largely reimplementing much code set custom monolithic antehandler baseapp instead would like allow user specify custom behavior necessary combine default antehandler functionality way modular flexible possible proposal permodule antehandler one approach modulemanager module implement antehandler requires custom antehandler logic modulemanager passed antehandler order way order beginblockers endblockers modulemanager return single antehandler function take run module antehandle specified order module manager antehandler set baseapps antehandler pro simple implement utilizes existing modulemanager architecture con improves granularity still cannot get granular permodule basis auths antehandle function charge validating memo signature user cannot swap signaturechecking functionality keeping rest auths antehandle functionality module antehandler run one way one antehandler wrap decorate another decorator pattern weave project achieves antehandler modularity decorator pattern interface designed follows decorator wrap handler provide common functionality like authentication feehandling many handler type decorator interface checkctx store kvstore next checker checkresult error deliverctx store kvstore next deliverer deliverresult error decorator work like modularized cosmos sdk antehandler function take next argument may another decorator handler take next argument decorator chained together one decorator passed next argument previous decorator chain chain end router take route appropriate msg handler key benefit approach one decorator wrap internal logic around next checkerdeliverer weave decorator may following example decorator deliver function func example decorator deliverctx store kvstore next deliverer preprocessing logic err nextdeliverctx store postprocessing logic given result error pro weave decorator wrap next decoratorhandler chain ability preprocess postprocess may useful certain setting provides nested modular structure isnt possible solution also allowing linear oneaftertheother structure like solution con hard understand first glance state update would occur decorator run given ctx store decorator arbitrary number nested decorator called within function body possibly pre postprocessing calling next decorator chain thus understand decorator one must also understand every decorator along chain also get quite complicated understand linear oneaftertheother approach powerful may much easier reason chained microfunctions benefit weave approach decorator concise chained together allows maximum customizability however nested structure get quite complex thus hard reason another approach split antehandler functionality tightly scoped microfunctions preserving oneaftertheother ordering would come modulemanager approach way chain microfunctions run one module may define multiple ante microfunctions also provide default permodule antehandler implement default suggested order microfunctions user order antehandlers easily simply modulemanager modulemanager take list antehandlers return single antehandler run antehandler order list provided user comfortable default ordering module simple providing list module antehandler exactly beginblocker endblocker however user wish change order add modify delete ante microfunctions anyway always define ante microfunctions add explicitly list get passed module manager default workflow example user antehandler choose make custom microfunctions cosmos sdk code chain together list antehandler microfunctions get run one returned antehandler abort first error func chainerorder antehandler antehandler return funcctx simulate bool newctx err error ante range order ctx err antectx simulate err nil return ctx err return ctx err antehandler microfunction verify signature func verifysignaturesctx simulate bool newctx err error verify signature return invalidsignature result aborttrue sigs invalid return result abortfalse sigs valid antehandler microfunction validate memo func validatememoctx simulate bool newctx err error validate memo auth defines default antehandler chaining microfunctions recommended order authmoduleantehandler chainerantehandlerverifysignatures validatememo distribution microfunction deduct fee func deductfeesctx simulate bool newctx err error deduct fee abort insufficient fund account pay fee distribution microfunction check fee mempool parameter func checkmempoolfeesctx simulate bool newctx err error checktx abort fee mempools minfee parameter distribution defines default antehandler chaining microfunctions recommended order distrmoduleantehandler chainerantehandlercheckmempoolfees deductfees type modulemanager struct field antehandlerorder antehandler func modulemanager getantehandler antehandler return chainermmantehandlerorder user code note since user making custom modification setantehandlerorder default antehandlers provided module preferred order modulemanagersetantehandlerorderantehandlerauthmoduleantehandler distrmoduleantehandler appsetantehandlermmgetantehandler custom workflow example workflow user want implement custom antehandler logic example user want implement custom signature verification change order antehandler validate memo run signature verification user code user implement custom signature verification antehandler microfunction func customsigverifyctx simulate bool newctx err error custom signature verification logic microfunctions allow user change order get executed swap default antefunctionality custom logic note user still chain default distribution module handler auth microfunction along custom ante function modulemanagersetantehandlerorderantehandlervalidatememo customsigverify distrmoduleantehandler pro allows ante functionality modular possible user custom antefunctionality little difference antehandlers work beginblock endblock work modulemanager still easy understand con cannot wrap antehandlers decorator like weave simple decorator approach take inspiration weave decorator design trying minimize number breaking change cosmos sdk maximizing simplicity like weave decorator approach allows one antedecorator wrap next antehandler pre postprocessing result useful since decorator defercleanups antehandler return well perform setup beforehand unlike weave decorator antedecorator function wrap antehandler rather entire handler execution path deliberate want decorator different module perform authenticationvalidation however want decorator capable wrapping modifying result msghandler addition approach break core cosmos sdk apis since preserve notion antehandler still set single antehandler baseapp decorator simply additional approach available user desire customization api module namely xauth may break approach core api remains untouched allow decorator interface chained together create cosmos sdk antehandler allows user choose implementing antehandler setting baseapp decorator pattern chain custom decorator cosmos sdk provided decorator order wish antedecorator wrap antehandler pre postprocessing next antehandler type antedecorator interface antehandlectx simulate bool next antehandler newctx err error chainantedecorators recursively link antedecorators chain return final antehandler function done preserve ability set single antehandler function baseapp func chainantedecoratorschain antedecorator antehandler lenchain return funcctx simulate bool chainantehandlectx simulate nil return funcctx simulate bool chainantehandlectx simulate chainantedecoratorschain example code define antedecorator function setup gasmeter catch outofgaspanic handle appropriately type setupcontextdecorator struct func sud setupcontextdecorator antehandlectx simulate bool next antehandler newctx err error ctxgasmeter newgasmetertxgas defer func recover outofgas panic handle appropriately return nextctx simulate signature verification decorator verify signature move type sigverifydecorator struct func svd sigverifydecorator antehandlectx simulate bool next antehandler newctx err error verify sigs return error invalid call next antehandler sigs return nextctx simulate userdefined decorator choose pre postprocess antehandler type userdefineddecorator struct custom field func udd userdefineddecorator antehandlectx simulate bool next antehandler newctx err error preprocessing logic ctx err nextctx simulate postprocessing logic link antedecorators create final antehandler set antehandler baseapp create final antehandler chaining decorator together antehandler chainantedecoratorsnewsetupcontextdecorator newsigverifydecorator newuserdefineddecorator set chained antehandler baseapp bappsetantehandlerantehandler pro allows one decorator pre postprocess next antehandler similar weave design break baseapp api user still set single antehandler choose con decorator pattern may deeply nested structure hard understand mitigated decorator order explicitly listed chainantedecorators function make modulemanager design since already beginblockerendblocker proposal seems unaligned design pattern consequence since pro con written approach omitted section reference modular antehandler issue initial implementation permodule antehandler approach weave decorator code weave design video