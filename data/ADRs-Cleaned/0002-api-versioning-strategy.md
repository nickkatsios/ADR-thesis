api versioning strategy regardless well planned api sure bet business requirement eventually dictate backwardsincompatible change made api versioning api necessity opgdata api must implement versioning must restful offer much flexibility regard future hostinginfrastructure possible sadly real consesus best approach versioning api several big player opting different strategy pro con approach exploration various api versioning strategy may found versioningstrategymd semantic versioning httpssemverorg see versioningstrategymdsemver implement versioning via content negotiation accept header per versioningstrategymdoptions seems future proof restful solution necessitates vendor content type example applicationvndopgdatavjson presented json applicationvndopgdatavyml presented yaml applicationvndopgdatav presented json applicationvndopgdata latest version presented json applicationjson latest version json final two dangerous version presented change time without warning see also content negotiation given time api allow request two major version latest version previous deprecated version api response contain xcurrentapiversion set current version api addition xapiwarn header calling deprecated api endpoint version timeline document kept change presented endpoint apireleaseinfo within api versionnonspecific contenttype final two example preceding list xapiwarn header returned warning client specify version consequence simple api consumer request version representation hateoasfriendly cachefriendly restfully keep uri resource open possibility adding resourcespecific versioning future applicationvndopgdatadonorvjson would json representation donor resource version api developer must made aware accept header browser may trouble understanding nonstandard contenttypes however browser almost certainly target consumer service note detailed opgdata api specification api specification borrows heavily jsonapi documentation specify otherwise assumed jsonapi standard applies