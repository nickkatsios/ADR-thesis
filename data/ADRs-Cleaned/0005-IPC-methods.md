interprocess communication ipc method zeromq redis august pending revised design flowkit follow apibackend model interservice interprocess communication ipc must considered previously relevant within single multithreaded instance python built rlock sufficed rlock implement reentrant lock lock something may held one task control access set resource one task holding lock task must wait released order access resource standard lock applies within thread example python threading import lock lock lock lock printgot lock lock printgot lock twice get stuck printing got lock lock released restriction relaxed rlock held multiple time thread lock instance replaced rlock code would print twice finish rlock flowmachine ensure query written cache query wait cached version available instead running limitation rlock function thread within single instance program apibackend model method communication api server backend required indicates message queue type model service run separate docker container communicate network also desirable free assuming single backend server currently typical case pragmatic design alternative several message queue available fairly standard capability zeromq lightest weight lowest complexity considering ipc backend flowmachine necessary backend communication wth database multithreaded triggered asynchronous request api database transactional backend know whether particular query process calculated cannot reliably determined directly database hence method indicating currently running required one might argue idempotency run query solution considerable runtime many query suggests otherwise ipc backend similar rationale message queue applies thread based primitive suffice close avenue multiple backend server indicates keyvalue type approach end multiple exist space largely equivalent redis arguably best known apibackend communication via zeromq ipc backend mediated redis consequence necessary deal securing intercontainer communication via zeromq manage additional docker container redis