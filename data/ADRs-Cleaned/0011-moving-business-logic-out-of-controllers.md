moving business logic controller time controller class content publisher become increasingly complex application grew size functionality led action method long difficult understand expensive test looking towards future anticipated functionality controller access limiting concurrent editing protection invalid state handling therefore expectation controller would become increasing pain point application due complexity common scenario growing rail application customary approach address distinguish business rendering logic action business logic action user requested changing application state rendering logic process building response returned user move business logic outside controller action another class within content publisher team evaluating number pattern tool creating business logic class came following conclusion service object pattern already content publisher however perform distinct application task rather coupled particular controller action felt service directory become mess content publisher little consistency service object drytransaction gem provides nice interface managing response ruby block however drytransaction requires strict adherence provided dsl make transaction class different plain old ruby object interactor gem simple relatively freeform pattern dsl object basic control flow disadvantage input output particularly clear trailblazer operation gem provides dsl creating class perform business operation work best within rail application embraced collection trailblazer utility publishing api command pattern effective pattern moving logic controller however felt become convoluted inflexible due domain logic coupling content publisher make interactor gem tool implement class performing controller business logic logic within controller action focused producing http response interactors controller action intended coupled particular action reused outside maximise clarity purpose naming minimise logic outcome interactor interactors created controller action mutate application state typically postputpatchdelete request case action simple interactor controller action dont mutate application state get request interactor class may created beneficial abstracting complexity case type request low amount code pattern would advantageous interactors stored appinteractors directory within directory created controller store interactors action pattern similar view interactor class name suffixed interactor make purpose clear example given create action documentscontroller corresponding interactor create document documentscreateinteractor stored appinteractorsdocuments interactor gem chosen writing framework handling business logic per publishing api command approach following reason bespoke problem solved shouldnt require bespoke solution authoring new pattern something requires documentation maintenance iteration harder bikeshed made externally felt compared community gem drytransaction trailblazer interactor offered lower learning curve greater flexibility lower dependency overhead also felt gem quite simple would preclude building changing different approach change found problem gem consequence many controller action content publisher refactored make interactor gem resulted increase number class application size complexity controller class decreased convention established consistent approach writing interactors focused initialising interactors request parameter user writing interactor call method sequence noargument method call delegation reduce repetitive reference variable setting variable determine http response rather contextsuccess contextfailure method allows code explicit successfailure scenario occurred