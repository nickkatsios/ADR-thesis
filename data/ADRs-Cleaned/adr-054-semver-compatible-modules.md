adr semver compatible sdk module changelog first draft draft abstract order move cosmos sdk system decoupled semantically versioned module composed different combination staking bank distribution reassess organize api surface module avoid problem semantic import versioning circular dependency adr explores various approach take addressing issue fair amount desire community semantic versioning sdk significant movement splitting sdk module standalone module ideally allow ecosystem move faster wont waiting dependency update synchronously instance could version core sdk compatible latest release cosmwasm well different version staking sort setup would allow early adopter aggressively integrate new version allowing conservative user selective version theyre ready order achieve solve following problem way semantic import versioning siv work moving siv naively actually make harder achieve goal circular dependency module broken actually release many module sdk independently pernicious minor version incompatibility introduced correctly evolving protobuf schema without correct unknown field filtering note following discussion assumes proto file versioning state machine versioning module distinct proto file maintained nonbreaking way something like buf breaking ensure change backwards compatible proto file version get bumped much frequently might maintain cosmosbankv many version bank module state machine state machine breaking change common ideally wed want semantically version module xbankv xbankv etc problem semantic import versioning compatibility consider module foo defines following msgdosomething weve released state machine module examplecomfoo protobuf package foov message msgdosomething string sender uint amount service msg dosomethingmsgdosomething return msgdosomethingresponse consider make revision module add new condition field msgdosomething also add new validation rule amount requiring nonzero following semantic versioning release next state machine version foo examplecomfoov protobuf revision package foov message msgdosomething string sender amount must nonzero integer uint amount condition optional condition thing since revision condition condition approaching naively would generate protobuf type initial version foo examplecomfootypes would generate protobuf type second version examplecomfoovtypes let say module bar talk foo keeper interface foo provides type fookeeper interface dosomethingmsgdosomething error scenario backward compatibility newer foo older bar imagine chain foo bar want upgrade foov bar module upgraded foov case chain able upgrade foov bar upgraded reference examplecomfootypesmsgdosomething examplecomfoovtypesmsgdosomething even bar usage msgdosomething changed upgrade impossible without change examplecomfootypesmsgdosomething examplecomfoovtypesmsgdosomething fundamentally different incompatible structs type system scenario forward compatibility older foo newer bar let consider reverse scenario bar upgrade foov changing msgdosomething reference examplecomfoovtypesmsgdosomething release barv change chain want chain however decided think change foov risky itd prefer stay initial version foo scenario impossible upgrade barv without upgrading foov even barv would worked fine foo changing import path msgdosomething meaning barv doesnt actually new feature foov way semantic import versioning work locked either foo bar foov barv cannot foo barv foov bar type system doesnt allow even version module otherwise compatible naive mitigation naive approach fixing would regenerate protobuf type examplecomfoovtypes instead update examplecomfootypes reflect change needed adding condition requiring amount nonzero could release patch examplecomfootypes update foov change state machine breaking requires changing validatebasic method reject case amount zero add condition field rejected based adr unknown field filtering adding change patch actually incorrect based semantic versioning chain want stay foo importing change incorrect problem circular dependency none approach allow foo bar separate module reason foo bar depend different way instance cant foo import bartypes bar import footypes several case circular module dependency sdk staking distribution slashing legitimate state machine perspective without separating api type somehow would way independently semantically version module without mitigation problem handling minor version incompatibility imagine solve first two problem scenario barv want msgdosomethingcondition foov support barv work foo set condition nonnil value foo silently ignore field resulting silent logic possibly dangerous logic error barv able check whether foo dynamically could choose condition foov available even barv able perform check however know always performing check properly without sort frameworklevel unknown field filtering hard know whether pernicious hard detect bug getting app clientserver layer adr intermodule communication may needed solution approach separate api state machine module one solution first proposed httpsgithubcomcosmoscosmossdkdiscussions isolate protobuf generated code separate module state machine module would mean could state machine module foo foov could type api module say fooapi fooapi module would perpetually accept nonbreaking change would allow module compatible either foo foov long intermodule api depends type fooapi would also allow module foo bar depend could depend fooapi barapi without foo directly depending bar vice versa similar naive mitigation described except separate type separate module could break circular module dependency problem naive solution otherwise could rectify removing state machine breaking code api module validatebasic interface method embedding correct file descriptor unknown field filtering binary migrate interface method api type handler solve remove interface implementation generated type instead handler approach essentially mean given type sort resolver allows resolve interface implementation type sdkmsg authzauthorization example func keeper dosomethingmsg msgdosomething error var validatebasichandler validatebasichandler err kresolverresolvevalidatebasichandler msg err nil return err err validatebasichandlervalidatebasic case method sdkmsg could replace declarative annotation instance getsigners already replaced protobuf annotation cosmosmsgvsigner future may consider sort protobuf validation framework like httpsgithubcombufbuildprotocgenvalidate cosmosspecific replace validatebasic pinned filedescriptors solve state machine module must able specify version protobuf file built instance api module foo upgrade foov original foo module still copy original protobuf file built adr unknown field filtering reject msgdosomething condition set simplest way may embed protobuf filedescriptors module filedescriptors runtime rather one built fooapi may different buf build embed build script probably come solution embedding filedescriptors module fairly straightforward potential limitation generated code one challenge approach place heavy restriction api module requires state machine breaking code api module would generated protobuf file probably control code generation done risk aware instance code generation orm future could contain optimization state machine breaking would either ensure carefully optimization arent actually state machine breaking generated code separate generated code api module state machine module mitigation potentially viable api module approach require extra level care avoid sort issue minor version incompatibility approach little address potential minor version incompatibility requisite unknown field filtering likely sort clientserver routing layer check adr intermodule communication required make sure done properly could allow module perform runtime check given msgclient func keeper callfoo error kintermoduleclientminorrevisionkfoomsgclient kfoomsgclientdosomethingmsgdosomethingcondition else unknown field filtering adr router would protoreflect api ensure field unknown receiving module set could result undesirable performance hit depending complex logic approach change generated code alternate approach solving versioning problem change protobuf code generated move module mostly completely direction intermodule communication described adr paradigm module could generate type internally including api type module talk module via clientserver boundary instance bar talk foo could generate version msgdosomething barinternalfoovmsgdosomething pas intermodule router would somehow convert version foo foointernalmsgdosomething currently two generated structs protobuf type cannot exist binary without special build flag see httpsdevelopersgooglecomprotocolbuffersdocsreferencegofaqfixnamespaceconflict relatively simple mitigation issue would set protobuf code register protobuf type globally generated internal package require module register type manually applevel level protobuf registry similar module already interfaceregistry amino codec module adr message passing naive nonperformant solution converting barinternalfoovmsgdosomething foointernalmsgdosomething would marshaling unmarshaling adr router would break needed expose protobuf type keeper interface whole point try keep type internal dont end import version incompatibility weve described however issue minor version incompatibility unknown field filtering sticking keeper paradigm instead adr may unviable begin performant solution could maybe adapted work keeper interface would expose getters setter generated type internally store data memory buffer could passed one implementation another zerocopy way example imagine protobuf api getters setter exposed msgsend type msgsend interface protomessage getfromaddress string gettoaddress string getamount vbetacoin setfromaddressstring settoaddressstring setamountvbetacoin func newmsgsend msgsend return msgsendimplmemorybuffers hood msgsend could implemented based raw memory buffer way capn proto flatbuffers could convert one version msgsend another without serialization zerocopy approach would added benefit allowing zerocopy message passing module written language rust accessed ffi could also make unknown field filtering intermodule communication simpler require new field added sequential order checking field set also wouldnt issue state machine breaking code generated type generated code state machine would actually live state machine module depending interface type protobuf anys language however may still desirable take handler approach described approach either way type implementing interface would still registered interfaceregistry would way retrieve via global registry order simplify access module adr public api module maybe even one remotely generated buf could client module instead requiring generate client type internally big downside approach requires big change people protobuf type would substantial rewrite protobuf code generator new generated code however could still made compatible googlegolangorgprotobufreflectprotoreflect api order work standard golang protobuf tooling possible naive approach marshalingunmarshaling adr router acceptable intermediate solution change code generator seen complex however since module would likely migrate adr anyway approach might better approach dont address issue solution seen complex also decide anything explicit enable better module version compatibility break circular dependency case developer confronted issue described require dependency update sync attempt adhoc potentially hacky solution one approach ditch semantic import versioning siv altogether people commented siv changing import path foov foov etc restrictive optional golang maintainer disagree officially support semantic import versioning could however take contrarian perspective get flexibility xbased versioning basically forever module version compatibility could achieved gomod replace directive pin dependency specific compatible version instance knew foo compatible bar could replace directive gomod stick version foo bar want would work long author foo bar avoid incompatible breaking change module developer choose semantic import versioning attempt naive solution described would also special tag replace directive make sure module pinned correct version note however adhoc approach would vulnerable minor version compatibility issue described unless unknown field filtering properly addressed approach avoid protobuf generated code public apis alternative approach would avoid protobuf generated code public module apis would help avoid discrepancy state machine version client api version module module boundary would mean wouldnt intermodule message passing based adr rather stick existing keeper approach take one step avoiding protobuf generated code keeper interface method approach fookeeperdosomething method wouldnt generated msgdosomething struct come protobuf api instead positional parameter order foov support foov keeper would simply implement keeper apis dosomething method could additional condition parameter wouldnt present would danger client accidentally setting isnt available approach would avoid challenge around minor version incompatibility existing module keeper api would get new field added protobuf file taking approach however would likely require making protobuf generated code internal order prevent leaking keeper api mean would still modify protobuf code generator register internal code global registry would still manually register protobuf filedescriptors probably true scenario may however possible avoid needing refactor interface method generated type handler also approach doesnt address would done scenario module still want message router either way probably still want way pas message one module another router safely even case like xgov xauthz cosmwasm etc would still require thing outlined approach although could advise module prefer keeper communicating module biggest downside approach probably requires strict refactoring keeper interface avoid generated code leaking api may result case duplicate type already defined proto file write method converting golang protobuf version may end lot unnecessary boilerplate may discourage module actually adopting achieving effective version compatibility approach although heavy handed initially aim provide system adopted give developer version compatibility free minimal boilerplate approach may able provide straightforward system since requires golang api defined alongside protobuf api way requires duplication differing set design principle protobuf apis encourage additive change golang apis would forbid downside approach clear roadmap supporting module language like rust doesnt get closer proper object capability security one goal adr adr done properly anyway set case latest draft proposal alignment adopting adr addition framework core replacement keeper paradigm entirely adr intermodule router accommodate variation approach given following rule client type server type pas directly client server zerocopy generated code wrapper still defined pas memory buffer one wrapper marshalunmarshal type client server approach allow maximal correctness enable clear path enabling module within language possibly executed within wasm minor api revision declare minor api revision proto file propose following guideline already documented cosmosappvalpha module proto package revised initial version considered revision include package comment proto file containing test revision start comment line current revision number field message etc added version beyond initial revision add comment start comment line form since revision nonzero revision added advised correspondence state machine module versioned set proto file versioned either buf module api module buf schema registry version buf module always corresponds package revision patch release documentation comment updated okay include proto package named etc versioned buf module cosmosbankv long proto package consist single api intended served single sdk module introspecting minor api revision order module introspect minor api revision peer module propose adding following method cosmossdkiocoreintermoduleclient servicerevisionctx contextcontext servicename string uint module could service name statically generated grpc code generator intermoduleclientservicerevisionctx bankvbetamsgservicedescservicename future may decide extend code generator protobuf service add field client type check concisely package bankvbeta type msgclient interface sendcontextcontext msgsend msgsendresponse error servicerevisioncontextcontext uint unknown field filtering correctly perform unknown field filtering intermodule router one following protoreflect api message support gogo proto message marshal existing codecunknownproto code zerocopy message simple check highest set field number assuming require field adding consecutively increasing order filedescriptor registration single binary may contain different version generated protobuf code cannot rely global protobuf registry contain correct filedescriptors appconfig module configuration written protobuf would like load filedescriptors module loading module provide way register filedescriptors module registration time instantiation propose following cosmossdkiocoreappmoduleoption constructor various case filedescriptors may packaged package appmodule googlegolangorgprotobuf compatible generated code protofilesbankvbetafilecosmosbankvbetamoduleproto func protofilesfile protoreflectfiledescriptor gogo proto generated code func gzippedprotofilesfile byte buf build generated pinned file descriptor func protoimageprotoimage byte approach allows support several way protobuf file might generated proto file generated internally module protofiles api module approach pinned file descriptor protoimage gogo proto gzippedprotofiles module dependency declaration one risk adr dependency called runtime present loaded set sdk module also want module way define minimum dependency api revision require therefore module declare set dependency upfront dependency could defined module instantiated ideally know dependency instantiation statically look app config determine whether set module example bar requires foo revision able know creating app config two version bar foo propose defining dependency proto module config object interface registration also define interface method defined type serialized googleprotobufanys light desire support module language may want think solution accommodate language plugins described briefly adr testing order ensure module indeed multiple version dependency plan provide specialized unit integration testing infrastructure automatically test multiple version dependency unit testing unit test conducted inside sdk module mocking dependency full adr scenario mean interaction module done via intermodule router mocking dependency mean mocking msg query server implementation provide test runner fixture make streamlined key thing test runner test compatibility test combination dependency api revision done taking file descriptor dependency parsing comment determine revision various element added created synthetic file descriptor revision subtracting element added later proposed api unit test runner fixture package moduletesting import testing cosmossdkiocoreintermodule cosmossdkiodepinject googlegolangorggrpc googlegolangorgprotobufproto googlegolangorgprotobufreflectprotodesc type testfixture interface contextcontext intermoduleclient making call module testing beginblock endblock type unittestfixture interface testfixture grpcserviceregistrar registering mock service implementation type unittestconfig struct moduleconfig protomessage module config object depinjectconfig depinjectconfig optional additional depinject config dependencyfiledescriptors protodescfiledescriptorproto optional dependency file descriptor instead global registry run run test function combination dependency api revision func cfg unittestconfig runt testingt funct testingt unittestfixture example testing bar calling foo take advantage conditional service revision expected mock argument func testbart testingt unittestconfigmoduleconfig foomodulevmodulerunt func testingt moduletestingunittestfixture ctrl gomocknewcontrollert mockfoomsgserver footestutilnewmockmsgserver foovregistermsgserverf mockfoomsgserver barmsgclient barvnewmsgclientf fservicerevisionfoovmsgservicedescservicename mockfoomsgserverexpectdosomethinggomockany foovmsgdosomething condition condition expected revision returnfoovmsgdosomethingresponse nil else mockfoomsgserverexpectdosomethinggomockany foovmsgdosomethingreturnfoovmsgdosomethingresponse nil err barmsgclientcallfoof msgcallfoo unit test runner would make sure dependency mock return argument invalid service revision tested ensure module dont incorrectly depend functionality present given revision integration testing integration test runner fixture would also provided instead mock would test actual module dependency various combination proposed api type integrationtestfixture interface testfixture type integrationtestconfig struct moduleconfig protomessage module config object dependencymatrix mapstringprotomessage dependent module configs run run test function combination dependency module func cfg integationtestconfig runt testingt func testingt integrationtestfixture example foo bar func testbarintegrationt testingt integrationtestconfig moduleconfig barmodulevmodule dependencymatrix mapstringprotomessage runtime protomessage test two version runtime runtimevmodule runtimevmodule foo protomessage test three version foo foomodulevmodule foomodulevmodule foomodulevmodule runt func testingt moduletestingintegrationtestfixture barmsgclient barvnewmsgclientf err barmsgclientcallfoof msgcallfoo unlike unit test integration test actually pull module dependency module written without direct dependency module golang concept development dependency integration test written separate module examplecombarvtest paradigm semantic versioning possible build single module import version bar version runtime test together six various combination dependency consequence backwards compatibility module migrate fully adr compatible existing module keeper paradigm temporary workaround may create wrapper type emulate current keeper interface minimize migration overhead positive able deliver interoperable semantically versioned module dramatically increase ability cosmos sdk ecosystem iterate new feature possible write cosmos sdk module language near future negative module refactored somewhat dramatically neutral cosmossdkiocoreappconfig framework play central role term module defined likely generally good thing mean additional change user wanting stick predepinject way wiring module depinject somewhat needed maybe even obviated full adr approach adopt core api proposed httpsgithubcomcosmoscosmossdkpull module would probably always instantiate method providemoduleappmoduleservice appmoduleappmodule error complex wiring keeper dependency scenario dependency injection may much case discussion described considered draft mode pending final buyin team key stakeholder key outstanding discussion adopt direction module client introspect dependency module api revision module determine minor dependency module api revision requirement module appropriately test compatibility different dependency version register resolve interface implementation module register protobuf file descriptor depending approach take generated code api module approach may still viable supported strategy would pinned file descriptor reference httpsgithubcomcosmoscosmossdkdiscussions httpsgithubcomcosmoscosmossdkdiscussions httpsgithubcomcosmoscosmossdkdiscussions httpsgithubcomcosmoscosmossdkpull httpsgithubcomcosmoscosmossdkissues adr adr