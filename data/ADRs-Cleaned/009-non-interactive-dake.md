adr noninteractive dake noninteractive dake based xzdh protocol start responder request initiator prekey ensemble untrusted prekey server initiator longterm public key verified responder responder generates ephemeral key derives mixed shared secret start double ratchet algorithm allow sending data message directly dake subsequent encrypted message sent longlived secret ephemeral key material otrv window key compromise equivalent long take double ratchet refresh ephemeral key material ratchet including first compromised ratchet long prekey message remains unused prekey profile becomes expired recommend expiration client profile prekey profile week long window key compromise one week done offline conversation participant may receive message reply day week month time result window compromise kind conversation long limitation set set expiration reduce window compromise primarily two attack want mitigate active adversary modifies first flow initiator adversarially controlled prekeys ephemeral key capture drop response responder compromise initiator longterm secret key initiator never see message adversary able decrypt moreover since longterm key usually meant last year long time may pas responder sending message adversary compromising initiator key attack requires powerful adversary initiator responder complete exchange engage conversation point adversary capture drop message example initiator later adversary compromise initiator ephemeral secret revealing message key corresponding dropped message adversary retroactively decrypt captured message first attack mitigated xzdh xzdh signed shared prekeys relatively short expiration time result attacker would compromise secret part signed shared prekey expiration time along longterm secret key order able decrypt message second attack mitigated two way key dropped message skipped message kept period time alice example receives message bob received message alice derive key validate decrypt message message valid chain key derivation deleted message key kept case chain key message message deleted stored message key remain stored appropriate interval defined implementers trigger deletion partially defends second attack second fully defend attack session expired new ecdh key generated within certain amount time encourages key removed often cost lost message whose mac key cannot revealed example alice set session expiration time hour bob must reply within time alice must create response reply thus generating new ecdh key order reset session expiration time alice alice generate new ecdh key two hour alice delete key associated session receives message bob expired session cannot decrypt message thus cannot reveal mac key associated session time decided individually participant client possible alice expiration time two hour bob two week addition first data message receiver start expiration timer message received reason timer dont count event trying determine whether something happened within certain time frame thus timer compromised clock error error may cause session deleted early result undecryptable message received error may result clock moving forward would cause session never expire mitigate implementers secure reliable clock cannot manipulated attacker otrv spec give implementers guide determine amount time session expiration difficult dictate good general expiration time since many secure messaging scenario exist different security requirement session expiration essentially expiration last message readability deniability time setter either implementer user expect reply unreadable undeniable time example time set minute message received minute unreadable undeniable attacker must compromise local key within minute order read tamper last message sent time pass time set one month allows receiver reply within one month however client compromised within one month attacker able read tamper last message sent due usage double ratchet algorithm protocol correct way initializing noninteractive dake must taken consideration preserve security proof dake initial ephemeral key ring signature derivation first mixed shared secret key attached second noninteractive dake message noninteractiveauth message ratcheting ephemeral public key included phi value message format prekey message format protocol version short version number protocol message type byte message type prekey owner instance tag int instance tag client created prekey prekey owner ecdh public key point first part onetime prekey value prekey owner public key mpi second part onetime prekey value ephemeral public key note even though uppercase point prekey message uploaded untrusted prekey server along client profile prekey profile three value create defined prekey ensemble public part shared prekey signature essential implementing xzdh included published prekey profile signature shared prekey must published order deniable created participant long term key noninteractive auth message format protocol version short version number protocol message type byte message type sender instance tag int instance tag person sending message receiver instance tag int instance tag intended recipient sender client profile clientprof described section creating client profile point ephemeral public ecdh key mpi ephemeral public key note even though uppercase point sigma ringsig ringsig proof authentication value prekey message identifier int prekey message identifier prekey message retrieved untrusted prekey server part prekey ensemble auth mac mac mac appropriate mac key see message ring signature ringsig ourecdhfirstpublic ephemeral public ecdh key intialization double ratchet algorithm ourdhfirstpublic ephemeral public key intialization double ratchet algorithm multiple otr protocol version prekey message contain version information client expected upload one prekey per supported version otr noninteractive communication relevant otrv subsequent version publishing retrieving prekey emsembles prekey server describing detail interaction otrv client prekey server outside scope specification implementers expected create policy dictating often client upload prekey ensemble prekey server nevertheless client expected upload client profile prekey profile old one expired thus new client profile prekey profile published untrusted prekey server expire keep valid value prekey ensemble available client profile prekey profile published every longterm public key belongs user client mean bob client support otrv uploads three long term key otrv client bob client must publish client profile prekey profile also bob uploads two long term key otrv two long term key otrvx future version otr also implement noninteractive dake bob upload profile respectively requesting prekey ensemble prekey server client request prekey ensemble prekey server many prekey ensemble may returned example alice request prekey ensemble bob following may happen alice receives two prekey ensemble bob bob two otrv client one phone one laptop client maintains set prekey ensemble prekey server two prekey ensemble different instance tag meaning two client profile two prekey profile two prekey message different instance tag scenario therefore follow different path two prekey ensemble may client profile created different longterm key two prekey profile signed different key respectively point alice trust one key may decide send message client key trust alice trust key may decide send message one alice trust either key may decide send message may send message without validating key two prekey ensemble may client profile created longterm key prekey profile signed key key trusted alice may decide send message client instance alice may decide send message first prekey ensemble received alice trust key may decide send message send message instance without validating key alice receives two prekey ensemble bob different client profile instance tag prekey profile signed corresponding longterm key stated client profile validly happen bob client support two different version otr prekey ensemble longterm public key ensemble client profile different version longterm key client profile prekey message compatible alices version one prekey ensemble must invalid alice cannot know send message either prekey ensemble prekey ensemble version version supported alice longterm key different alice look whether trust key trust may send message trust one may decide send one message may send message untrusted key well trust neither may send message may decide send message one despite risk prekey ensemble version different alice support version alice may choose send message version one depending whether trust longterm public key key associated prekey ensemble version different alice support one send message prekey ensemble support longterm public key associated message untrusted may decide send message trusted may send message example possible situation two prekey ensemble received course many may received aid complexity specification includes guide filtering list given prekey ensemble remove invalid message identify invalid situation remaining message implementer guide validate prekey ensemble following check fail ignore message check instance tag prekey ensemble value validate client profile validate prekey profile check prekey profile signed longterm public key stated client profile verify prekey message stated section check otr version prekey message match one version signed client profile contained prekey ensemble check client profile version supported receiver one prekey ensemble received prekey ensemble valid decide whether send noninteractive auth message based whether longterm public key client profile trusted many prekey ensemble received remove invalid ensemble remove duplicate prekey ensemble list one prekey message remains decide whether send message prekey ensemble based whether longterm public key within profile trusted multiple valid prekey ensemble remain key untrusted trusted list message decide whether message contain trusted long term key several instance tag list prekey ensemble decide instance tag send message multiple prekey ensemble per instance tag decide whether send multiple message instance tag decreased participation deniability responder otrv make clear noninteractive conversation different lower participation deniability property responder interactive conversation otrv also leave implementer decide appropriate noninteractive dake convey security loss multiple dakes otr state machine currently decided one state machine receive multiple dakes machine following state start waiting authr waiting authi encrypted message finished state except finished state may receive second message noninteractive dake called noninteractiveauth prekey server run prekey ensemble server run prekey ensemble one value otrv expects client implementation wait prekey ensemble retrieved continuing noninteractive dake purposely different expect protocol like signal signal protocol prekey server run message default message new message uploaded consequence participation deniability technique currently undefined thus risky waiting prekey server send prekey ensemble otrv subject attack server compromised network undermined return prekey message available response server preferred possible compromise multiple noninteractive dakes due reuse prekey ensemble