raw arct pointer pas object across ffi proposed deciders mhammond rfkelly consulted travis jhugman dmose discussion approval technical story issue prototype problem statement uniffi currently manages object instance handlemap struct ffisupport crate mean external consumer uniffiwrapped interface never see pointer structs instead get roughly index array struct stored owned array number safety characteristic particularly important handwritten ffi interface cause issue evolving uniffi direction consider important addition slight performance overhead handlemaps make difficult support passing object instance argument getting object handlemap involves closure accepting multiple objecttyped argument would involve codegenerating nested closure returning object instance function returned object already exist handlemap handle manage lifetime multiple reference object restriction mean uniffis object type currently suitable self argument method call forbidden argument position record field etc adr considers way evolve handling object instance lifetime reference structs widely currently allowed driver desire ability flexible lifetime object interface stored dictionary interface returned function method constructor would like keep uniffi implementation simple possible providing suitable degree safety particular promise impossible misuse generated binding way trigger rust undefined behavior otherwise defeat rust safety characteristic ownership model particular avoiding thing like useafterfree issue would like keep overhead uniffi small possible viable solution usecases considered extend handlemap abstraction track lifetime support easier codegen would involve deciding want track lifetime via reference counting garbage collection actually building replace handlemapt raw pointer rust builtin arct replace handlemaps rust arc arcintoraw pas value foreignlanguage code arcfromraw receive back rust replace handlemapt raw pointer specialpurpose reference container replace handlemaps something like triomphearc specifically intended ffi code arcintoraw pas value foreignlanguage code arcfromraw receive back rust outcome chosen replace handlemapt raw pointer rust builtin arct taken believe additional safety offered handlemaps far important usecase code pointer generated instead handwritten correctly implementing better lifetime management threadsafe way trivial subtle error would defeat safety mechanism handlemaps offer ultimately wed end reimplementing arc anyway one stdlib far likely correct usability familiarity benefit stdlib arc rather specialpurpose container like triomphearc way currently codegen mean unlikely notice potential performance improvement specialized type positive consequence overhead generated code performance overhead cognitive overload much easier rationalize generated code actually work performs negative consequence error generated code might cause pointer misuse lead free type issue misuse generated apis may able create reference cycle rust object cannot deallocated consumer coming garbagecollected language may assume cycle collected pro con extend handlemap abstraction track lifetime support easier codegen good raw pointer arent handed anywhere bad reimplement safe reference counting garbage collection bad code generation likely remain somewhat complex overall dispreferred involve writing significant new complex code safety benefit quite marginal practice replace handlemapt raw pointer rust builtin arct good code generated uniffi clearer easier understand good reuse rust standard library confidence implementation bad handing raw pointer around mean bug generated code intentional misuse binding might cause vulnerability overall preferred achieves goal reducing performance overhead generated code cognitive overhead maintaining tool replace handlemapt raw pointer specialpurpose reference container good code generated uniffi clearer easier understand good reuse existing welltested container type like triomphearc good specialpurpose container type may performant default implementation rust stdlib bad handing raw pointer around mean bug generated code intentional misuse binding might cause vulnerability bad specialpurpose container may leak implementation uniffiwrapped rust code adding cognitive overhead consumer overall dispreferred due additional cognitive overhead consumer potential performance improvement seem likely lost amongst many source overhead current generated code may reconsider future profiling show stdlib arc bottleneck link thom discus bit issue agrees assertion raw pointer make sense relevant code generated ryan discus general approval approach issue adr