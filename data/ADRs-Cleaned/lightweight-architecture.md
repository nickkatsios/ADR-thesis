lightweight architecture proposed summary keywords lightweight iterative improvement inlined implementation testing production small scala aws lambda package size prefer direct inlined business logic abstracted indirection offtheshelf aws infrastructural facility instead bespoke implementation testing production via preconditionsprogrampostconditions instead mocked test prevent silent failure minimal custom abstraction zuora usage lightweight http json library vanilla scala design based observation lesson learned year various approach taken solve problem awszuora domain core idea minimalism tool abstraction indirection small scala aws lambda package size custom lambda library following vanilla scala snippet necessary define scala lambda scala object lambda def handlerequestinput inputstream output outputstream unit deserialise stream run program serialise stream importing web frameworkslibraries within lambda aws provides necessary facility outofthebox logging concurrency error handling etc many custom library necessary scala expressive language express concept vanilla facility something done couple line code import whole library prefer direct inlined business logic abstracted indirection generally speaking much algorithmically complicated logic business domain essentially http client json deserialiser request orchestration code able inline directly whole orchestration single file instead spreading many file library abstraction advanced feature place needed instead across whole system offtheshelf infrastructural facility instead reinventing wheel aws good documentation many example across open source github gdpr compliant setting infrastructure difficult largely onetime affair rarely change able look documentation example stack api gateway lambda import web framework implement custom router etc testing production via preconditionsprogrampostconditions instead mocked test favour runtime precondition postcondition testing production instead unit test mocked httpjson input tap precondition pipe program tap postconditions reserve unit test complicated business logic algorithm plumbing issue malformed json wrong http request orchestration likely surface quickly deployment long alarming setup thus roi unit testing aspect likely worth runtime preconditionspostconditions code alongside main business logic harder ignore lower maintenance cost relative unit test prevent silent failure multiple case silent failure introduced handling error technique swallow error without error logging wiring non response failing fast unrecoverable error hook aws outofthebox error logging alarming minimal cost automatic error recovery possible system cannot proceed fail slow automatic error recovery selfhealing etc difficult achieve ideal usually possible zuora due nature zuora outage hour long error handling cannot meaningfully addressed technique unit level instead addressed much higher infrastructural level sqs step function etc error recovery possible actually modelled error simply path system try minimal custom abstraction zuora work whitelisting opposed blacklisting principle system detects scenario cannot handle immediately notify developer make adjustment instead trying predict zuora model upfront handle imaginable scenario modelling zuora successful last five year due way guardian countless exception model instead zuora directly way document mean essentially rest api level favor precondition postconditions check done right thing invoice look correct production mutation opposed predicted model capturing way invoice generated corresponding mocked unit test zuora hard enough understand without developer putting another layer top usage lightweight http json library vanilla scala scala expressive language many concept directly implemented without depending external library json http boring sophisticated library even worse reinventing yet another custom implementation special logging config library aws provides outofthebox scenario require advanced techniqueslibraries technique necessary isolated segment codebase consequence argument silent failure subsecond aws lambda warmup lower maintenance cost easier lookup documentation easier onboard developer testing real data instead mocked data quicker build force developer stop ignoring alarm argument crucially depends developer responsibly reacting upon receiving alarm pending