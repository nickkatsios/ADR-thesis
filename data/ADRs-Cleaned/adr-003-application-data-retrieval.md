adr retrieving application message changelog initial draft adr build top adr implemented apis described reader familiarize least highlevel concept well spec academic paper describes motivation api main motivation quoted section paper property application message retrieval partitioning client node must able download message relevant application without needing downloading message application property application message retrieval completeness client node download message relevant application must able verify message received complete set message relevant application specific block omitted message main data structure enables property called namespaced merkle tree nmt ordered binary merkle tree node tree includes range namespaces message descendant node leaf tree ordered namespace identifier leaf message formal description found specification implementation found repository adr basically describes version getwithproof nmt leverage fact ipfs content addressing implemented ipld plugin nmt note apis defined particularly relevant optimistic rollup full node want download rollups data see celestiaorgoptimint another potential usecase api could socalled light validator node want download replay staterelevant portion block data transaction reserved namespace alternative approach approach described rely ipfs block exchange protocol bitswap dht ipfss implementation black box find peer serve requested data likely much slower potentially could first implementation intentionally incorporate optimization could briefly mention potential optimization future graphsync instead bitswap ipld selector expose api able download application specific data namespace including proof minimal number roundtrips finding node expose rpc endpoint like getwithproof discussion particular api happened either call nondocumented way describe section decide implement simplest approach first first describe protocol informally explain fulfils property property section case leaf requested namespace exist basically boil following traverse tree starting root finding first leaf start namespace question directly request download leaf coming start namespace change greater requested one case leaf requested namespace exist tree traverse tree find leaf position tree namespace would download neighbouring leaf pretty much provenamespace method ipfs simply locate request leaf corresponding inner proof node automatically downloaded way detailed design define one function return share block belonging requested namespace block via block data availability header see computeshares reference encode block data namespace share retrieveshares return raw data raw share passedin namespace nid included block dataavailabilityheader dah func retrieveshares ctx contextcontext nid namespaceid dah typesdataavailabilityheader api coreifacecoreapi byte error find row root contains namespace nid traverse corresponding tree according informally described algorithm get corresponding leaf return raw share corresponding nid additionally define two function first one return parsed nonpadding data reserved namespace transaction intermediate state root evidence return application specific blob share belonging one namespace parsed slice message specification code latter two method might require moving exporting currently unexported function currently live sharemerginggo could implemented separate pull request retrievestaterelevantmessages return staterelevant transaction transaction intermediate state root evidence included block dataavailabilityheader dah func retrievestaterelevantmessages ctx contextcontext nid namespaceid dah typesdataavailabilityheader api coreifacecoreapi intermediatestateroots evidencedata error like retrieveshares reserved namespaces additionally share parsed merged corresponding type return argument retrievemessages return message passedin namespace included block dataavailabilityheader dah func retrievemessages ctx contextcontext nid namespaceid dah typesdataavailabilityheader api coreifacecoreapi message error like retrieveshares additionally parsed share message type proposed consequence api likely rollups document properly move together relevant part adr separate gopackage positive easy implement existing code see adr resilient data retrieval via network dependence mature welltested codebase large welcoming community negative ipfs inherit fact potentially lot roundtrips done data fully downloaded word could end way slower potentially possible anyone interacting api run ipfs node neutral optimization happen incrementally initial working version reference weve linked reference throughout adr