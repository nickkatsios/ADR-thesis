targeted sweep legacy sweep achieve transactional guarantee atlasdb maintains historical version cell written eventually existing future transaction start timestamp large enough historical version never visible resulting unnecessary cruft issue due taking storage space underlying also certain access pattern require scanning obsolete historic version leading significant performance degradation time process removing old historic version cell table atlasdb called sweep refer current implementation sweep atlasdb relying legacy sweep legacy sweep iterative procedure given table reference start row sequentially scan historic version cell searching candidate written transaction start timestamp commit timestamp lower sweep timestamp sweep timestamp timestamp expected lower start timestamp open transaction rendering last historic version cell prior sweep timestamp effectively invisible thus obsolete version therefore safely deleted legacy sweep continues scan enough candidate found processing least one full row cell deletes obsolete historic version two main mode running legacy sweep background sweep background task repeatedly chooses table sweep proceeds run iteration sweep row processed manual sweep triggered rest endpoint cli perform iteration full sweep given table start row note corner case sweep timestamp may mistaken readonly transaction running longer one hour also subject clock drift write transaction loses lock committing table allow readonly transaction must therefore defensively write garbage deletion sentinel empty value timestamp valid start timestamp readonly transaction encounter sentinel signalizes could historic version able read may deleted transaction must therefore abort table allows readonly transaction therefore requires sentinel defined table sweep strategy conservative allows readonly transaction requires sentinel thorough time identified number issue architecture implementation legacy sweep outlined legacy sweep slow even table historic version cell swept still scan historic version cell table take week extreme case performance get worse data written increasing number entry legacy sweep must iterate particularly large problem user table whose access pattern mandate must swept regularly performance stability reason background sweep busy week sweeping large table must resort manual sweep avoid performance stability degradation obviously errorprone subject random failure since manual sweep interrupted reason automatically retried moreover legacy sweep depends complicated heuristic decide table sweep next given table must swept frequently slowness legacy sweep significant developer time must spent tweaking heuristic produce desired effect legacy sweep exert significant pressure underlying scanning table find historic version cell case cause significant pressure underlying particular cassandra even though interested start commit timestamp transaction writes performed understanding cassandra internally still load content cell memory regardless legacy sweep get stuck table regularly new row added increasing lexicographical order example table keyed steadily increasing fixed varlong legacy sweep end sweeping table indefinitely iteration discover new row therefore never declaring table fully swept consequence table swept issue noticed manually resolved problem legacy sweep architectural cannot solved simply improving implementation therefore decided change architecture sweep require scanning table find candidate delete instead maintains sweep queue contains information writes atlasdb conjunction ranged tombstone ranged deletion delete version cell two timestamps allows sweep table parallel without read data table swept note time writing adr cassandra implementation ranged tombstone actually avoids reading table targeted sweep targeted sweep queue targeted sweep queue persisted queue containing relevant metadata write committed atlasdb metadata encapsulated writeinfo object contains following tablereference table written cell written row column name start timestamp transaction performed write flag specifying write tombstone delete regular write high level sweeping targeted sweep queue targeted sweep follows whenever transaction commit writes persisted writes put corresponding writeinfo queue targeted sweep read entry front queue depending sweep strategy table specified entry acquire appropriate sweep timestamp compare start timestamp transaction sweep timestamp start timestamp must pause try later check commit timestamp transaction transaction committed abort transaction aborted delete write pop queue read next entry transaction committed timestamp greater equal sweep timestamp pause try later otherwise insert ranged tombstone follows strategy conservative write garbage deletion sentinel put ranged tombstone deleting version cell write timestamp deleting sentinel write strategy thorough write tombstone put ranged tombstone deleting version cell write timestamp deleting potentially existing sentinel write otherwise put ranged tombstone deleting version cell write timestamp deleting potentially existing sentinel write pop queue read next entry detailed implementation targeted sweep targeted sweep queue refer implementation section consequence benefit targeted sweep perform sweep several order magnitude time faster legacy sweep verified cassandra far load underlying significantly reduced verified cassandra far order sweeping fair suffer issue caused frequently appending new row end table drawback added overhead committing transaction information must persisted sweep queue part commit note caused significant regression benchmark implementation since assume thread may die moment implementation detail correct ordering crucial describe targeted sweep schema define necessary term fine timestamp partition timestamp divided integer division fine timestamp partition write fine timestamp partition start timestamp transaction wrote coarse timestamp partition analogous fine partition except number divided sweep strategy tablelevel property specifying sweep timestamp calculated deletion sentinel whether latest write swept away well case delete also sharding strategy enable better parallelisation targeted sweep maximum number shard supported effectively splitting queue number disjoint queue note number shard increased cannot lowered sweepable cell table table store actual information writes atlasdb transaction committed data persisted writes transaction partitioned based shard sweep strategy table fewer writes partition persist necessary information number cell nondedicated row row component calculated described writes partition insert single cell nondedicated row acting reference one dedicated row exclusively writes transaction partition row component timestamppartition varlong derived start timestamp writes row nondedicated row fine timestamp partition dedicated row start timestamp metadata byte blob encoding targetedsweepmetadata follows bit sweep strategy thorough conservative bit marking dedicated row nondedicated dedicated bit shard number inclusive bit dedicated row marking ordinal number inclusive bit unused note row component hashed avoid hotspotting column component timestampmodulus varlong storing start timestamp write modulo writeindex varsignedlong whose purpose overloaded case storing fewer writes row writeindex nonnegative increasing number deduplicate multiple writes start timestamp storing writes instead put single cell nondedicated row acting reference one dedicated row case writeindex negative number indicating many dedicated row dedicated row contain cell dedicated row writeindex deduplication since entry row timestampmodulus value writereference containing remaining required metadata targeted sweep tablereference cell boolean specifying write tombstone since persisted size cell object byte dominating size entry expect transaction per row allowing writes transaction row size one nondedicated row exceed practice lower note could technically full transaction row probability exceeding value infinitesimal allow maximum entry per dedicated row ensures dedicated row larger still allowing million writes single transaction practice even long number shard greater note cell nondedicated row calculate writes start timestamp simply multiplying timestamppartition adding timestampmodulus sweepable timestamps table auxiliary table locating next row sweepablecells table read since timestamp partition sparse therefore requiring many lookup locate nonempty row nondedicated row sweepablecells represented single cell table row component shard varlong containing shard row entry timestamppartition varlong corresponding coarse timestamp partition entry row sweepconservative boolean encoded blob specifying row contains entry thorough conservative sweep column component timestampmodulus fine timestamp partition row sweepablecells fall coarse partition specified timestamppartition row component value unused empty byte array locate first row sweepablecells entry timestamp start row sweepabletimestamps corresponding coarse partition read first column great enough timestampmodulus increasing row necessary cell found way timestampmodulus timestamppartition row sweepablecells looking sweep progress per shard table table store targeted sweep progress well information number shard sweep queue row component shard varsignedlong containing shard tracking progress sweepconservative boolean encoded blob specifying looking conservative thorough sweep sweepabletimestamps named column value varlong containing timestamp targeted sweep swept shard strategy persist number shard sweep queue distinguished row table row defined shard sweepconservative true note writes table atomic check set value allowed increase request update cell lower value effect writing sweep queue whenever snapshottransaction commit writes persisted enqueues sweep queue sweep queue creates list writeinfo containing relevant information partition list according sweep strategy table information read table metadata cached number shard sweep queue shard determined hash tablereference cell partition put entry sweepabletimestamps table start timestamp transaction finally partition put writeinfo sweepablecells table fewer entry list write many cell table row column component calculated described writeindex starting increasing entry entry list put single cell table acting reference dedicated row row reference writeindex negative number absolute value equal number dedicated row number writes divided rounded put cell dedicated row timestamppartition start timestamp transaction fine partition metadata encodes row dedicated row row ordinal number rest note entire start timestamp timestamppartition dedicated row avoid clash case nondedicated row multiple reference dedicated row reading sweep queue reading sweep queue done order writing given shard strategy minimum exclusive timestamp targeted sweep read sweepprogresspershard table described later maximum exclusive timestamp targeted sweep sweep timestamp following want locate fine timestamp partition first row sweepablecells entry greater minimum exclusive timestamp mint starting coarse partition mint getrowscolumnrange check cell sweepabletimestamps satisfying condition increase coarse partition repeat either candidate found coarse partition grows larger coarse partition maxts maxts maximum exclusive timestamp latter occurs guaranteed entry sweepablecells shard strategy timestamps specified range otherwise fine timestamp partition effectively reference row sweepablecells expected contain least one cell may true degenerate case thread writing cleaning queue process read cell row start timestamp greater last swept timestamp referring dedicated row necessary either finish row exceed maxts read entry plus additional entry ensure read entry start timestamp latest one cleaning sweep queue entire nondedicated row sweepablecells row sweepabletimestamps needed anymore remove follows given shard strategy fine timestamp partition delete entry sweepablecells corresponding row note cassandra entire row deleted single tombstone first read nondedicated row find reference dedicated row delete delete nondedicated row necessary given coarse timestamp partition also delete row defined shard strategy coarse timestamp partition sweepabletimestamps targeted sweep implementation targeted sweep read write metadata sweep queue instead sequentially scanning table find historic version entry read sweep queue check commit timestamp transaction performed write start timestamp commit timestamp lower sweep timestamp single ranged tombstone delete prior version cell note cassandra implementation deletealltimestamps method writes ranged tombstone require reading information therefore provides substantial improvement comparison legacy sweep find previous timestamps deleted one one commit timestamp greater sweep timestamp targeted sweep must wait sweep timestamp increase enough entry processed generally issue since likely happen targeted sweep processing writes written within last hour targeted sweep number background thread strategy controlled install config continuously cycling shard find next shard sweep thread request timelock lock shard strategy successful start iteration targeted sweep otherwise request lock next shard finally giving pausing cycle unsuccessfully shard mechanism ensures synchronization across multiple node service assuming thread successfully acquired lock following calculate sweep timestamp sweep strategy read last swept timestamp shard strategy sweepprogresspershard get batch writeinfo sweep queue read sweep queue described mint last swept timestamp maxts sweep timestamp find candidate skip step start timestamps batch check transaction committed must abort behaviour legacy sweep transaction committed sweep timestamp must progress targeted sweep past start timestamp remove writes greater start timestamps batch delete writes referenced aborted transaction note direct deletes ranged tombstone partition remaining writeinfos cell tablereference take greatest start timestamp partition one ranged tombstone per partition writes cell table batch going lower start timestamp therefore going deleted well strategy conservative write garbage deletion sentinel put ranged tombstone deleting version cell write timestamp deleting sentinel write strategy thorough write tombstone put ranged tombstone deleting version cell write timestamp deleting potentially existing sentinel write otherwise put ranged tombstone deleting version cell write timestamp deleting potentially existing sentinel write new sweep progress described greater detail guarantee minimum start timestamp swept future greater fine coarse partition previous last swept timestamp clean sweep queue accordingly previously explained persist sweep progress sweepprogresspershard shard strategy finally regardless success failure iteration unlock timelock lock shard strategy schedule next iteration sweep thread delay second calculating sweep progress wish update progress greatest value guarantee swept multiple case consider order find candidate row sweepablecells reading sweep queue update sweep timestamp none timestamps batch committed sweep timestamp read entry sweepablecells sweep timestamp update minimum sweep timestamp first timestamp would written next row sweepablecells otherwise update greatest timestamp among writes batch