layout default title adr navorder permalink record json web token jwt authenticating interservice api request drafted deciders sul infrastructure developer drafted problem statement sdr implemented way many different discrete service make network request work example present argo call preservation catalog retrieve computed checksum file content retrieve actual preserved file content many different service dorservicesapp read write operation digital repository object course want make sure client network service since access limited authorized caller past accomplished primarily network access restriction firewall whitelisting service access limiting access client inside vpn etc however sole approach deprecated industry large stanford uit particular though still important component security driver want secure access api endpoint uit want secure access api endpoint would like approach thats relatively easy understand maintain considered gate access service authenticated client allowed connect rejecting client request dont inclue valid auth token specifically service access controlled application serving api endpoint able mint signed json web token token generated per jwt standard thus one thats minted consist delimited section base encoded json header metadata token including hash algorithm signing alg field token payload consist base encoded json hash sub subject field containing name application token minted signature generated strong hmac algorithm hmacsha hmacsha writing encode concatenated delimited header payload base encoded securely generated stored secret sufficient length detail provided link section particular secret generation brief probably generate secret least length hash output least bit byte hmacsha least bit byte hmacsha easy way run rail secret since return random byte hex value service access controlled look authorization http header request token protected resource header value form bearer token token token minted particular calling service token validated decoding verifying signature portion corresponds combination token headerpayload protected server signing secret signing hash algo client application access token protected application developer generate new token client application protected application see link section concrete example warning like signing secret token protected service generated token treated private configuration value made public might allow unauthorized client pretend legitimate caller note likely there library handy language generating validating jwts without implement ruby jwt gem provides jwtencode method take payload hash secret value string name hash algorithm string decode counterpart method token reading validation specific client token compromised two revoking rotate server signing secret effectively invalidate client token require new token minted new signing secret security situation urgent probably safest expedient approach implement blacklist functionality protected application reject specific token either payload content token value route taken make sure implementation well tested please add link bottom doc server signing secret compromised signing secret must rotated client token must regenerated new secret basic jwt approach lead automatic token expiry though standard doesnt preclude token expiry note api route application may opted token protection resque sidekiq dashboard meant human access instead protected shibwebauth jwts see preservationcatalog validation link end example implementation seriously discussed another approach also cryptography prove client identity would authentication via client certificate fedora current digital repository backend approach client application would generate publicprivate key pair public key would registered server access desired thus client private key could prove identity decrypting protected service challenge protected service encrypted client public key ecosystem likely easier implement jwt based approach concise pattern rubyrails jwt based approach completely adequate proving caller identity assuming guideline secret selectionstorage hash algo choice followed outcome infrastructure team came consensus weekly planning meeting going forward gate access api endpoint jwts minted service provided request client adr meant capture flesh positive consequence robust circumventable restricting access solely way network firewall configuration preclude keeping appropriate firewall restriction remain part security practice network reconfiguration result accidental loosening firewall restriction token based authentication provides robust additional line access control way weve built application token based authentication least easy implement maintain client certificate based authenication provide similarly adequate security minting token become common approach industry authenticating client access apis wealth current information advice available online practice negative consequence work developer solely relying firewall rule network configuration task typically fall operation happen anyway link glossy collection jwt introductory resource jwt rfc concise wikipedia entry explaining structure implementing library possible shortcoming jwtbased auth choosing secret hmac algorithm useful post useful stack exchange thread archiveorg link section hmac rfc provides meat concise useful answer thread example implementation dorservicesapp current documentation token minting code token validation code example implementation preservationcatalog current documentation token minting code token validation code coordinating github ticket comparison overview somewhat different jwt based authenticationauthorization approach party identity provider amazon cognito issue jwts expire signedvalidated identity provider privatepublic key token issued human user behind scene browser upon successful usernamepassword login sinopia editor note approach illustrates jwts facilitate granular authorization whats described