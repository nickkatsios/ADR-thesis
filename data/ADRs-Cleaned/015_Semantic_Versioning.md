semantic versioning dependency deciders gabriel birke abban dunne corinna hillebrand problem statement way deploy specific version bounded reproducible release software testing production driver want frequent release software adding new feature etc want keep dependency monthly basis composer update want reproducible version software composer install must install code machine developer machine user acceptance environment production environment want trunkbased development process current master repository always working deploy time regularly update wmdefundraisingfrontendcontent dependency considered rely composerlock pinning current dev version bounded semantic versioning bounded outcome semantic versioning month period well evaluate actual benefit drawback semantic versioning drawback outweigh benefit cant fix mean automation well abandon semantic versioning return trunkbased dependency pro con semantic versioning bounded create new version tag whenever want new master bounded update dependency fundraisingfrontend afterwards follow following logic deciding part version increase major database change change public api constructor nonoptional method parameter minor adding new method optional parameter public api patch bug fix dont change public api fundraisingfrontend foc code full version number version selector instead force consciously increase minor version whenever add new feature bounded still check composerlock file keep software version stable composer install good version number increase show rapidly bounded changing good easier roll back previous version good composer validate become part continuous integration longer throwing unbound version constraint dev error good situation bugfix release already merged feature case backport fix new patch version good tag annotation act change log good create bugfix release bounded omit feature commits replace development feature flag case bad well add release almost every change make bounded creating additional work tagging release updating version consuming application bad harder develop feature two parallel repository application change version bounded development branch feature get create new release bounded change dependency back new release number without safeguard process risk accidentally keeping development branch dependency rely composerlock pinning version bounded weve last year keep version specification bounded dev whenver change bounded wmdefundraisingfrontendcontent repository composer require contextnamedev update specifically composer update caution avoid pulling change bounded arent ready yet good fit development model good encourages developer communication bad accidentally pull unwanted change composer update link versioning may become unnecessary integrate fundraising app fundraising operation center see adr