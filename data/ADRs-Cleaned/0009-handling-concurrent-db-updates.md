handling concurrent update two feed court case data libra common platform send data way result concurrent database update leading error libra list court case received batch specified time throughout day practice quite often see multiple update case coming either payload quick succession effect multiple update case processed courtcaseservice within millisecond lead raceconditions updating record causing persistence fail request retried common platform individual update case received real time throughout day frequently see multiple update case coming immediate succession leading issue seen libra data prior adr adopted common failure saw result concurrency optimisticobjectlockingexceptions thrown change happens reading state object subsequently saving dataintegrityviolationexception thrown attempted update violates database constraint specifically offendermatchgroupuq compound key defendantid caseid must unique give offender match group neither fatal error within larger system courtcasematcher retry failed request retries generally succeed frequency issue definite problem though alert channel rife error potentially obscuring serious issue though courtcasematcher also retry failed http call decided retry within courtcaseservice known recoverable exception also preferable updating alerting filter exception alternative isnt really dealing underlying problem apply transactionalisolation isolationrepeatableread force transaction acquire lock attempting update see doc isolation level acquisition fails cannotacquirelockexception thrown though prevent transaction failing first place provide guarantee database level mechanism bad update applied also lock required beginning transaction fail fast rather query portion transaction falling save currently apply retryablevalue cannotacquirelockexceptionclass conjunction allow recovery failed transaction caused concurrent update lock could acquired application fails get lock simply try second conflicting transaction hopefully completed apply retryablevalue dataintegrityviolationexceptionclass catch instance failure happen result two new record compound key created concurrently differs first failure mode cannot guarded row level lock conflicting row causing failure exist transaction started code check existing record prior creating new one retry update conflicting record rather attempting create new one consequence fewer alert possibility time new issue arise resulting novel issue caught mechanism error risk happening however low given tight constraint error handling fact retrying valid case exception anyway retry fails resolve issue request fail fatal error still caught adr address problem concurrent update address issue ordering receiving request close succession real possibility applied order something currently solution applies larger scope courtcaseservice