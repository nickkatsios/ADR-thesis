geoprocessing caching geoprocessing call large shape take long time complete user draw custom shape also pick list predefined shape system geoprocessing shape multiple user select wasteful unnecessary caching geoprocessing result predefined shape well known area interest wkaois improve user experience application performance outside geoprocessing also database call much faster comparison likely see significant improvement caching especially since cache could table database adr consider following question cached cached cached cached cache invalidated also sketch implementation plan consider consequence sideeffects cached output geoprocessing service wkaois cached almost always json blob keyvalue pair key combination overlaid cell value set raster value count cell input geojson shape set related argument specify raster operation type etc could cache entire output mapshed run update constituent raster vector data would force recalculation whole caching timeconsuming geoprocessing result ensure update constituent raster would invalidate specific cached result leaving others still current since vector data result would never cached always current upon update well case mapshed modification change geoprocessing query thus request cached easily modification change geoprocessing query case cache current condition modificationless run scenario since storing arbitrary shape balloon size cache quickly may revisited future case foresee updating raster often may beneficial consider caching entire json response api cached current stack already django caching setup allows cache single line code python djangocorecache import cache cachesetkey value none key unique identified consisting wkaoi geoprocessing operation value result geoprocessing operation none timeout value ensures value dont ever expire retrieval simple python value cachegetkey value calculate cache value return value key prefixed geop namespace cache entry app composed wkaoi consists table name integer geoprocessing operation name example geopboundaryhucnlcdsoils practice key may actually something like geopboundaryhucnlcdsoils configurable appwide prefix default version number prefixed key however long always access cache via djangocorecachecache shouldnt worry cached django caching framework configured number cache backends including redis database currently setup redis elasticache production advantage redis already configured allows take advantage django caching framework configured redis redis really fast good candidate storing keyvalue pair like intend designed cache thus come mechanism timeout lru cache miss box disadvantage redis case system failure cached value lost cached purge least recently value might good candidate storing hardtoprocess large wkaois rarely cached user selects wkaoi request made analyze modeling wkaoi result havent already cached run cache time build cache new user request wkaois get cached result cached celery task calculation would otherwise happen select wkaois large process production infrastructure hucs timeout mapshed gathering phase run geoprocessing step powerful infrastructure longer timeouts batch process cache result decommission make available regular user production app without needing extra power render purpose well pair new django management command first run geoprocessing step given wkaois save result file run super environment second take file preprocessed result given shape operation add cache run production environment cache invalidated since every cache entry tagged type certain raster updated remove related cache entry example update uspercentslopemepsg raster nlcdslope slope request could simply run python cachedeletepatterngeopnlcdslope cachedeletepatterngeopslope refresh specific shape could python cachedeletepatterngeopboundaryhuc could management command well implementation plan see geoprocessing currently done via summaryjob done via mapshedjob consistency rewrite geoprocessing bit mapshedjob instead split nlcdsoilcensus three request nlcd soil nlcdsoil first two analyze much faster second modelingtr update geoprocessing submodule take geojson shape wkaoi geoprocessing type return output update celery task django view geoprocessing submodule new interface add caching support geoprocessing submodule geoprocessing done two part start finish case cache hit signal passed start finish instructs fetch value cache instead sjsretrieve update send wkaoi instead geojson predefined shape rwd user defined shape still sent geojson consequence make worst case scenario cache miss slightly longer currently well checking cache actual geoprocessing case elasticache failure cache would rebuilt large wkaois processed outofband may get pushed cache cache exceeds maximum size user defined shape still cached runtime improved since longest time taking activity geoprocessing fetching tile adding network cache may help improve runtimes