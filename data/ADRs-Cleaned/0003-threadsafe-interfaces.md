let consumer opt handlemap locking interface threadsafe deciders rfkelly jhugman mhammond dmosedale problem statement uniffi currently coarse locking strategy managing concurrent access object instance caused accidentally ship code product blocked main thread network enable finergrained concurrency control order provide desired api key consumer currently every interface corresponding ffisupportconcurrenthandlemap responsible owning instance interface handing reference mutabilitysafe threadsafe manner ensures generated code safe face concurrent operation substantial runtime cost one method call executed instance time attempt call object method concurrent method already executing block previous call completed desired api project nimbus includes method called synchronously main thread hence must block network disk api cannot built uniffi currently implemented driver enabling consumer control potential blocking behaviour generated apis ensure safety generated code ship solution timely manner unblock project nimbus considered nothing require consumer assume method call might block let consumer mark interface definition threadsafe opt lesslocking handlemap insist interface threadsafe replace handlemap raw pointer lesslocking handlemap rely calling code behave safely outcome chosen let consumer mark interface definition threadsafe opt lesslocking handlemap choice come safety simplicity making moreconcurrencyfriendly handlemap maintain current strict enforcement rust mutabilitysafety threadsafety guarantee even face error generated binding seems relatively small change making optin avoid creating busywork consumer urgently facing problem one downside consumer optin fix meaning default behavior may still surprising new consumer well mitigate doc consider revisiting default behaviour majority consumer adopt new approach choice also punt potential performance improvement future work seems keeping project lifecycle pro con nothing require consumer assume method call might block make change uniffi instead accept fact method call executed serially document limitation work consumer update api definition account good ship quickly good dont give safety guarantee current approach bad make basically impossible meet one key early consumer would force awkward compromise around suboptimal api bad make uniffi attractive potential future consumer bad keep runtime overhead handlemap bad default behaviour still hidden mutex might nasty surprise future consumer way nimbus ultimately want uniffi tool help consumer deliver value something foist limitation upon make unattractive let consumer mark interface definition threadsafe opt lesslocking handlemap implement variant concurrenthandlemap protect member mutex main source constraint concurrent execution current setup instead handlemap would give immutable reference member would insist member send sync safely accessed multiple thread introduce new annotation udl interface definition declared threadsafe generated rust scaffolding new handlemap threadsafe interface keep existing concurrenthandlemap default good relatively small change current behaviour fairly quick ship good nonbreaking change consumer dont opt good sync send bound underlying struct help consumer implement finegrained concurrency control supported rust compiletime guarantee good consumer dont care discover finegrained locking good leaf door open improvement like future decide make sense later bad keep runtime overhead handlemap bad maintain two handlemap variant bad default behaviour still hidden mutex might nasty surprise future consumer way nimbus solution ultimately selected insist interface threadsafe replace handlemap raw pointer stop concurrenthandlemap intermediate object access instead put object instance box boxintoraw transfer ownership box foreign language code raw pointer maintain safety insisting struct implementing udl interface must sync send refusing hand mutable reference boxed instance good remove issue potential footgun consumer good sync send bound underlying struct help consumer implement finegrained concurrency control supported rust compiletime guarantee good likely reduces runtime overhead give small performance boost bad breaking change consumer even dont care issue bad increase amount unsafe rust emit generated scaffolding bad lose additional runtime check provided handlemap guarding passing handle belongs different datatype bad nontrivial departure current approach take time seems like promising longerterm especially find majority consumer opting fix proposed adr additional complexity weight heavily trying ship initial fix project nimbus lesslocking handlemap rely calling code behave safely implement variant concurrenthandlemap protect member mutex main source constraint concurrent execution current setup instead handlemap would hand reference without runtime check assumption calling code behaving safe manner replace currently concurrenthandlemap new lesslocking variant good relatively small change current behaviour fairly quick ship bad lost rust compiletime safety guarantee bad hard communicate consumer behave safely really mean might even understand seems throw away key safety benefit rust make unattractive implementation sketch add threadsafe attribute udl interface definition would advise nimbus sdk update udl definition nimbusclient like idl threadsafe interface nimbusclient existing method definition remain unchanged uniffibindgeninterfaceobject struct would grow corresponding boolean threadsafe field corresponding public accessor building instance struct udl would inspect list attribute look one named threadsafe set field present way handle byref annotation method argument likely serve good example follow implement lesslocking handlemap variant ffisupport crate provides basic nonlocking handlemapt struct implement concurrenthandlemap thin wrapper around rwlockhandlemapmutext make variant remove inner mutex thin wrapper around arwlockhandlemaparct outer rwlock still needed order guard mutation handlemap arc needed quickly clone reference release lock calling potentiallylongrunning method reference bikeshed name lesslockinghandlemap implemented uniffiffi module live uniffi crate generated rust scaffolding runtime dont support entire concurrenthandlemap interface insertwithoutput insertwithresult callwithoutput callwithresult deleteu lesslockinghandlemapt struct capable handing reference never hand mut also require send sync lesslockinghandlemap rust scaffolding threadsafe instance objecttemplaters check threadsafe property object definition true lesslockinghandlemap instead concurrenthandlemap lazy static declares handlemap interface ensuring lesslockinghandlemap concurrenthandlemap expose similar api hopefully fairly minimal ifthenelse chooses correct name struct optional add blocking annotation method function moved followup issue ref link fenix bug large regression mainview start proofofconcept experiment raw pointer rather handlemap final implementation adr