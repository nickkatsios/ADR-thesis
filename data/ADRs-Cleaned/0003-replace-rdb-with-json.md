replace postgres rdb json point repeated discussion within development team whether relational database appropriate persistence author product graphql specification documentation associated library prescribe one best method persistence data rather suggest thinking graphql abstraction layer wrapped around type backend persistence early stage development author product taken start relational database served well point time database specific code api added complexity api made requirement difficult implement ought example feature include duplication moving ordering team new requirement implement permission model around author questionnaire data due relational nature data model estimate order check author permission perform mutation one lower level relational tree say update validation rule several join would happen get back root data model questionnaire permission could checked moreover check would likely happen every request resulting increased complexity another motivating factor revisiting persistence mechanism current inability easily port questionnaire environment present isnt easy way taking questionnaire built one environment preprod migrating data another environment localdevtestprod reason one primary reason database autogenerated make difficult ingest data environment data would migrated many table successfully motivation hope making change make easier make change api going forward complexity code maintain easier write test functionality tested unit test pure function easier move data environment example preprod prod easier implement permission checking easier keep versioned history change restore point time cheaper run cloud infrastructure serverless overall performant portable migrate another cloud provider require significantly call datastore per request also believe see improvement cypress test execution time since possible load questionnaire preconfigured state rather build scenario test taken refactor api json document database persistence mechanism initially implementation focused targeting dynamodb ability run application locally either inmemory containerised local dynamodb instance however striving become dependent one cloud provider thin layer integration dynamo rely reading mutating inmemory json document part consequence benefit making change believe see benefitsimprovements following area making change performance improvement single read operation query single write operation mutation simplified duplication logic simplified orderingmoving logic simplified author validation logic could leverage json schema validation simplified code base probably delete api code repository data entity migration etc since would longer rely numeric autogenerated database allow provide humanreadable url noted important analytics ability support pointintime restore data assigning schema change new version risk mitgations large change api main risk delivery ensuring functionality andor data lost part change plan mitigating risk ensuring keep high level test coverage particularly around api main contract backend ensuring test data migration thoroughly dev environment switching new mechanism preprod prod environment team aim unblock development task soon possible seek merge code back master soon stable sufficient test coverage expect code suboptimal beginning committed improving time subsequent pull request