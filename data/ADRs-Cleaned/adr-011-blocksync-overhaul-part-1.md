adr block data sync overhaul part storage changelog initial unfinished draft first finished version fixing missed gap author wondertan start like writing adrs stepbystep also trick help imagine like talking dev joined team onboard glossary light node full node bridge node edsextended data square plain block data omitting header block metadata original data square first quadrant contains real user data padding nmt namespaced merkle tree datahash hash commitment daheader quo current block data synchronization done bitswap traversing nmt tree row column data square quadrant know empirical evidence take second network request download block share unacceptable must much block timesec dasing hand show acceptable metric block size aiming initially case block operation take technically blocking request ideal scenario excluding disk getting data namespace also improved time take currently lie blocksync dasing data equal request time fulfill request mini node offsite berlin facilitate speed resolution problem decided make team gathering berlin four day help preliminary preparation wondertan guest willscott able find solution day match following requirement sync time block timeideally subsecond data namespace block timeideally subsecond pragmatic timeframe done incentivized testnet dont time redesign protocol scratch keep bitswap suffices solves data withholding attack existing bitswap logic kept fallback mechanism case reconstruction light node keeping random hashaddressed access share bitswap work adr intends outline design block data storage nutshell car format dagstore extended block storage custom reqresp protocol block data syncingwhole block data namespace happy path portion document come subsequent part document key design fnsbns store eds serialized car file car format provides efficient way store merkle dag data like nmt pack dag data single blob read sequentially one read transferred wire additionally carv introduces pluggable index blob allowing efficient random access share nmt proof one read index cached memory fnsbns manage toplevel index hash car block file mapping current dasing lns requires fnsbns serve simple hash data request toplevel index map sharenmt proof hash block carv file fnsbns quickly serve request fnsbns address eds datahash alternative height however allow block data deduplication case eds equal couple data layerpkg header layerpkg fnsbns run single instance dagstore manage car block file dagstore provides toplevel indexing carvbased indexing per car file essence engine managing car file indexing convenient abstraction tool recovery mechanism etc eds carv file carv carv encodes index file dagstore maintains carvbased indexing usage carv keep one copy index storestransfers metadata per simplifies reading file lns dasing remains untouched networking protocol storage lns remain intact fulfills requirement bitswap usage backbone protocol requesting sample global badger kvstore remain unaffected detailed design comment api definition preserved potentially improved implementation new block storage design solely additive existing storagerelated component functionality kept additional component introduced altogether existing new component recomposed serve foundation improved block storage subsystem central data structure representing celestia block data edsrsmtdextendeddatasquare new storage design focused around storing entire eds whole rather set individual share storage subsystem handle storing streamingserving block deserialization storing whole requires deserialization car format chosen edswriteeds write streamfile writeeds introduced internally reimports similarly ipldimportshares blockservice offline exchange inmemory blockstore nodevisitor save blockstore nmt merkle proofsno share note lennodelinks actual share written particular way explained creates writes header carvheader fill root field edsrowrootsedscolroots root converted cid iterates share quadrantbyquadrant order via edsgetcell writes share rowbyrow order iterates inmemory blockstore writes nmt merkle proof stored note car provides utility serialize dag file way serialize dagshareipldimportshares approach simplest traverse share merkle proof depthfirst manner packing car file however incompatible requirement able truncate car file reading first quadrant without nmt proof serialization must different utility support alternatively writeeds edsreader could introduced make edstostream handling idiomatic efficient case cost complex implementation writeeds writes whole given iowriter carv file share recomputed nmt proof func writeedscontextcontext rsmtdextendeddatasquare iowriter error edsreadeds read streamfile readeds introduced internally import empty preallocated slice note size taken carheader wrap given ioreader blockreader read block one one fill quadrant via edssetcell total sharesinquadrant amount read recomputes validates via edsrepair readeds read quadrant ioreader car file expects strictly first quadranttop left returned guaranteed full valid datahash otherwise readeds error func readedscontextcontext ioreader datahash rsmtdextendeddatasquare error edsodsreader read quadrantods full odsreader introduced constructor wrap ioreader containing generated writeeds produce ioreader read exactly similar iolimitreader size determined amount cid carheader edsstore fnsbns keep edsstore manage every disk edsstore type introduced pkg together merkle proof serializes carv file serialized carv file blob mounted dagstore via local mount registered shard introduced edsstore also maintains via dagstore toplevel index enabling granular efficient random access every share andor merkle proof every registered carv file edsstore provides custom blockstore interface implementation achieve access main usecase randomized sampling whole chain block data getting data namespace type store struct basepath string dgstr dagstoredagstore topidx indexinverted caridx indexfullindexrepo mount mountregistry newstore construct store directory store carv file eds index datastore keep invertedtoplevel index func newstorebasepath string datastorebatching store topidx indexnewinverteddatastore caridx indexnewfsrepobasepath index mount mountnewregistry mountnewregistry err rregisterfs mountfsmountfs osdirfsbasepath registration must err nil panicerr return store basepath basepath dgst dagstorenewdagstoreconfig topidx indexnewinverteddatastore caridx indexnewfsrepobasepath index mount mount note edsstore lifecycle methodsstartstop edsstoreput write entire put method introduced internally open file storepathdatahash path serializes file via sharewriteeds wrap dagstores filemount convert datahash shardkey register mount shard dagstore note registering dagstore populates toplevel index sharesproofs accessible stored scope document put store given data square datahash key square verified exchange level put store square trusting resulting file store share nmt merkle proof additionally file get indexed storeblockstore access func store putcontextcontext datahash rsmtdextendeddatasquare error edsstoregetcar read byte stream getcar method introduced internally convert datahash shardkey acquires shardaccessor return ioreadcloser note dagstoress shardaccessor extended return ioreadcloser currently return blockstore car returned ioreadcloer represents full exchanged get quadrant odsreader instead getcar take datahash return buffered reader respective serialized carv file reader strictly read full integrity verified caller must close returned reader reading func store getcarcontextcontext datahash ioreadcloser error edsstoreblockstore blockstore method return blockstore interface implementation instance providing random access share nmt merkle proof every stored required fnsbns serve request bitswap blockstore dagstore carv index note either dagstores one implement custom optimized blockstore store whole celestia block ipfs block represent merkle proof share ipfs block edit went custom implementation blockstore return ipfs blockstore providing access individual sharesnodes registered store note blockstore store whole celestia block ipfs block represent share nmt merkle proof ipfs block ipld node bitswap access func store blockstore blockstoreblockstore edsstorecarblockstore carblockstore method return readonly blockstore interface implementation instance provide random access share nmt merkle proof specific identified datahash along corresponding dah required fnsbns enable reading data namespace note returned blockstore store whole celestia block ipfs block represent merkle proof share ipfs block carblockstore return ipfs blockstore providing access individual sharesnodes specific identified datahash registered store note blockstore store whole celestia block ipfs block represent share nmt merkle proof ipfs block ipld node bitswap access func store carblockstorecontextcontext datahash dagstorereadblockstore error edsstoregetdah getdah method return dah shareroot identified datahash internally acquires shardaccessor corresponding shard read car header accessor convert header root cid shareroot verifies integrity shareroot comparing datahash getdah return dataavailabilityheader identified datahash func store getdahcontextcontext sharedatahash shareroot error edsstoreget read entire get method introduced internally get serialized ioreader via storegetcar deserializes validates via sharereadeds note unnecessary api ergonomicssymmetry nicetohave get read store given datahash read one quadrant verifies integrity stored data recomputing func store getcontextcontext datahash rsmtdextendeddatasquare error edsstorehas check edsstore keep method introduced internally convert datahash shardkey check getshardinfo return errshardunknown note unnecessary api ergonomicssymmetry nicetohave check exists given datahash func store hascontextcontext datahash bool error edsstoreremove remove stored remove method introduced internally convert datahash shardkey destroys shard via dagstore internally remove mount well remove carv file disk storepathdatahash path drop indecies note unnecessary api ergonomicssymmetry nicetohave logic dagstore investigated removing correctly implemented remove remove store given datahash clean indexing func store removecontextcontext datahash error reading data namespace generally stay unchanged minor edits shareipldgetbynamespace kept load data disk network anymore blockservice offline exchange blockstore provided edsstore shareipldgetbynamespace extended return nmt merkle proof similar shareipldgetproofsforshares ensure merkle proof duplicated extension shareipldgetbynamespace modified sharecarbynamespace returning carv reader encoded share nmt merkle proof deduplication addressing datahash allows deduplicate equal eds equality unlikely happen practice beside empty block case always produce empty blockeds empty block valid small happen early stage network body constant avoid transferring wire edsstore preinitialized empty value edsstore directory path edsstore construction expects directory store car file index path gotten based nodestorepath alternative approach extended block set share blob merkle proof global store current approach kvstore extended block single blob onlycomputing merkle proof extended block single blob merkle proof extended block set dagcar blob extended block single dagcar blob consideration tofrom carv converting performance current sync design assumes two convert car protocol layer back car storing rsmtd allocates operation individual share giant block sync allocation put significant pressure one way substantially alleviate integrate byte buffer pool rmstd disk usage increase toplevel index temporary solution index removed lns know block sample provide datahashtogether sample request bitswap removing hashtoedsfile mapping requires either facilitate implementation bitswaps auth extension proposing custom bitswap message extension subsequently blockstore implementation provided via edsstore would changed expect datahash passed contextcontext