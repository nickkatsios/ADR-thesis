adr sql performance profiling supercedes described planning approach problem profiling sql query automatically approach worked theory practically ran issue build tooling releasing application android application tool called optimizing release build part process tool remove line number class file compiled android toolchain line number typically retained application helpful examining stack trace crash field tool provides official way retain line number described practice discovered tool would remove line number release build regardless whether official way retain posed problem sql performance profiling since depended presence line number order detect sql query run order continue current method sql performance profiling would either wait issue tool fixed turn build optimization release build neither feasible time writing document decided rethink approach profiling sql query approach instead reflection based approach opted code modification approach required two step done part build process step insert profiling method every generated dao insert method delegate sql performance information reporting class available runtime method would look something like java private static measureandreportfinal string methodname final kotlinjvmfunctionsfunctiont block final long start systemcurrenttimemillis final result result blockinvoke final javatimeduration timetaken javatimedurationofmillissystemcurrenttimemillis start orgsimpleclinicsqlperformancereporterreportuserroomdaoimpl methodname timetaken return result would allow define class orgsimpleclinicsqlperformancereporter whose report method would called everytime measureandreport method would invoked step delegate dao query operation next step would delegate actual sql query operation every method dao measureandreport method considering generated method like java override public uuid currentfacilityuuid final string sql select currentfacilityuuid loggedinuser limit final roomsqlitequery statement roomsqlitequeryacquiresql dbassertnotsuspendingtransaction final cursor cursor dbutilquerydb statement false null try final uuid result ifcursormovetofirst final string tmp tmp cursorgetstring result uuidroomtypeconvertertouuidtmp else result null return result finally cursorclose statementrelease transformed method looked like java override public uuid currentfacilityuuid return measureandreportcurrentfacilityuuid final string sql select currentfacilityuuid loggedinuser limit final roomsqlitequery statement roomsqlitequeryacquiresql dbassertnotsuspendingtransaction final cursor cursor dbutilquerydb statement false null try final uuid result cursormovetofirst final string tmp tmp cursorgetstring result uuidroomtypeconvertertouuidtmp else result null return result finally cursorclose statementrelease adding step build allowed automatically capture sql performance profiling whatever level granularity implementation implementation build tool transforms generated room daos available integration simpleandroid build process reporting event analytics platform available consequence coupling generated code since approach code transformation generated code transformation quite specfic code room generates event room decides change shape generated code might spend effort updating tooling order continue reporting profiling event effort involved depends entirely degree much shape generated code changed hard measure actual impact practice however dont expect shape generated code change drastically specfic major version room switching major version upgrade room require investigation compatible build tooling proceed support generated kotlin code currently javaparser transform original room dao generate transformed source code framework however support java language kotlin language event room decides generate kotlin code instead java code look approach transforming generated daos potential might kotlin compiler plugins api framework like arrow meta