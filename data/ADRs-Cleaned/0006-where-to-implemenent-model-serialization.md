separate metadata serialization metadata class model keep helper technical story httpsgithubcomtheupdateframeworkpythontufpull problem statement course implementing classbased role metadata model also reviewed design serialization infrastructure wire format class model initial attempt implemented serialization metadata class see issue inheritance call flexibility caused rethink approach driver classbased role metadata model see adr requires serialization routine wire format tuf integrator may require custom serialization implementation custom wire format readability simplicity implementation user maintainer recognizability specification considered serialization metadata class serialization metadata subclass serialization separated metadata class compromise default serialization method metadata class nondefault serialization separated compromise serialization separated dict conversion helper method default serialization metadata class outcome chosen compromise implementing dict conversion method corresponding class idiomatic allows wellstructured code together separated serialization interface provides ease maintenance full flexibility regard custom serialization implementation wire format pro con serialization metadata class serialization implemented metadata class metadataserializeasjson etc good serialization object encapsulated within corresponding class thus structured small code chunk already existing hierarchical class model structure good tuf specification heavily based json even illustrative purpose thus facilitates recognizability bad might suggest tuf limited json alone bad facilitate custom serialization implementation bad get complicated inheritance class model note workaround exists serialization metadata subclass serialization implemented metadata subclass jsonmetadataserialize etc good wire format decoupled base class giving impression tuf limited json facilitating custom implementation bad user decide serialization ahead time instantiating metadata object bad metadata model many class would subclassed accordingly serialization separated metadata class serialization implemented independently metadata class defining abstract serializer interface must implemented subclass jsonserializer etc good wire format completely decoupled class model giving impression tuf limited json facilitating custom implementation good serve exact blueprint custom implementation bad decoupled serialization implementation reimplement entire class hierarchy likely procedural manner compromise default json serialization implemented metadata class described overridden independent serializer interface described good reason outlined encapsulation within class decoupled class model wire format bad creates two different code path default nondefault wire format making code complex prone deteriorate especially nondefault path bad ontheclass default implementation blueprint custom implementation compromise serialization implemented independently metadata class described however meat default jsonserializer conversion metadata object dicts implemented metadata class metadatatodict etc good reason outlined encapsulation within class decoupled class model wire format without disadvantage two completely different code path good make separate default serializer minimal wrapper around dict conversion method good serialization implementation might also make dict conversion method good conversion class object dicts akin type casting idiomatic implement class bad ontheclass default implementation blueprint custom implementation link adr add class complex metadata attribute driver add simple tuf role metadata model implement detail separation serialization instantiation code comment issue inheritance new metadata api add metadatainfo targetfile class recent adr discussion impetus discussion issue inheritance sslibissue add metadata container class comparison tufonaplane parser implement