adr graphql data layer discussion participant roanna james david mailtorfbdavidchaucom complete installation ariadne apollo complete graphql schema completed philipp april boxwise middle planned migration old phpbased dropapp new app based new stack pythonreact old app backend data model closely intertwined sql string written directly within php made challenging evolve data model app turn imposed many product functionality constraint slowed development time especially since dropapp data model prototype rather designed scalability productmarket fit team migrates new app explores possibility entering new market time reexamine team might benefit separation concern data layer driver scalability well support expected future change restructuring database migration etc timescale technology expected defunct developer experience given rotating environment loosely affiliated developer different background support rapid onboarding developer data structure onboarded chosen technology pleasant useful career progression standpoint maintainability expect rapid change structure expand functionality easy solution maintain evolve documentation support productionreadiness library mature enough production environment active community support channel run problem considered api style full rest interface backend would involve creation multiple endpoint resource devs request wellunderstood professional devs new devs coming data analysis background example would learn correct rest standard overunderfetching problem cause network traffic heavy difficult evolve api dont know query requesting field specific resource often lead creating one endpoint per client data layer separation concern would require devs fluent current table structure change data model paired cascading sql query change equivalent orm blended environment graphql endpoint inventory rest endpoint login logic might easier create rest endpoint login user proof concept already started rest overfetching underfetching issue user katie said preferred build everything one style point implementing login graphql single endpoint everything benefit avoids underfetchingoverfetching problem readable frontend query language super easy compared learning sql scratch enables parameterized query inherently support incremental evolution field explicitly specified query supported facebook adopted major tech company paypal github ebay etc con new kid block devs much familiar graphql concept requires devs understand concept query mutation resolvers problem easy cache rest server graphene take code first approach development reportedly lagging behind maintainer looking people take oldest python solution around likely quite stable many frustrated user reddit ariadne take schemafirst approach excellent documentation functionality designed mimic industry leader apollo server nodejs compatible python backend fewer star compared graphene however compensates somewhat spectrum support channel wellloved reddit release supported small dev shop mirumee software client apollo client wellsupported industry leader extensive documentation sophisticated caching solution large footprint previously considered hard set configure due sophistication apollo boost package make thing super simple speedy urql lightweight tiny client solution intended make graphql simple however lack one major benefit apollo client cacheing supported mediumsize dev shop younger apollo client well server graphql single endpoint everything selected paired ariadne serverside apollo client side reasoning graphql may steeper learning curve professional developer familiar standard long run scalable iteration easier maintain multiple rest endpoint future end ingesting external data apis unhcr data easier pull graphql endpoint well also favorable developer experience standpoint onboarding maintaining codebase due graphqls introspective capability humanreadable json query structure degree clientside specificity requesting fieldlevel data apollo selected clientside due maturity product robust feature including sophisticated caching excellent documentation huge community ariadne selected graphene server side due designed deliberately intended mimic apollo server ariadne active development mirumee software excellent documentation developer crossreference apollo server documentation believe outweighs con come mature library graphene finally believe performance concern could result query abstracted sql resolvers compensated load network due overfetching long query created consequence easier requesting data backend initial set complete integrating external data source readability query making change database without breaking every single existing query data structure understanding keeping track data structure relationship one another versioning difficult initial set mean cannot take advantage flask utility create rest endpoint thing like login routing initial set data schema optimizing query performance error handling graphql inherently http response code like rest potentially optimizing scalability performance within large scale distributed system reading httpsgoodapicoblogrestvsgraphql