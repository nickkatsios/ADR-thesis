object acrs text array adr supersedes adr concerning implementation access control rulesacrs raster foundry implemented mechanism called access control rule acrs determine manage update user access firstclass object project scene datasources shape workspace template analysis acrs stored table access object determined user ownership membership team organization platform directly granted access etc acrs worked fine beginning mechanism quantity object grows especially number scene acrs table quickly expanded giant one resulted slow timedout query especially scene due join union giant acr table object table user group role ugrs table taken action remedy optimizing sql query increasing instance size deleting unnecessary acr record etc looking forward find sustainable way especially speed fundamental query like scene search next section adr land still acrs combine closely object avoid join union among increasingly huge table much possible suggests consequential change adapt updated mechanism last section along underlying risk involved add text field firstclass object migrate acrs accesscontrolrules table object level acrs create gin index new field drop original acr table adapt acrrelated endpoint data model sql command property test object level text array field querying scene filtered text array filed acrs proven lot faster within copy production database proof experiment consequence format acr string acrs formerly consist three type information object type project scene etc subject type user team organization etc action view edit delete etc acrs object drop object information format acr string subject typeoptional subject idaction type text array note object granted subject type subject allview indicates object granted certain action type across entire platform serialization deserialization doobie support mapping singledimensional text liststring construct subject typeoptional subject idaction type string create data model transform list access control rule string conforming structure inserting database easily tested property based test text array acrs returned listing endpoint first class object object owner able access acrs apifist class objectobject idpermissions endpoint adaption acrrelated action crud acrs object special handling importing doobiepostgres doobiepostgresimplicits required since doobie mapping note currently deleting single permission update permission rest permission delete speak reassigning deleting permission object pas empty text acrs field term querying object filter object level acrs postgres array function arraycat concatws operator determines overlay two array etc could potentially handy listing action permission subject type potentially require going string text array could postgres array function unnest combined like match string pattern migration migration could bit tricky probably could take time run adding new field updating field firstclass object table would likely require novel approach creating temp table new column writing new permanent table dropping previous table research future issue card note acrs field empty text array default value example datasources section show initial attempt adapting acr text array solution initial test dont represent final implementation detail datasources could simple case adaptation applied firstclass object similar way data model scala jsoncodec case class datasource uuid createdat javasqltimestamp createdby string modifiedat javasqltimestamp modifiedby string owner string name string visibility visibility composite json extra json band json licensename optionstring acrs liststring jsoncodec case class objectaccesscontrolrulecreate subjecttype subjecttype subjectido optionstring actiontype actiontype val subjectid string subjectido match case somesubjectid subjectid case def toaccesscontrolrulestring string ssubjecttypetostringsubjectidactiontypetostring crud scala def getacrsbyobjectidobject datasource fragment frselect acrs datasources datasourceid def updatepermissionsobjectacrcreatelist listobjectaccesscontrolrulecreate datasourceid uuid user user connectionioint val new timestampnew javautildategettime val objectacrs objectacrcreatelistmaptoaccesscontrolrulestring val updatequery frupdate thistablef frset modifiedat modifiedby userid acrs objectacrs datasourceid updatequeryupdaterun firstclass object query filtered acrs scala def examplelistqueryuser user actiontype actiontype tablef fragment fragment val basef fragment frselect tablef val ownedf fragment frowner userid val publicf fragment frvisibility public val sharedplatf fragment frarrayall actiontypetostring val shareduserf fragment frarrayuser userid actiontypetostring val inheritedf fragment array select concatws grouptype groupid actiontypetostring usergrouproles userid userid basef owned requesting user ownedf scene publicf determine permission text array overlap operator arraycat shared platform user directly sharedplatf shareduserf inherited due membership inheritedf acrs filter note inheritedf could better practice get set user group role front separate query would easier extend practice assumed function examplelistquery either took function user usergrouproles list usergrouproles would allow rely caching parsing user group role jwt also seems magical way avoid sql around array formation list user action scala def listactionsbyuseruser user datasourceid uuid tablef fragment fragment select select unnestacrs acrs tablef datasourceid aacrs like suserid aacrs like aacrs like concat select textgroupid usergrouproles userid userid