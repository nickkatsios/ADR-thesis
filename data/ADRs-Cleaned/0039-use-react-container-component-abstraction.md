react container component abstraction deciders lauren zugai dan schomburg barry chen problem statement fxa team proposed later implemented refactoring effort move api logic component favor account class abstraction life appcontext accessible via useaccount hook working converting remainder fxacontentserver backbone react fxasettings package extending account model cumbersome account grown large essentially acting global api layer model currently must pull useaccount make api call even account data required driver large query run first useaccount call across newly converted page make api call even data required nonsettings page cause initial fetching data even available without session token mindful rely often leading tedious mocking issue like impure function possibly unintended rerenders explicit oftentimes unneeded component dependency newly converted page varying data requirement consistent pattern set model validation currently apollo client query mutation method directly instead hook ideal see info want keep presentation layer light dont want mockedprovider across test consistent error handling loading state mix error handling account component accountloading consistently reliable considered separate account authed nonauthed perpage model api layer like account validate hoc container perpage container component model validate container outcome chosen comprehensively resolve issue factor driving see prototype helped informed outcome applies react page fxasettings package setting page weve applied pattern newly refactored react page decide want handle setting may want one container component info common practice create instance apollo client root graphql application pas instance apolloprovider allowing apollo hook like usequery usemutation anywhere component tree currently create apollo client instance instead place appcontext pull account model perform query mutation away react component mentioned began pattern better separation presentation code datafetching logic make mocking easier dont mock gql queriesmutations mockedprovider though worth noting minimal test account model present choose perform operation inside react component apolloprovider apollo provided hook must continue apolloclientquery apolloclientmutate however potential downside associated method worth considering approach uncommon documentation example much sparse method tied react lifecycle causing manual management loading error state well manually handling state update since automatically cause rerender polling check account session signin signup sync screen slightly complicated apollo client query method doesnt support polling box hook reference apolloclientquery polling setinterval clearinterval note cant apollo client subscription database realtime functionality also worth noting prior refactor account custom mockedprovider called mockedcache aid testing boilerplate custom usemutation hook reported network error sentry see doc explain proposed keep gql one layer make easier refactor away gql ever desire future compared abstracting mutation performing query page component example would mockedprovider almost test pro con separate account authed nonauthed fxa team held preliminary meeting frontend architecture initially noted splitting account model authenticated nonauthenticated version could address least concern lot account data requires session token access global useaccount query attempt fetch data regardless sessiontoken suggested prior identifying problem driver ideal solution would still two large model overlapping method may difficult split later address related concern though better inversion control could help viable perpage model api layer like account validate hoc container description instead single account model provides api layer account data create one per page continue apolloclientquery apolloclientmutate continue referencing modelapicallhandler component pas dependency page component rather store page validation create separate model containing data validate create hoc container component perform validation similar current linkvalidator component pro con good better inversion control keeping similar pattern good allows move away useaccount hook make easier see data fetched per page bad preferable hook apolloclient direct method bad apolloclient authclient singleton would pas every new page model alternatively always pull bad loading error state may still inconsistent without refactoring perpage container component model validate container see prototype helped informed outcome description every page component api call data validation corresponding container component handle wrap application apolloprovider container component execute query mutation hook perform api call container component includes usequery pagespecific needed data stored read apollo cache future query usemutation mutation authclient call refactored gql handle error processing container component page validation create separate model containing data validate perform validation container component pro con good container component common pattern approach provides better separation concern among apinetworkbusiness logic layer data model presentation layer good flexibility inversion control wont mock entire model partial unknown account type casting instead mock handler result writing pagelevel test good allows move away useaccount hook make easier see data fetched per page good placing validation api handler location explicit clear good benefit gained apollo client hook see info goodneutral create consistent error handling container component prototype shown likely want manually handle loading state page component good pattern setting smooth able apollo client result object error loading data state neutral gql related container test require mockedprovider test presentationpagelevel require mockedprovider standard testing apollo client give higher degree confidence api layer another testing tool engineer familiarize neutral isolate change nonsettings page first without taking massive refactoring effort differing pattern two may feel awkward