adrappsetupandgoals title application setup goal create application without dependency raster foundry following capability run model imagery kick model run learns new imagery run model without knowing anything content model summarize past model result allow user respond model run event additionally wed like application meet several design goal arent core pursuit feature deploy continuously infrastructure kept light possible main question adr seek answer api work communication external world api api model runner work adr attempt answer question user interface accomplish since germane shortterm three monthish envision project specific component summary datamodel application includes three core entity modeled scala case class without import without bookkeeping field like scala area interest case class aoi geographic bounding box imagery must intersect geom projectedgeometry largest acceptable ground sampling distance new imagery targetresolution double required wavelength image band must overlap wavelength listdouble model aoi associated modelid uuid model case class model name model modelname string job definition run prediction model container cant overridden job definition must know job submission time jobdefinition string description prediction command new image notification endpoint appended command liststring model run result case class prediction model prediction modelid uuid aoi prediction aoiid uuid absolute uri geojson holding result prediction uri uri model renamed something overloaded developer sanity later new imagery outside world new imagery becomes available outside world application match model interested kind imagery requires tracking kind metadata incoming imagery developed fairly complex datamodel raster foundry track information imagery including component file imagery bandlevel information however spec best knowledge one relies raster foundry datamodel describe imagery update look like instead api demand incoming imagery adheres stac electrooptical spec extension several reason prefer stac datamodel include tapping ongoing work geospatial community standardize data exchange making validation easier anyone hoping rely api reusing work around typesafe stac datamodel geotrellisserver running model new imagery posting new image api cause image matched available model model function raster raster raster geojson raster number simplicity well start raster geojson case since save complexity figuring kind contract enforce kind model sufficient object detection chip classification semantic segmentation task model know sort imagery acceptable obtain meaningful result array bandwidth requirement minimum spatial resolution aoi determine information incoming imagery adheres spec band information model also know requirement run particular sufficient information able fill submitjob request aws batch includes resource requirement docker container accessible within hosting aws account compute environment name command run require model carry information avoid infer guess based heuristic identify model run image well kick aws batch job model parameter model command must accept stac item extension last parameter important security concern compute environment running model must vpc general internet access least gateway make post request application without access database prevent user even user whove somehow compromised database credential executing arbitrary code team take responsibility deployment code make sure resulting configuration pass check notifying api since model run asynchronous workflow theyll way notify api form notification take stac item labeling extension reason lean stac similar reason leaning new imagery api accept post particular model contains stac item asset point prediction new agery possible future work could allow discrimination prediction time run asynchronous process model synchronous prediction since dont know necessary even possible well assume prediction happen asynchronously update granary api happen via later post request notifying end user create model also create aws simple notification service topic model purpose think inexhaustible resource since aws account allowed topic time future think danger going limit think new strategy ask service limit increase whenever model updated either new prediction run kicked result available metadata model changed well send event topic model application deployable aws account including client account assume client also ability subscribe topic subscribe notification impact continuous deployment several consequence choice aim continuous deployment continuous integration check passing must mean branch safe deploy require care around migration usual thorough exercise application test raster foundry long repository api probably mean generative testing workflow modeled api interaction correctness performance regression believe already tool expertise team application also include smoke test smoke test new feature able rely small application scope ensure define reasonable standard fire repository probably shouldnt follow git flow pattern since relationship develop master pretty confused develop master time currently develop consistency avoid appearance made choice final adr reviewed enable frontend change without backends ready work sensible story feature flag well also enable backend change even breaking way without frontend needing know care likely candidate solve latter problem api versioning later adrs address implementation detail problem impact keeping infrastructure light possible one example motivation already played choice run model originally considered two possibility submit model run first demand consumer deploy server somewhere accepts post new imagery responds information output written eventually notifies granary api fetch imagery second whats written chose requires infrastructure another aws service creation compute environment job definition role necessary running batch job case possible part motivation lot work given service designed data scientist easily run prediction new imagery weigh increase infrastructure complexity presumed potential user since believe potential user strike zone likely includes creating docker container running prediction deploying restful modelasaservice potentially asynchronous task runner chose granary particular piece infrastructure complexity second example choice notification service include webhooks application user would tell granary wanted notification sent would required understand availability characteristic endpoint well model application possibility user might want multiple service notified instead pushing trade consuming small part another aws service api needing model respond appropriately unbounded set external resource allows achieve clear separation concern consequence chose continuous deployment well revert default branch master create pull request template express constraint weve committed choosing continuous deployment set deploy every merge master well also standard startup work new scala backend much work free thanks azaveag template however well create datamodel daos route good dont think much elaboration detail come implementation think well also make deployment code life since supposed open source portable think make sense bring deployment open source repository downside open source tool come vendor lockin hand deployment life separately small open source tool probably never deployed anyone else