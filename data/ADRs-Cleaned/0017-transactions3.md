twostage encoding transaction table value transaction cassandra timestamps value cassandra written together timestamp note differs column column atlasdb schema operation cassandra typically wallclock time server paxos completed timestamp writes applied multiple node quorum disagree reading value key latest write win pick value highest write timestamp however returning perform blocking read repair update dissenting node quorum information latest write update happens return value user important correctness protocol cassandra lightweight transaction weakness known consistency issue cassandra checkandset operation operation occurs following happens cassandra implemented storageproxycas round paxos phase run paxos state stored paxos system table round paxos successful proposed evaluated value read fails match expected value successful request made seeking paxos round committed node applies mutation proposed paxos round committed node part response handler plus node block get read consistency many node quorum eachquorum possible may fail second third substep step however node may performed mutation recommended successful paxos round others user receiving failure response response seems fine long ensure relevant paxos round value read resolved practice accomplished serial consistency level however reading serial costly furthermore another problem cassandra ttl system keyspace hour includes paxos system table cassandra keep track paxos promise thus failed mutation actually applied node followed extended failure network partition could result inconsistent read particular supposing threenode cluster successful value coordinator successfully applied mutation quorum read cell could read quorum chosen quorum included value newer assuming weird writetime shenanigan problem atlasdb rely putunlessexists transaction table cassandra practice mean transaction given timestamp could read committed uncommitted furthermore possible quorum node believe transaction uncommitted decide transaction rolled back would accept putunlessexists cell interpreted atlas meaning transaction aborted range movement cassandra determines node participate paxos based replication group relevant key however may change runtime change cluster topology naturally lead disjoint quorum cassandra currently resistant case would require substantial change paxos algorithm thus treating dealing case outside scope proposal criterion good solution problem demonstrate following characteristic repeatable read nonnull value commit timestamp aborted read table given timestamp future read return value primary issue current system eventual read efficiency eventually reading cell transaction table require rpc atlasdb coordinating cassandra node within cassandra rpc pair cassandra node relevant replication group write efficiency writing cell transaction table require rpcs possible bearing mind constraint optimising property important two theory pue table want define putunlessexists table support two operation putunlessexists get interface may look superfluous keyvalueservice interface already similar endpoint must support repeatable read java public interface putunlessexiststable void putunlessexistsmultiplemap keyvalues throw keyalreadyexistsexception listenablefuturemapk getiterablek key primitive define putunlessexists value pair value state enumeration state indicates whether value staging committed java public interface putunlessexistsvalue value putunlessexistsstate state public enum putunlessexistsstate staging committed perform write putunlessexists value following protocol noting kvslevel operation puev staging putv committed perform read following protocol read current value database committed return present return null staging perform casv staging staging perform putv committed return notice protocol meet criterion outlined eventual read efficiency steady state value going committed read protocol committed value involves single read quorum consistency argument read consistency bit subtler found appendix adr intuitively protocol put committed value writer reader know quorum node value written staging never change value moving staging committed read committed value transaction service putunlessexists table provide implementation transaction service functionality required transaction service essentially match putunlessexiststablelong long arent actively aware improvement ticket encoding strategy transaction cell strategy figuring put individual value put problem one challenge face working cassandra choose suitable timestamps writes cassandra seems willing tolerate inconsistency clock drift allowed atlasdb lightweight transaction cassandra apply writes serverside timestamp coordinator though combined bit conditional logic ensures write take place term paxos another one writetime greater assuming paxos consistent fine however write protocol performs hard put second step choose timestamp settled choosing large constant maximal timestamp hard put exceed reasonable timestamps wed encounter practice still allow deletion user perform clean transaction range workflow part backup restore plausible could included exposing new endpoint cassandra thrift api copy get timestamp later whats logic allows user hit directly would require new endpoint thus new dependency cassandra fork making rollout messy second step write protocol casv staging committed requires another round paxos writes implementation define putunlessexiststablek interface described switch transaction service rather keyvalue service directly useful allows avoid change transaction service logic much deployment keyvalueservices dont actually problem oracle postgres simply instantiate much simpler implementation pass relevant call keyvalue service part needed rework checkandsetcompatibility classification keyvalue service separately track failure detail consistency guarantee remainder section largely focus implication deployment running cassandra consensus forgetting store introduce new abstraction consensusforgettingstore table intended capture behaviour cassandra identified read repeatable still remain consistency guarantee define main operation consensusforgettingstore required support protocol outlined java public interface consensusforgettingstore atomic put unless exists operation method throw exception consistency guarantee subsequent pue may succeed fail nondeterministically subsequent get may return optionalofvalue optionalempty even optionalofothervalue another pue failed past nondeterministically void putunlessexistscell cell byte value throw keyalreadyexistsexception atomic operation verifies value cell successful link consensusforgettingstoreputcell byte called subsequent get guaranteed return optionalofvalue subsequent pue guaranteed throw keyalreadyexistsexception void checkandtouchcell cell byte value throw checkandsetexception listenablefutureoptionalbyte getcell cell put operation offer consistency guarantee exception thrown multiple put cell different value may result nonrepeatable read void putcell cell byte value note multicell version actual implementation omitted interest conciseness implementation method generally involve passing value perhaps small amount wiring nonetheless interface useful allows simulate legitimate failure layer part testing resilientcommittimestampputunlessexiststable implement putunlessexiststablek interface consensusforgettingstorek applying protocol discussed theory section also make going store tablelevel key value keyvalue service implemented twophaseencodingstrategy discussed earlier reuse logic ticketsencodingstrategy encoding start timestamp key cell ensures still profit performance optimisation written specifically transaction shared modulus generation timelock protection overall hotspotting opted reuse transaction table avoid unnecessary overhead cassandra reasoning justify specific table parameter tuned specific way remains valid transaction value also reuse ticketsencodingstrategys deltaencoded varlong simply append one byte end value staging value committed value primary concern would space readability optimal space consider likely method achieve better efficiency adding one bit rather one byte also since majority value committed could simply zero byte staging one committed probably value relative simplicity approach well defense user attempting read data incorrect encoding strategy deployment testing much work transaction schema version done transaction general easily repurposed one simply set targettransactionsschemaversion configuration going required schema lease process transaction set existing transaction test become parameterised run legacy transaction schema curiously time transaction written wired also implemented simulated test version consensus forgetting store forget value configurable probability fuzz test putunlessexists table give stronger evidence protocol safe implemented correctly considered one possible solution could perform read serial consistency override default system keyspace ttl cassandra longer however would still pick reasonable bound paxos log content system keyspace could kept furthermore read serial consistency achieve eventual read efficiency require cassandra node perform round paxos internally adding two rpcs coordinator act paxos proposer node another possible approach involves state machine user allowed propose value part read protocol opposed required commit staging value written author think could probably work difficult reason one concerned behaviour concurrent proposal whether dueling proposersstyle situation possible consequence transaction rolled globally cassandra deployment longer exposed correctness bug hope though dont strong evidence owing small sample size extreme difficulty root causing reduce incidence atlasdb corruption ticket general backup restore workflow case manually manipulate one transaction table aware new serialized form exist particular transaction table read isolation without caution value unambiguous indicating whether written transaction transaction user aware staging value safe though final possible even likely performance transaction worse transaction strictly work value passed database strictly larger however dont expect add constant amount overhead small steady state isnt fair comparison case transaction approach correct appendix proof read consistency first prove lemma lemma first time quorum node latest writes contains combination staging committed longer possible write anything staging committed clear condition satisfied pue value cannot succeed since every read include recent write remains show two put protocol putv committed assume write protocol putw committed must successful puew staging since operation would satisfy condition lemma implying pue must occurred quorum node latest writes already contained contradiction since pue would failed assume read protocol casw staging staging must staging written condition lemma satisfied choose earliest write one replicated read could result pue also could result earliest write read part would read latest value quorum node assume read protocol putw committed similarly successful casw staging staging must occurred beforehand condition lemma satisfied follows proof prove second lemma lemma committed written longer possible write anything staging committed committed written put write protocol must followed successful puev staging quorum node staging satisfying lemma written put read protocol must followed successful casv staging staging satisfying lemma result soon committed written committed never written since protocol return committed value point onwards returned ergo repeatable read