stripe typing management strategy deciders julian poyourow ben bangert reino muhl problem statement stripe typing create frequent challenge subplat team subplat stripehelper contains number typecasts introduce potential runtime bug make harder reuse code without knowing internal implementation detail ecosystem want move library encapsulate complexity consumer library strong foundation typing give predictable behavior given set input driver want performant solution want solution give reasonable amount typesafety want solution introduce significant mental overhead complexity considered full set generic overriding stripe default typing system leverage library wrapper stripe exporting custom type library disableblock usage stripe expand property always query field expanded throw errorsassert helper receives unexpected value narrow type outcome chosen fallback best blend major drawback maintenance cost complexity best alternative experience issue implementing low cost introduce costly maintenance complexity infeasible team would faciliated creating stripe library wrap call stripe apply correct type util stripe type custom type would live library well fall back assertion util would also live stripe library pro con full set generic overriding stripe default typing system description create full set generic override default stripe return type stripedts file application would work type stripesubscriptionstripecustomer call stripe would generic would infer return type based expanded property passed small wrapper library would required separate definition field typesonly implementation would probably enough since type function requires stripesubscriptionstripecustomer could passed stripesubscriptionstripecustomer stripepaymentmethod since defaultpaymentmethod property would compatible type would require small wrapper library separate type separate field pro con good nicest api interact wish stripe originally provided box bad obfusticates interaction stripejs since stripe truly return type bad create library map property stripejss response bad tremendous amount take maintain time bad likely overkill usecase leverage library wrapper stripe exporting custom type library description stripe lib cast stripe result type top response type set work defined subset typing fully encapsulate stripe typing application would work type subscriptioncustomer customer subscription type defined maintained come stripe lib codebase pro con good solves obfustication issue stripejs good still nice api interact good maintains ability expand property bad create library map property stripejss response bad quite bit maintain bad likely overkill usecase disableblock usage stripe expand property description never expanded property create generic infers provided property actually type string null override stripe type specify expand property though would add additional complexity specifically necessary application behavior expanded property always string null application could work normal stripe type stripesubscription stripecustomer either override stripe type stripedts file somewhat complex contain nonexpanded type associated property wrap call stripe returnoverride return type generic narrow type specified property contain nonexpanded type associated property pro con good least effort good match bad cant expand would cast unlikelyunusual case absolutely expand always query field expanded description require property expanded time create generic infers property would expanded actually type string application behavior expanded property always expanded type application would work normal stripe type stripesubscription stripecustomer overridden via stripedts file contain expanded type associated property pro con good always data expanded field bad expect major performance issue stripe recommend behavior throw errorsassert helper receives unexpected value narrow type description stripe library normal document associated function signature given method specific property expanded assert utility given property present needed prop narrow type assertion pass pro con good zeroeffort bad there compiletype validation bad escapehatch typescript provide type validation bad likely author miss required expanded prop given method cause runtime error bad likely instance devs end situation end expanded property inhand due external force call method requires nonexpanded property viceversa