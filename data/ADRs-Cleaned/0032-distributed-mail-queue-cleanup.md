distributed mail queue cleanup lazy consensus implemented read distributed mail queue full enqueuedmailsv deletedmailsv never cleaned corresponding blob always referenced ideal privacy space storage cost point view note enqueuedmailsv deletedmailsv rely timewindowcompactionstrategy add new contentstart table referencing point time given mailqueue hold data mail queue value contained contentstart browsestart safely deleted perform cleanup upon browsestartupdate finished browse delete content enqueuedmailsv deletedmailsv contained contentstart new browsestart safely set contentstart new browsestart content browsestart safely considered deletable applicatively longer exposed dont additional grace period mechanism contentstart failing cleanup lead content eventually updated upon next browsestart update furthermore delete blobstore content upon dequeue also mail deleted purged via mailqueue management apis consequence cassandra sstable browsestart safely dropped part timewindowcompactionstrategy updating browse start two time expensive unreference passed slice eventually allow reclaiming cassandra disk space enforce mail privacy removing dandling metadata proposal made piggy back cleanup upon dequeuedelete operation dequeuerdeleter directly remove related metadata enqueuedmailsv deletedmailsv simpler design however several flaw cleanup fails reason cannot retried future way cleaning related data end tumbstoning live slice potentially harming browsedeletebrowse start update performance proposition dont leverage efficiently timewindowcompactionstrategy reference jira