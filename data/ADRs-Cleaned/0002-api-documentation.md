adrapidocumentation title api documentation granary standalone deployable open source application user primary way interacting granary rest api rather least foreseeable future focus put larger burden usual quality api documentation wed like evaluate different way keep api documentation uptodate strategy want know general pro con find doc drifted api document different version api time contender evaluated three software solution rely codedocumentation generation also process solution three library considered rho tapir guardrail software solution created small repository manual api spec maintenance successful way weve done past specfirst development pattern pattern added endpoint api spec implemented spec change merged drifted away time eventually wound checklist item pull request template specified api spec updated long time spec wasnt valid swagger found tried create doc site part spec incorrect found user attempted spec api interaction though problem well find doc drifted api way answered question spec make sure happy path least correctly documented generated python client yelp bravado library interact api without error manual process relied heavily python client repository different strategy could consider would generate scala client hosted version spec swaggerhub ensure drop data model generated client place existing data model testing would require investing software development time tooling another rely upcoming panrec feature parse generated client datamodel existing datamodel ensure agree strategy ensure data model correct without detecting whether weve moved route thats consistency check beyond weve done still leaf lot room get spec exactly right way make spend potential support time triaging issue responding help request spec maintenance document different version api time strategy ive come manual maintenance version lot copying pasting supposing route exists vmodels another route exists vmodels dont know openapi share thing two endpoint later change like adding new response type think would manually written place sound like headache tapir change generate doc tapir doc served localhostapihellodocsyaml put directly swagger editor tapir library separating description apis implementation interpreting description different output example endpoint description interpreted documentation yaml string server given function map input described endpoint output described endpoint endpoint tapir explicitly encode input type output type error endpointi map input type output type returning error type stream type far needed stream type anything tapir make easy add input endpoint chain call endpoint add output add metadata name description worst thing happened tapir accidentally wound unreachable route seems like tapir http interface want mount service onto path routerv new vapi new vapi instead include path component endpoint description tested serving doc algebraic data type adding authenticated route make sure understood path work straightforward adt response correctly encoded oneof default response left authentication function instead thats primarily consequence extremely simplified endpoint dont know encode specific error cant anything discriminate response return tapir endpoint also interpreted client test feature find doc drifted api doc cannot drift api doc server interpretation endpoint document different version api time think separating endpoint component authentication doc mention defining auth input first shared many endpoint believe could something similar version input scala object endpoint val endpointinv val endpointinv val scenesendpointv vinscenes val scenesendpointv vinscenes versioned collection endpoint could served version prefix rho change generate doc rho doc served localhostapihelloswaggerjson put directly swagger editor rho library http ecosystem automatically generating swagger documentation alternative routing dsl route parameter description combined routing logic create rhoroutesf transformed normal httproutesf rhomiddleware also serf api documentation json configurable endpoint worst part rho keep number odd operator head example capturing query parameter specifying response type adding description binding route function business logic possible something wed get time look write rho generates swagger openapi specification json access oneof keyword describing response might one several different schema generated json included one error json schema generated endpoint returning circe json type missing referred route find doc drifted api doc cannot drift api rhomiddleware creates doc route actually document different version api time service serve doc mounting service http router also mount documentation service guardrail guardrail http support currently documented investigate library tapir automatically generating api documentation adt support straightforward api input output auth extractor auth flatten learning curve well stable correct reference point api documentation user setting deployment refer call beginning readme hopefully save answer entire category question consequence first route added api slightly difficult theyll include writing api route new library first time readme updated point location api documentation