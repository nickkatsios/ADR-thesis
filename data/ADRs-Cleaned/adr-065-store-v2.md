adr store changelog feb initial draft alexanderbez dec update implementation alexanderbez abstract storage state primitive cosmos sdk based application large changed since launch inaugural cosmos hub demand cosmos sdk based application developer client perspective evolved outgrown ecosystem since primitive first introduced time application gained significant adoption many critical shortcoming flaw exposed state storage primitive cosmos sdk order keep evolving demand client developer major overhaul primitive necessary cosmos sdk provides application developer various storage primitive dealing application state specifically module contains merkle commitment data structure iavl tree data structure module store retrieve keyvalue pair along merkle commitment proof keyvalue pair indicating exist global application state data structure base layer kvstore addition sdk provides abstraction top merkle data structure namely root multistore rms collection module kvstore rms application serve query provide proof client addition provide module access unique kvstore though storekey ocap primitive layer abstraction sit rms underlying iavl kvstore gaskvstore responsible tracking gas consumption state machine read writes cachekvstore responsible providing way cache read buffer writes make state transition atomic transaction execution governance proposal execution critical drawback layer abstraction overall design storage cosmos sdk since module iavl kvstore commitment atomic note still allow module iavl kvstore iavl library support ability pas instance argument various iavl apis since iavl responsible state storage commitment running archive node becomes increasingly expensive disk space grows exponentially size network increase various performance bottleneck start emerge many area query performance network upgrade state migration general application performance developer poor allow application developer experiment different type approach storage commitment along complication many layer abstraction referenced see storage discussion information previous attempt refactor storage layer described adr however approach mainly stem short coming iavl various performance issue around partial implementation adr never adopted variety reason reliance smt research phase design choice couldnt fully agreed upon snapshotting mechanism would result massive state bloat propose build upon great idea introduced adr bit flexible underlying implementation overall intrusive specifically propose separate concern state commitment needed consensus state storage needed state machine client reduce layer abstraction necessary rms underlying store remove unnecessary store type implementation cachekvstore simplify branching logic ensure rootstore interface remains lightweight possible allow application developer easily swap backends furthermore keep iavl default backend time might fully settle iavl long term strong empirical evidence suggest better given sdk provides interface store sufficient change backing commitment store future evidence arise warrant better however promising work done iavl result significant performance improvement note provide application ability iavl iavl either backend latter showing extremely promising performance improvement iavl cost state migration separating separating allow optimize primary case access pattern state specifically layer responsible direct access data form key value pair whereas layer iavl responsible committing data providing merkle proof state commitment foremost design goal backends easily swappable necessarily iavl end scope reduced must provide stateful root app hash height resulting applying batch keyvalue setdeletes height fulfill though necessarily provide historical proof height provide api snapshot createrestore fulfill state sync request implementation may choose provide historical proof past height due time space constraint since store defines api historical proof least one configuration given backend support state storage goal provide modular storage backend multiple implementation facilitate storing versioned raw keyvalue pair fast embedded database responsibility function include following provided fast efficient query versioned raw keyvalue pair provide versioned crud operation provide versioned batching functionality provide versioned iteration forward reverse functionality provide pruning functionality functionality provided backend work versioned scheme user able get store iterate key latest historical version efficiently store key namespacing purpose propose three defaulting backends application choose rocksdb cgo based usage userdefined timestamps builtin versioning mechanism pebbledb native manual implementation mvcc key versioning sqlite cgo based single table state since operator might want pruning strategy differ compared tight pruning strategy looser pruning strategy propose introduce additional pruning configuration parameter identical exists sdk today allow operator control pruning strategy layer independently layer note pruning strategy must congruent operator state sync configuration allow state sync snapshot execute successfully otherwise snapshot could triggered height available state sync state sync process largely unaffected separation layer however node syncs via state sync layer node state synced height available since iavl import process setup way easily allow direct keyvalue insertion propose simple snapshotmanager consumes produce snapshot backends responsible providing snapshot state given height consume snapshot restore state rootstore define rootstore interface default implementation primary interface application interact rootstore responsible housing backends specifically rootstore provide following functionality manage commitment state provide module access state query delegation get value tuple providing commitment proof store key naturally single tree rootstore implementation notion store key becomes entirely useless however cannot dictate predicate application implement roostore choose since app choose multiple tree keep notion store key unlike store represent store key simple string opposed concrete type provide ocap functionality store key string act solely provide key prefixingnamespacing functionality module proof since layer naturally storage layer without commitment key value pair cannot provide merkle proof client query providing inclusion exclusion proof via commitmentop type responsibility backend retrieving proof done rootstore internally route request backend commitment abci specifically finalizeblock introduced flow state commitment baseapp defined writes written rootmultistore single commit call rootmultistore abci commit method advent abci commitment flow changed workinghash called finalizeblock commit called abci commit note workinghash actually commit state disk rather computes uncommitted workinprogress hash returned finalizeblock abci commit phase state finally flushed disk store must respect flow thus caller expected call workinghash finalizeblock take latest changeset rootstore writes tree single batch return hash finally abci commit phase call commit rootstore commits tree flush changeset backend consequence result new store package expect see improved performance query transaction due separation concern also expect see improved developer around experimentation commitment scheme storage backends performance addition reduced amount abstraction around kvstores making operation caching state branching intuitive however due proposed design drawback around providing state proof historical query backwards compatibility adr proposes change storage implementation cosmos sdk entirely new package interface may borrowed extended existing type exist store existing implementation interface broken modified positive improved performance independent layer reduced layer abstraction making storage primitive easier understand atomic commitment redesign storage type interface allow greater experimentation different physical storage backends different commitment scheme different application module negative providing proof historical state challenging neutral removal ocapbased store key favor simple string state retrieval namespacing consider neutral removal ocap functionality seen negative however simply moving ocap functionality upstream kvstore service layer shouldnt concern ocap responsibility keeping iavl primary commitment data structure although drastic performance improvement made discussion module storage control many module store secondary index typically solely support client query actually needed state machine state transition mean index technically reason exist layer take unnecessary space worth exploring api would look like allow module indicate key value pair want persisted layer implicitly indicating layer well opposed persisting key value pair layer historical state proof clear importance demand within community providing commitment proof historical state solution devised rebuilding tree fly based state snapshot clear performance implication solution reference httpsgithubcomcosmosiavlpull httpsgithubcomcosmosiavlpull httpsgithubcomcosmoscosmossdkissues httpsdocsgooglecomdocumentdepacxvscffxzmvsrsacopoxgqysmaugjylwryyjasfnhfxrijorqljzxtavlxlpsicfzjhyhpub